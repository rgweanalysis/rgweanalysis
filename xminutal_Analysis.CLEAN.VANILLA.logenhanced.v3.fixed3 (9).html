<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>X‚ÄëMinutal Analysis ‚Äî Soft UI</title>



  <style>
    /* =====================
       Design tokens (Soft UI)
       ===================== */
    :root {
      --bg: #f7fafc;
      --panel: #ffffff;
      --panel-2: #f8fbff;
      /* Accent colors tuned to match the Ras Ghareb logo (turquoise/blue) */
      --accent: #13a1c7;     /* main */
      --accent-600: #0b718f; /* hover/pressed */
      --accent-700: #086076;
      --text: #0f172a;
      --muted: #64748b;
      --border: #e2e8f0;
      --ring: rgba(37, 99, 235, 0.35);
      --row: #ffffff;
      --row-alt: #f6faff;
      --row-hover: #eef6ff;
      --table-head: #0b61e5;
      --table-head-text: #ffffff;
      --chip: #eaf2ff;
      --chip-text: #2152cf;
      --shadow-sm: 0 1px 2px rgba(16, 24, 40, 0.04);
      --shadow-md: 0 6px 18px rgba(16, 24, 40, 0.10);
      --radius: 12px;
      --radius-lg: 16px;
      --radius-pill: 999px;
      --transition: 180ms ease;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0b1220;
        --panel: #0f172a;
        --panel-2: #0b1220;
        /* Accent colors tuned for dark mode to match the Ras Ghareb logo */
        --accent: #50bcd3;
        --accent-600: #8fd1de;
        --accent-700: #72c3d2;
        --text: #e6edf7;
        --muted: #97a6ba;
        --border: #1e293b;
        --ring: rgba(99, 162, 255, 0.4);
        --row: #0f172a;
        --row-alt: #0b1220;
        --row-hover: #172133;
        --table-head: #1e3a8a;
        --table-head-text: #e6edf7;
        --chip: #11213f;
        --chip-text: #9bc2ff;
        --shadow-sm: 0 1px 2px rgba(0,0,0,0.35);
        --shadow-md: 0 8px 24px rgba(0,0,0,0.45);
      }
    }

    /* Base layout */
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji","Segoe UI Emoji";
      background-color: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      letter-spacing: 0.1px;
    }

    /* Topbar */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 50;
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      box-shadow: var(--shadow-sm);
      backdrop-filter: saturate(160%) blur(2px);
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 18px;
      color: var(--text);
    }

    /* Logo within the brand header */
    .brand .logo {
      height: 34px;
      margin-right: 6px;
    }
    .brand::before {
      content: "";
      width: 10px; height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--accent), var(--accent-700));
      box-shadow: 0 0 0 6px rgba(37,99,235,0.10);
    }
    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .soft-btn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      border-radius: var(--radius-pill);
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition), box-shadow var(--transition), background var(--transition), border-color var(--transition);
    }
    .soft-btn:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
    .soft-btn:active { transform: translateY(0); }
    .soft-btn:focus-visible { outline: none; box-shadow: 0 0 0 4px var(--ring); }
    .soft-btn.primary {
      color: #fff;
      background: var(--accent);
      border-color: var(--accent);
    }
    .soft-btn.primary:hover { background: var(--accent-600); border-color: var(--accent-600); }

    /* Main container */
    .container {
      display: flex;
      flex-direction: row-reverse; /* keep sidebar on the right */
      min-height: calc(100vh - 58px);
      gap: 16px;
      padding: 16px;
    }

    /* Sidebar */
    #sidebar {
      width: 320px;
      background-color: var(--panel);
      padding: 16px;
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-sm);
      overflow-y: auto;
      flex-shrink: 0;
      max-height: calc(100vh - 90px);
      position: sticky;
      top: 82px;
      transition: transform var(--transition), opacity var(--transition);
    }
    #sidebar h2 {
      color: var(--text);
      margin: 0 0 12px 0;
      font-size: 16px;
      font-weight: 700;
    }
    .section {
      margin-bottom: 16px;
      padding: 12px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }
    .section label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
      color: var(--text);
      font-size: 13px;
    }
    .section input[type="date"],
    .section input[type="time"],
    .section input[type="text"],
    .section input[type="file"],
    .section select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      font-size: 14px;
      background: var(--panel);
      color: var(--text);
      transition: border-color var(--transition), box-shadow var(--transition);
    }
    .section input:focus-visible,
    .section select:focus-visible {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 4px var(--ring);
    }
    .section button {
      width: 100%;
      padding: 10px 12px;
      margin-top: 8px;
      border: 1px solid var(--accent);
      border-radius: var(--radius);
      background-color: var(--accent);
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      transition: background-color var(--transition), transform var(--transition), box-shadow var(--transition);
      box-shadow: var(--shadow-sm);
    }
    .section button:hover { background-color: var(--accent-600); transform: translateY(-1px); box-shadow: var(--shadow-md); }
    .section button:focus-visible { outline: none; box-shadow: 0 0 0 4px var(--ring); }

    /* Category filter styling */
    .category-list { display: grid; grid-template-columns: 1fr; gap: 6px; }
    .category-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      cursor: pointer;
      color: var(--text);
    }
    .category-item input { margin: 0; cursor: pointer; }

    /* Filter buttons grouping */
    .filter-buttons {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }
    .filter-buttons button {
      border-radius: var(--radius);
      border: 1px solid var(--accent);
      background: var(--accent);
      color: #fff;
      font-size: 13px;
      padding: 8px 10px;
      box-shadow: var(--shadow-sm);
      transition: transform var(--transition), box-shadow var(--transition), background var(--transition);
    }
    .filter-buttons button:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); background: var(--accent-600); }

    /* Turbine + Variable lists */
    #turbineList, .variable-list {
      max-height: 260px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 10px;
      background-color: var(--panel);
    }
    .variable-item, .turbine-item {
      padding: 8px 10px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      transition: background var(--transition);
    }
    .variable-item:last-child, .turbine-item:last-child { border-bottom: none; }
    .variable-item:hover, .turbine-item:hover { background-color: var(--row-hover); }
    .variable-item.selected { background-color: var(--accent); color: #fff; }
    .turbine-item.selected { background-color: var(--table-head); color: #fff; }

    /* Main content */
    #main {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }
    #main h1 {
      margin: 6px 6px 0 6px;
      color: var(--text);
      font-size: 18px;
      font-weight: 700;
    }

    /* Data area card */
    #dataSection {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      padding: 12px;
      box-shadow: var(--shadow-sm);
    }
    #tableContainer {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      min-width: 0;
      border-radius: var(--radius);
    }
    table {
      width: max-content;
      border-collapse: collapse;
      margin-top: 8px;
    }
    th, td {
      padding: 8px 10px;
      border: 1px solid var(--border);
      white-space: nowrap;
      font-size: 13px;
    }
    th {
      background-color: var(--table-head);
      color: var(--table-head-text);
      position: sticky;
      top: 0;
      z-index: 2;
      text-align: left;
    }
    tbody tr:nth-child(even) td { background-color: var(--row-alt); }
    tbody tr:nth-child(odd) td { background-color: var(--row); }
    tbody tr:hover td { background-color: var(--row-hover); }

    /* Chart wrappers */
    #chartContainer, #powerChartContainer {
      margin-top: 14px;
      position: relative;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow-sm);
      overflow: hidden;
    }
    #chartCanvas, #powerChartCanvas {
      width: 100%;
      height: 700px;
      background-color: var(--panel);
    }
    #powerChartCanvas { height: 360px; }

    /* Pagination controls */
    .pagination {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      position: sticky;
      bottom: 0;
      background-color: var(--panel);
      padding: 8px 0;
      border-top: 1px solid var(--border);
      z-index: 1;
    }
    .pagination button {
      padding: 6px 10px;
      border: 1px solid transparent;
      background-color: var(--chip);
      color: var(--chip-text);
      border-radius: var(--radius-pill);
      font-size: 12px;
      cursor: pointer;
      transition: background var(--transition), transform var(--transition), box-shadow var(--transition);
      box-shadow: var(--shadow-sm);
    }
    .pagination button:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
    .pagination button.active {
      background-color: var(--accent);
      color: #fff;
    }
    .pagination button:disabled {
      opacity: 0.55;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    /* Bottom bar wrapper (sticky) keeps hScroll with the paginator */
    #bottomBar {
      position: sticky;
      bottom: 0;
      z-index: 2;
      background: var(--panel);
      border-top: 1px solid var(--border);
      padding-top: 6px;
      border-radius: 0 0 var(--radius) var(--radius);
    }
    #hScroll {
      overflow-x: auto;
      overflow-y: hidden;
      height: 20px;
      background-color: var(--panel-2);
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
      margin-top: 6px;
      border-radius: 8px;
    }

    /* Footer */
    footer {
      margin-top: 12px;
      font-size: 12px;
      text-align: center;
      color: var(--muted);
    }

    /* Print styling */
    @media print {
      #sidebar,
      #chartContainer,
      #paginationControls,
      #hScroll,
      #bottomBar,
      footer,
      .topbar {
        display: none !important;
      }
      body { margin: 0; padding: 0; background: #fff; }
      #main { width: 100%; padding: 0; }
      table { width: 100% !important; }
      th { position: static; }
    }

    /* Mobile / Responsive enhancements */
    @media (max-width: 1100px) {
      .container { flex-direction: column; padding: 12px; }
      #sidebar {
        width: 100%;
        max-height: 70vh;
        transform: translateY(-8px);
        top: 74px;
      }
    }
    @media (max-width: 860px) {
      /* Slide-in sidebar on small screens */
      .container { gap: 12px; }
      #sidebar {
        position: fixed;
        right: 12px;
        top: 64px;
        height: calc(100vh - 76px);
        max-height: none;
        width: min(92vw, 360px);
        transform: translateX(110%);
        opacity: 0;
        box-shadow: var(--shadow-md);
      }
      body.sidebar-open #sidebar { transform: translateX(0); opacity: 1; }
      body.sidebar-open::after {
        content: "";
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.25);
        -webkit-tap-highlight-color: transparent;
      }
    }

    /* Focus & accessibility */
    :focus-visible { outline: none; box-shadow: 0 0 0 4px var(--ring); border-radius: 8px; }

    /* Smooth scroll & reduced motion */
    html { scroll-behavior: smooth; }
    @media (prefers-reduced-motion: reduce) {
      html { scroll-behavior: auto; }
      * { transition: none !important; animation: none !important; }
    }

    /* Scrollbar styling (WebKit) */
    *::-webkit-scrollbar { height: 10px; width: 10px; }
    *::-webkit-scrollbar-thumb { background: #c8d5f1; border-radius: 20px; border: 2px solid transparent; background-clip: padding-box; }
    *::-webkit-scrollbar-track { background: transparent; }
</style>


  <style id="hairline-zfix">
    #chartContainer, #powerChartContainer { position: relative; z-index: 0; }
    #chartCanvas, #powerChartCanvas { position: relative; z-index: 0; }
    #chartOverlay, #powerOverlay, [id$="OverlayX"] {
      position: absolute; inset: 0; pointer-events: none; z-index: 1000;
    }
    #chartTooltip, #powerTooltip, [id$="Tooltip"], .tooltip { position: absolute; z-index: 2000; }
    #chartContainer, #powerChartContainer { z-index: 0; }
</style>

  <script id="hairline-zfix-script">
  (function() {
    function bringToFront(containerId, ids) {
      var c = document.getElementById(containerId);
      if (!c) return;
      ids.forEach(function(id) {
        var el = document.getElementById(id);
        if (el && el.parentElement === c) {
          c.appendChild(el);
        }
      });
    }
    function run() {
      bringToFront('chartContainer', ['chartOverlay','chartTooltip']);
      bringToFront('powerChartContainer', ['powerOverlay','powerTooltip']);
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', run);
    } else {
      run();
    }
  })();
  </script>

  <style id="fixed-topbar-and-theme">
    :root { --topbar-h: 58px; }
    body { padding-top: var(--topbar-h); }
    .topbar { position: fixed; top: 0; left: 0; right: 0; z-index: 100; }
    .container { min-height: calc(100vh - var(--topbar-h)); }
    [data-theme="light"] {
      --bg: #f7fafc; --panel: #ffffff; --panel-2: #f8fbff; --accent: #2563eb; --accent-600: #1e40af; --accent-700: #1d4ed8;
      --text: #0f172a; --muted: #64748b; --border: #e2e8f0; --ring: rgba(37, 99, 235, 0.35);
      --row: #ffffff; --row-alt: #f6faff; --row-hover: #eef6ff; --table-head: #0b61e5; --table-head-text: #ffffff;
      --chip: #eaf2ff; --chip-text: #2152cf; --shadow-sm: 0 1px 2px rgba(16, 24, 40, 0.04); --shadow-md: 0 6px 18px rgba(16, 24, 40, 0.10);
    }
    [data-theme="dark"] {
      --bg: #0b1220; --panel: #0f172a; --panel-2: #0b1220; --accent: #63a2ff; --accent-600: #9bc2ff; --accent-700: #84b6ff;
      --text: #e6edf7; --muted: #97a6ba; --border: #1e293b; --ring: rgba(99, 162, 255, 0.4);
      --row: #0f172a; --row-alt: #0b1220; --row-hover: #172133; --table-head: #1e3a8a; --table-head-text: #e6edf7;
      --chip: #11213f; --chip-text: #9bc2ff; --shadow-sm: 0 1px 2px rgba(0,0,0,0.35); --shadow-md: 0 8px 24px rgba(0,0,0,0.45);
    }
</style>

  <style id="pro-tooltip-styles">
    .tooltip-card {
      font: 12px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(16,24,40,.2), 0 2px 8px rgba(16,24,40,.1);
      padding: 8px 10px;
      min-width: 220px;
      color: var(--text);
    }
    .tooltip-card .tt-header {
      display:flex; align-items:center; justify-content:space-between;
      font-weight:700; margin-bottom:6px;
    }
    .tooltip-card .tt-time { opacity:.9; }
    .tooltip-card .tt-body { display:flex; flex-direction:column; gap:4px; }
    .tt-row {
      display:grid; grid-template-columns: auto 1fr auto;
      align-items:center; gap:8px;
      padding:4px 6px; border-radius:8px;
    }
    .tt-row.active { background: rgba(37,99,235,.10); }
    .tt-swatch {
      width:10px; height:10px; border-radius:50%;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.15);
    }
    .tt-label { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; opacity:.95; }
    .tt-value { font-variant-numeric: tabular-nums; font-weight:600; }
</style>

  <style id="tooltip-forever-top">
    /* Force tooltips to top of the entire page */
    #chartTooltip, #powerTooltip, [id$="Tooltip"] {
      position: fixed !important;
      z-index: 2147483647 !important; /* max 32-bit int, effectively always on top */
      pointer-events: none;
    }
</style>

  <style id="tooltip-forever-top-2">
    /* Always-on-top tooltip as a global portal */
    #chartTooltip, #powerTooltip, [id$="Tooltip"] {
      position: fixed !important;
      z-index: 2147483647 !important;
      pointer-events: none;
      max-width: min(420px, 90vw);
    }
    /* Dark-mode stronger active highlight */
    .tt-row.active { background: rgba(37,99,235,.12); }
    [data-theme="dark"] .tt-row.active { background: rgba(99,162,255,.28); }
</style>

<style>
  /* --- Fullscreen overlay for charts --- */
  #chartsFullscreenOverlay {
    position: fixed; inset: 0;
    background: var(--panel);
    z-index: 9999;
    padding: 12px;
    overflow: auto;
  }
  #btnToggleFullscreenCharts {
    position: absolute;
    top: 8px; right: 8px;
    z-index: 2500;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 6px 10px;
    font-weight: 600;
    box-shadow: 0 6px 14px rgba(0,0,0,0.12), 0 2px 6px rgba(0,0,0,0.08);
    cursor: pointer;
  }
  #btnToggleFullscreenCharts:hover { background: var(--accent-600); }</style>

<style id="fs-patch-styles">
#chartContainer, #powerChartContainer { position: relative; }
#btnToggleFullscreenCharts{
  position:absolute; top:8px; right:8px; z-index: 2500;
  background: var(--accent); color:#fff; border:0; border-radius:10px;
  padding:6px 10px; font-weight:600; box-shadow:0 6px 14px rgba(0,0,0,.12),0 2px 6px rgba(0,0,0,.08);
  cursor:pointer; pointer-events:auto !important; opacity:1 !important; display:inline-block !important;
}
#btnToggleFullscreenCharts:hover{ filter: brightness(1.05); transform: translateY(-1px); }
#chartsFullscreenLayer { position: fixed; inset: 0; background: var(--panel, rgba(0,0,0,.4)); z-index: 9999; padding:12px; overflow:auto; }</style>

<style>
/* === Print Optimization (clean PDF) === */
@media print {
  /* Hide chrome/controls */
  .topbar, #sidebar, #chartContainer, #powerChartContainer, #paginationControls,
  #hScroll, #bottomBar, footer, .no-print { display: none !important; }

  html, body { background: #fff !important; }
  body { margin: 0 !important; padding: 0 !important; font-size: 11pt; }

  /* Layout */
  #main, #dataSection, #tableContainer { width: 100% !important; min-width: 0 !important; }
  table { width: 100% !important; border-collapse: collapse !important; table-layout: fixed !important; }
  th, td { padding: 6pt 8pt !important; border: 1px solid #d0d7e2 !important; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

  /* Repeat header on every page */
  thead { display: table-header-group; }
  tfoot { display: table-footer-group; }
  tr { page-break-inside: avoid; }

  /* Remove sticky positions in print */
  th[style*="position: sticky"], .sticky, thead th { position: static !important; top: auto !important; }

  /* Colors in print */
  * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
}

/* Default to A4 landscape with sensible margins */
@page { size: A4 landscape; margin: 12mm; }</style>
<style>
/* === Conditional formatting for over-limit values === */
td.over-limit{ background:#ef4444 !important; color:#fff !important; font-weight:600; }
td.near-limit{ background:#fde68a !important; } /* optional amber for 90‚Äì100% */
@media print{
  td.over-limit{ background:#ff4d4d !important; color:#fff !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
  td.near-limit{ background:#ffe8a3 !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
}</style>
<style>
/* === Exceedances summary table (fixed at bottom) === */
/* Exceedances summary container uses design tokens for seamless theming */
#exceedWrap{
  margin-top:16px;
  border:1px solid var(--border);
  border-radius:10px;
  overflow:hidden;
  background:var(--panel);
}
#exceedWrap header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:10px 12px;
  background:var(--panel-2);
  border-bottom:1px solid var(--border);
}
#exceedWrap header h3{
  margin:0;
  font:600 14px/1 system-ui, sans-serif;
  color:var(--text);
}
#exceedWrap header .actions{ display:flex; gap:8px; }
#exceedTable{ width:100%; border-collapse:separate; border-spacing:0; table-layout:fixed; }
#exceedTable thead th{
  position:sticky;
  top:0;
  background:var(--panel);
  border-bottom:1px solid var(--border);
  padding:8px 10px;
  text-align:left;
}
#exceedTable tbody td{
  border-bottom:1px solid var(--border);
  padding:8px 10px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
}
#exceedTable tbody tr:nth-child(odd){
  background:var(--row-alt);
}
#exceedTable .v{
  text-align:right;
  font-variant-numeric:tabular-nums;
}
#exceedWrap .empty{
  padding:12px;
  color:var(--muted);
  background:var(--panel);
}
@media print{
  #exceedWrap{ page-break-before:always; }
  #exceedWrap header .actions{ display:none !important; }
  #exceedTable thead th{ position:static; }
}</style>

<style id="exceed-refresh-styles">
#exceedWrap header .actions{ display:flex; gap:8px; }
#exceedRefreshBtn{
  border:1px solid #0b61e5; background:#0b61e5; color:#fff;
  border-radius:10px; padding:6px 10px; font-weight:600; cursor:pointer;
}
#exceedRefreshBtn:hover{ filter:brightness(1.05); }</style>

<style>
/* === Exceedances refresh button fallback === */
#exceedWrap header .actions{ display:flex; gap:8px; align-items:center; }
button#exceedRefreshBtn{ background:#0b61e5; color:#fff; border:0; padding:6px 12px; border-radius:10px; font-weight:600; cursor:pointer; }
button#exceedRefreshBtn:hover{ filter:brightness(1.05); }
#exToast{ position:fixed; right:14px; bottom:14px; background:#111; color:#fff; padding:8px 12px; border-radius:10px; font-size:12px; opacity:0; pointer-events:none; transition:opacity .2s; z-index:9999; }
#exToast.show{ opacity:0.92; }</style>

<style id="hide-refresh-download-csv">
  /* hide only the Exceedances header buttons */
  #exceedRefreshBtn, #exceedCsvBtn { display: none !important; }</style>

</head>

<body>
<script>
(function(){
  // Wait until DOM is ready
  function ready(fn){ if (document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    function getCont(){ return document.getElementById('powerChartContainer'); }
    function getMain(){ return document.getElementById('powerChartCanvas'); }
    function getOver(){ return document.getElementById('powerOverlay'); }

    function ensureRelative(cont){
      if (!cont) return;
      var cs = getComputedStyle(cont);
      if (cs.position === 'static'){ cont.style.position = 'relative'; }
    }

    function ensureBtn(cont){
      if (!cont) return null;
      var btn = cont.querySelector('#btnToggleFullscreenPower_inside');
      if (!btn){
        btn = document.createElement('button');
        btn.id = 'btnToggleFullscreenPower_inside';
        btn.type = 'button';
        btn.setAttribute('aria-label','Power fullscreen');
        btn.title = 'ÿ™ŸÉÿ®Ÿäÿ±/ÿ™ÿµÿ∫Ÿäÿ± ŸÜÿßŸÅÿ∞ÿ© Average Active Power + Theoretical Power';
        btn.textContent = '‚§¢';
        // Pure inline styles to avoid touching <head>
        btn.style.cssText = [
          'position:absolute','top:10px','right:10px',
          'display:inline-flex','align-items:center','justify-content:center',
          'width:40px','height:40px','border:none','border-radius:10px','cursor:pointer',
          'background:#2563eb','color:#fff','font-size:20px','line-height:1','font-weight:700',
          'box-shadow:0 8px 18px rgba(0,0,0,.18),0 3px 8px rgba(0,0,0,.12)',
          'z-index:10001','opacity:.95'
        ].join(';')+';';
        btn.onmouseenter=function(){ btn.style.opacity='1'; };
        btn.onmouseleave=function(){ btn.style.opacity='.95'; };
        cont.appendChild(btn);
      }
      return btn;
    }

    function setHiDPISize(el,w,h){
      if(!el) return;
      var dpr = window.devicePixelRatio || 1;
      el.style.width = '100%';
      el.style.height = '100%';
      el.width  = Math.max(1, Math.floor(w * dpr));
      el.height = Math.max(1, Math.floor(h * dpr));
    }

    function resizePower(){
      var cont = getCont();
      if (!cont) return;
      var main = getMain(), over = getOver();
      // Detect whether the power container is currently in fullscreen (either via
      // the Fullscreen API or the CSS fallback class). When not in fullscreen
      // we want the canvas to revert to its CSS-defined height rather than
      // continuing to fill the container from a previous fullscreen state.
      var isFS = (document.fullscreenElement === cont) || (cont.classList && cont.classList.contains('is-fullscreen-power'));

      var dpr = window.devicePixelRatio || 1;

      if (main) {
        if (isFS) {
          // In fullscreen: make canvas fill the container and set high-DPI
          main.style.width  = '100%';
          main.style.height = '100%';
          // Use the container's current bounding rect for sizing
          var rr = cont.getBoundingClientRect();
          main.width  = Math.max(1, Math.floor(rr.width  * dpr));
          main.height = Math.max(1, Math.floor(rr.height * dpr));
        } else {
          // Exiting fullscreen: remove inline styles and attributes so CSS
          // takes over. Then recompute the size based on the natural height.
          main.style.width  = '';
          main.style.height = '';
          main.removeAttribute('width');
          main.removeAttribute('height');
          // After clearing, get the updated bounding rect for correct sizing
          var rr2 = cont.getBoundingClientRect();
          main.width  = Math.max(1, Math.floor(rr2.width  * dpr));
          main.height = Math.max(1, Math.floor(rr2.height * dpr));
        }
      }

      if (over) {
        if (isFS) {
          over.style.width  = '100%';
          over.style.height = '100%';
          var rr3 = cont.getBoundingClientRect();
          over.width  = Math.max(1, Math.floor(rr3.width  * dpr));
          over.height = Math.max(1, Math.floor(rr3.height * dpr));
        } else {
          over.style.width  = '';
          over.style.height = '';
          over.removeAttribute('width');
          over.removeAttribute('height');
          var rr4 = cont.getBoundingClientRect();
          over.width  = Math.max(1, Math.floor(rr4.width  * dpr));
          over.height = Math.max(1, Math.floor(rr4.height * dpr));
        }
      }

      try {
        if (typeof window.updateChart === 'function') window.updateChart();
      } catch (e) {}
      // Trigger a resize event so other listeners can update correctly.
      window.dispatchEvent(new Event('resize'));
    }

    async function toggleFS(){
      var cont = getCont(); if (!cont) return;
      try{
        if (document.fullscreenElement === cont){
          await document.exitFullscreen();
        } else if (document.fullscreenEnabled){
          if (document.fullscreenElement) await document.exitFullscreen();
          await cont.requestFullscreen();
        } else {
          // Minimal fallback: class-based styling
          cont.classList.toggle('is-fullscreen-power');
          if (cont.classList.contains('is-fullscreen-power')){
            cont.style.position='fixed'; cont.style.inset='0';
            cont.style.width='100vw'; cont.style.height='100vh';
            cont.style.background='var(--bg, #0b0b0c)'; cont.style.zIndex='2147480000';
          } else {
            cont.style.position=''; cont.style.inset=''; cont.style.width=''; cont.style.height='';
            cont.style.background=''; cont.style.zIndex='';
          }
        }
      }catch(e){
        cont.classList.toggle('is-fullscreen-power');
      }
      setTimeout(resizePower, 50);
    }

    function mount(){
      var cont = getCont();
      if (!cont) return;
      ensureRelative(cont);
      var btn = ensureBtn(cont);
      if (btn && !btn.__bound){
        btn.addEventListener('click', toggleFS);
        btn.__bound = true;
      }
    }

    // Initial mount (if container already in DOM)
    mount();
    // If the app builds/tears DOM, keep ensuring the button exists
    var mo = new MutationObserver(function(){ mount(); });
    mo.observe(document.body, { childList:true, subtree:true });

    // Resize hooks
    document.addEventListener('fullscreenchange', function(){ setTimeout(resizePower, 60); });
    window.addEventListener('resize', function(){
      var cont = getCont();
      if (document.fullscreenElement === cont || (cont && cont.classList.contains('is-fullscreen-power'))){
        resizePower();
      }
    });
    document.addEventListener('keydown', function(e){
      if (e.key === 'f' || e.key === 'F'){
        var cont = getCont();
        if (!cont) return;
        var over = cont.matches(':hover') || document.fullscreenElement === cont;
        if (over){ e.preventDefault(); toggleFS(); }
      }
    });
  });
})();
</script>


  <div class="topbar">
    <div class="brand"><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAA8AL4DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKSlqnrF4unaXd3bHCwQvKf+AqT/AEppNuyJlJRTky3S189/sy+PNQkt4tD1uSVzqULanpk87ljKpZhIgJ/2lLY9m9q+hK7cbhJYKvKjJ3t17/1+Z5eV5jTzXCxxNNWvuuqfb9V3TTCiiiuE9Y8e+PXxe1j4dXvh3TvD9ta3mpapI6+XcozcAqqhQGHJZsc+lcvrvxC+N/hrR7zVNQ8MaJBY2cZlmlDhtqjqcCbJ/CqXxc+HviH4nfHbTbSGC/0zR7S0RBrUcDGOJgGlJVsgbtxVevUe1Y3xa+BPirw/4XEtl4p8Q+MJJp1ifTPLkkBXBYuQHbgEDqO4r7fC0sDGnh6U3Dnkru6ber01TSWnc/K8wxGaVK2Lr0lU9nB2jyyjFaJX0ablrroe3/B/4jXPj34dw+ItXgt9OkDTLK0bERbY2IL/ADHgYBzk8YNeM+KP2qfEq3l9qnh/RrSXwlb3a2cd5dROWlbaW6hgAWVSQMcDGeTV/wAbab4v1vwn4V+HPh3w7PpNrNaQHVbxbd47SNioZotxz8oOS/JJOF55qjrXwD+JFn8OZvD66xot5o1oDdJp9rakTSyKS/D7MlyeOTz0qcNh8BTqOrX5bTlpFt6RvvpfXte2hWNxmb1qMaGF5704+9OMV707LTW2i6tXd9LHtnjz4oWvhH4Zv4st4hepJDE9pEW2iRpcbAT2HzZPsDXkui/Fn4q+JNMt9Tsz4Ngtrld8cdxdhJFH+0pkyD7HmsUHxofgBpuhT+BptWe1vWtp7XULWbzBAB5kMiKrK3BO3I6bfeueXw1oDxLn4J+J2ucDP+kz7C2PQr0z+la4XA4ejTnGUVKXM1f3XottHONr7mOPzXGYirTnCcoR5Itr34+899VTne21tD03xH8dvFXw3+DV94o8V6dpy69cXX2TR9OgVwJ2PAd8McrgMw2nlQP7wrAi8W/tPXFvHOPC/hSASoHWKaUK6gjOCDNwfao/iv4o+Kum/Crwba2PhK71G7u2WfV20+12tBEkgK2gjQFow6YUsBwAR1NeafGHXNW+NF5/aF98EfGsOtR2ZtLSSO8nSCLlmDGNYRu+ZsnkZwBXNRw8ZNv2cLNyu7p2torJyjpv59T16mKnCEU6tS6jGyaabb1d2oyu9lsktj0GH9p34h6H8H/FeveKvCcOi65p91aWunG5tZoYbppmIbKM2TsVScq2Dkfj6z8K/jjo/iT4eaDqniTxH4dsNbvLYT3NrHfxRCJmJIXazlgQuMgnrmvkjXPgd4+0n4H+FfDSeHNTudT1rXJdUvo4YmlNoixpDAJiMhTh3fGeOc9K991T9if4X6Zod1cro2p391b2zyCOK/lLzOqE4AB6sRwB61niqOXqFm7OUnblV9FZdXom9TowVfNJTuldRirqba1d30jq0rJl/wCDf7QGtfFT41eMtBhi01/COjLJ9mvLZHMs2JRGjb9xUhsSHgdAKyfjv+1BrXhXxofCXw/0u117V7C3lvNWknRpI7dETeyAKy/Mq/MxJ4yq9TivLPgnpfjv4I/BzxXqVh4J1qXxlrt5HZWNr/Z8jPbRxxZM7rjhQ0jbQfvMB2Bra+GP7Mvxk8F2t7qemeJfD2l6hrkIOoLqVsbq4+bLNG7tG3OWJbacE+uBVywuDp151JOPLGyim9JOyu3a7/zZEMZj62HhSipc8ryk0tYpt2SvZXf4I96/Zt+MM3xq+G0WtXsdvBq0NxJaXkVqCIw4IKsoJJAKMp5PXNeNad+0d8YPiJ438V6b8P8Aw1oeraZo948SyXAKMI/MZIyzNMoLNsY8Csj9mvw349+BviH4iaDfeHNSuLP+z5p7S8trSRra4uoFPl+UxAz5itgDqSoFY3wG/ZN8Ya94Wu9W1DxT4g+Hl/PctG9hDA8UkyqARI/zqeWZ8ZHbPej6vg8PUr1JOPLpy3u1rrstdNhfWsfiaWHpRUuf3ue1ovTRavTXc626/aQ+Mfgf4ieF/D3jPwnodv8A21cxRpBasTI8byrGWVllcAgt0I5qXUP2mPiX4j+Kni3w14K03wzcWWi3MkSyapKYSyI/llt7SqGJcNwB0rnfA/wh8WeB/wBphrjVbLWPHGj6NZzTQa9qtrK4Mi2+9BCzMRvEjbBgnOWwAeR5b4L+HOsWcmqXPjH4HeJfF93ez/aI5N9zZ+QW3FxhUO4lmzk9MV2Qw+DleSjFvlW2zbfZyWyXV9ThlisfC0JTmlzPfdKKX2oxe7fRNafM+ovA/wAQPjbqXirT4vEGm+DbXQFcyahcWN6ss0cCgliqrMxz0HQ4zXnngz9p34y/E1dSu/DGh+FJbC1uDHm8nEDAHLIPnnXcduMkDFVPBOgNovh3x/deHPgZrfg3WW8PzWttdTXFxdSTvK6oIo0dBzyXJHICe9eZeC/hpNouhra+I/gD4n8TaksjH7ctzdWo2HG1PLVCOPXvmpp4fDy9o5QjdWSXu+rdue3b7XyLq4rFR9nGNSVndt+96JX9nfo38PzPb/Df7THxPsfjD4b8F+K9A8Ps2rTRq66TMZHjjcsPMDJK65UKWKnsO2Qa+gPjTrH9h/CTxbe5wY9MnAPuyFR+rV8r/s5fCvxLbftAW/iPT/A2pfDzwpbW8gmtNQkeTfmIrsDSAM5ZyG4GFC9a94/a61I2PwL1qBTiS/mtrNfcvMnH5A15uIo0fr9ClSSV+W9u7fq1+LPVwtbEf2ZiateTdublv2S0s7JvXukch4ohsPA3wB+Husy3iadrWmJZ/wBnyEEtLLKAzRcdiCWPoFNe1fD74jaP8Q9J+06dcxm6hCrd2e795bORnay9cdcN0OOK8Q8BacPjp8WrfWGHneA/ASrp+lLj93e36qoeb3C4GPonqay/HHwqv/CfxohufDWrP4c1LUUeXR7rGbeSTdue0mHdCScdcbl4PbnxXs5yVOvO0tXfouZ3SfX17N+Ry0KlbANYnDwvRfLBpbtxVlNdNfhXe0T6uory74b/ABkbW9RPhrxbYHw14wh+VrOX/U3X+3C2eQf7uT7E16hnNePWoVMPPkqK35Nd0+qPscLi6OMp+0oyutn3T7Nbprsw2jOcc0YFLRXOdgm0elFLRQA3aPSsvX/Edp4d/s/7YJNl9dJZoyAFUdlYgsSeF+UjPuK1qxfF3hHTvG2kf2bqiSPa+dHMRFIUJKOGAyOcHGCO4JHegDm7f4z+H7nRm1OKK9a2S2vLxx5IV0it32Fipbje2Ag6tntg4nvvi7oWn61q2kzLeDUNNjtnkgEXMnnuiKsZzhmVpYgw/h8xfWrR+F+hG312HyptutXSXV4fNOSVZWCL/dTKn5Rx87/3qZffCrQNS1K2v7iGaS8t9W/tmOYykET7FTHumEj+Tp8inqBQAz/hZ2nf20bJtP1BLUaj/ZP9p+WhtvtOBhOH3gFiF3FNu7jNWvGXxC0/wVdaZa3UE1zc6h5pgjilhi4jCliWmkRf4lGM5JPSodJ+GOl6XqgvGub++CXc1/DbXdxvhhnlZmeRUAGWy7YLZ254xU/iT4f2fibWrPVJL29tLq1ha3T7M6bSjOrsCrowySi8jB4oAzdS+L2g6Tq2qaXdRXkWo6faQ3ctv5QJcSMqiNCGwzqXj3DPHmIckGrll8StO1DxVf6FbW80klhK0Vzc+dbqkZWNXY7DL5pADqNwTGTSap8LdB1q+S8vIZZrpNWj1lZTKQROkaRgf7m2NAU6HAplp8L9Ps7jWZI77UPL1X7SZ4TKm1WnOXZDs3A+nzED0oAp6b8YtHvLR7m4sdS0yI2MWpQ/aoVZriGV/LiKLG7nczEAIwDEsMDrjRn+Iltpen/btX0rUdDtRdRWry3yxBI/M4WRmWRgEyQpJPBIyO9VrX4PeGdP0zUrCys20+1vjbuy2b+UYpIAPKljK4KuCqHPcrnHJzbb4b6VPoOoaVePdahHqM6XF5NdS75bhkKYDHGNuI0XaABgH1oAux+MLF/CU/iSSK5t9Mht5LsmWE+Y0KAneEGThlG4DGcEcA8UvhDxVD4w0hdRgs7i0tpD+6M7xOJVwCHVondSOcdcgggjir+s6WNZ0yeza5urMSgfv7OYxSoQQQVYdOn0I4OQaxNI+HlhoWk3FhY3d9bJdG4kuJo5gsks02N8xIHDjHBUADJwKALHh3xtpvijVNXsLJZy+muivLJHtjmDbhviP8abo5E3dNyNjPWqa/Eawm8aXHhm3tLi4vbZ0SeRZYFWMtGJPutKJGAVlJKocZ+tM0X4VaB4YupZ9Dhl0ZpbaO0ZbOUhTGj714OeRlhn0Y1LY/Du003xBqOr2+oagk19LJNLEZEKB3RULLlNwwFXA3YGOlAHVYHXFfMX7cWvQ3nhzw14Ptp8arqOordmNVLGOCNXUyMBzgMw+u0+lfQ2u65YeCvC93qmq3ZisNOtjLPcTEFtqjkn1Y/qTXyp8Mfi14dtvEus/E7xdcte+LNeP2fRvD9gn2m4s7FThE2jhGfHOcEjn+I17mV0Z+0+sxi5cmyXV9F8t2+h83neIpqj9VlNQ5929lFbvdXvsl1v5HqPw5+Kfw4+G/g3S/DumXV5HaWUQTzJLCVWlfq8jcdWYkn61V+K3xN8D+PPCc1tBrEltqtqwurC4a1lUxzJyvO3gHp+IPatS11D4mfErD2+mW/gHR26TXiia+ZfZcfIfwH1ro/DPwM8OaJdfb75JfEGqsd7XeqN5nzeoT7o/EE+9Rj6eHUXdXnLdc6l97UbX9G/keRQ/tPGQ9hS5fY2teVOUFb+6nNy9LpLszgLz4mfDr4l+DdPj8XX0dhrccYLSxxP5tvKOrRuqkYJGcdOeelUPDf7R0fg2WbStUv18W6fEP8ARNVsvkmZf7sqyY5A79fr1r6EbQdOfO6wtW+sCf4VE3hfR2+9pdk31to/8K8WdTEOkqMZe6u+v9X62PV/s3F+1VeNWKnazai1zL+8uZp/dddLGpRRRTPpgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAOM+LHwvsPi74V/wCEf1O9vrKxa5iuJfsMio0gQ5CNkEFSeenUA9qPh/8AB/wj8MrUReH9Ft7OXGHumHmXD+u6Rst+uPauzordV6qp+xUny9uhzPC0ZVfbuCc9r9RKWiisDpCiiigD/9k=" alt="Ras Ghareb logo" class="logo"><span>X‚ÄëMinutal Analysis</span></div>
    <div class="toolbar">
      <button id="themeToggle" class="soft-btn" title="Toggle theme">üåô</button>
      <button id="sidebarToggle" class="soft-btn">Filters</button>
      <button id="scrollTop" class="soft-btn">Top</button>
      <button id="scrollBottom" class="soft-btn primary">Bottom</button>
    </div>
  </div>

  <div class="container">

    <div id="sidebar" aria-label="Filters panel">
      <h2>Filters</h2>


      <div class="section">
        <label for="csvInput">Upload CSV</label>
        <input type="file" id="csvInput" accept=".csv">
      </div>


      <div class="section">
        <label>Category Filter</label>
        <div class="category-list" id="categoryList"></div>
      </div>


      <div class="section">
        <label>Time Filter</label>
        <input type="date" id="startDate">
        <input type="time" id="startTime">
        <input type="date" id="endDate">
        <input type="time" id="endTime">
        <div class="filter-buttons">
          <button id="btnToday">Today</button>
          <button id="btnYesterday">Yesterday</button>
          <button id="btnLast24">Last 24h</button>
          <button id="btnClearTime">Clear</button>
        </div>
      </div>


      <div class="section">
        <label for="turbineSearch">Filter by Turbine</label>
        <input type="text" id="turbineSearch" placeholder="Type turbine id...">
        <div id="turbineList"></div>
        <button id="btnClearTurbine" style="margin-top:8px;">Clear turbine</button>
      </div>


      <div class="section">
        <label for="intervalSelect">Aggregation Interval</label>
        <select id="intervalSelect">
          <option value="10">10 minutes</option>
          <option value="60">1 hour</option>
          <option value="120">2 hours</option>
          <option value="180">3 hours</option>
          <option value="240">4 hours</option>
          <option value="1440">1 day</option>
        </select>
      </div>


      <div class="section">
        <label>Variables</label>
        <input type="text" id="variableSearch" placeholder="Search variable...">
        <div class="variable-list" id="variableList"></div>
      </div>


      <div class="section">
        <button id="btnDownloadCSV">Download CSV</button>
        <button id="btnDownloadXLS">Download Excel</button>
        <button id="btnDownloadPDF">Download PDF</button>
      </div>
    </div>


    <div id="main">
      <h1>Data Table</h1>


      <div id="chartContainer" style="display:none;">
        <canvas id="chartCanvas" style="border-top-left-radius: 12px; border-top-right-radius: 12px; border: none;"></canvas>
        <canvas id="chartOverlay" style="position:absolute; inset:0; pointer-events:none;"></canvas>
        <div id="chartTooltip" style="position:absolute; display:none; pointer-events:none; background: var(--panel); border:1px solid var(--border); border-radius:8px; padding:6px; font-size:12px; box-shadow: var(--shadow-md); color: var(--text);"></div>
      </div>

      <div id="powerChartContainer" style="display:none;">
        <canvas id="powerChartCanvas" style="border: none;"></canvas>
        <canvas id="powerOverlay" style="position:absolute; inset:0; pointer-events:none;"></canvas>
        <div id="powerTooltip" style="position:absolute; display:none; pointer-events:none; background: var(--panel); border:1px solid var(--border); border-radius:8px; padding:6px; font-size:12px; box-shadow: var(--shadow-md); color: var(--text);"></div>
      </div>


      <div id="dataSection">
        <div id="tableContainer">
          <table id="dataTable">
            <thead id="tableHead"></thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>


        <div id="bottomBar">
          <div id="hScroll"><div class="hScrollInner"></div></div>
          <div id="paginationControls" class="pagination"></div>
        </div>
      </div>

      <section id="exceedWrap"><header><h3>Exceedances analysis</h3><div class="actions"><button id="exceedRefreshBtn">Refresh</button><button id="exceedCsvBtn">Download CSV</button></div></header><div class="inner"><div class="empty">No exceedances yet.</div></div></section>

      <footer>designed by Mohamed Lasheen</footer>
    </div>
  </div>


  <script>
  // Global data storage

// === Embedded RGWE power curve (ws -> kW) & interpolation ===
window.__RGWE_POWER_CURVE_CSV = `ws,kw
1,0
2,0
3,21.6
3.1,29.22
3.2,36.84
3.3,44.46
3.4,52.08
3.5,59.7
3.6,67.32
3.7,74.94
3.8,82.56
3.9,90.18
4,97.8
4.1,111.41
4.2,125.02
4.3,138.63
4.4,152.24
4.5,165.85
4.6,179.46
4.7,193.07
4.8,206.68
4.9,220.29
5,233.9
5.1,253.37
5.2,272.84
5.3,292.31
5.4,311.78
5.5,331.25
5.6,350.72
5.7,370.19
5.8,389.66
5.9,409.13
6,428.6
6.1,456.05
6.2,483.5
6.3,510.95
6.4,538.4
6.5,565.85
6.6,593.3
6.7,620.75
6.8,648.2
6.9,675.65
7,703.1
7.1,739.74
7.2,776.38
7.3,813.02
7.4,849.66
7.5,886.3
7.6,922.94
7.7,959.58
7.8,996.22
7.9,1032.86
8,1069.5
8.1,1114.79
8.2,1160.08
8.3,1205.37
8.4,1250.66
8.5,1295.95
8.6,1341.24
8.7,1386.53
8.8,1431.82
8.9,1477.11
9,1522.4
9.1,1558.93
9.2,1595.46
9.3,1631.99
9.4,1668.52
9.5,1705.05
9.6,1741.58
9.7,1778.11
9.8,1814.64
9.9,1851.17
10,1887.7
10.1,1907.03
10.2,1926.36
10.3,1945.69
10.4,1965.02
10.5,1984.35
10.6,2003.68
10.7,2023.01
10.8,2042.34
10.9,2061.67
11,2081
11.1,2082.64
11.2,2084.28
11.3,2085.92
11.4,2087.56
11.5,2089.2
11.6,2090.84
11.7,2092.48
11.8,2094.12
11.9,2095.76
12,2097.4
12.1,2097.66
12.2,2097.92
12.3,2098.18
12.4,2098.44
12.5,2098.7
12.6,2098.96
12.7,2099.22
12.8,2099.48
12.9,2099.74
13,2100
13.1,2100
13.2,2100
13.3,2100
13.4,2100
13.5,2100
13.6,2100
13.7,2100
13.8,2100
13.9,2100
14,2100
14.1,2100
14.2,2100
14.3,2100
14.4,2100
14.5,2100
14.6,2100
14.7,2100
14.8,2100
14.9,2100
15,2100
15.1,2100
15.2,2100
15.3,2100
15.4,2100
15.5,2100
15.6,2100
15.7,2100
15.8,2100
15.9,2100
16,2100
16.1,2100
16.2,2100
16.3,2100
16.4,2100
16.5,2100
16.6,2100
16.7,2100
16.8,2100
16.9,2100
17,2100
17.1,2100
17.2,2100
17.3,2100
17.4,2100
17.5,2100
17.6,2100
17.7,2100
17.8,2100
17.9,2100
18,2100
18.1,2100
18.2,2100
18.3,2100
18.4,2100
18.5,2100
18.6,2100
18.7,2100
18.8,2100
18.9,2100
19,2100
19.1,2100
19.2,2100
19.3,2100
19.4,2100
19.5,2100
19.6,2100
19.7,2100
19.8,2100
19.9,2100
20,2100
20.1,2100
20.2,2100
20.3,2100
20.4,2100
20.5,2100
20.6,2100
20.7,2100
20.8,2100
20.9,2100
21,2100
21.1,2100
21.2,2100
21.3,2100
21.4,2100
21.5,2100
21.6,2100
21.7,2100
21.8,2100
21.9,2100
22,2100
22.1,2100
22.2,2100
22.3,2100
22.4,2100
22.5,2100
22.6,2100
22.7,2100
22.8,2100
22.9,2100
23,2100
23.1,2057.6
23.2,2015.2
23.3,1972.8
23.4,1930.4
23.5,1888
23.6,1845.6
23.7,1803.2
23.8,1760.8
23.9,1718.4
24,1676
24.1,1631.4
24.2,1586.8
24.3,1542.2
24.4,1497.6
24.5,1453
24.6,1408.4
24.7,1363.8
24.8,1319.2
24.9,1274.6
25,1230`;
window.POWER_CURVE = (function(csv) {
  try {
    const lines = csv.trim().split(/\n+/).slice(1);
    return lines.map(l=>{
      const [ws,kw] = l.split(',').map(Number);
      return { ws, kw };
    }).filter(p=>Number.isFinite(p.ws) && Number.isFinite(p.kw))
      .sort((a,b)=>a.ws-b.ws);
  } catch(e) { return []; }
})(window.__RGWE_POWER_CURVE_CSV);

window.expectedPowerKWFromWS = function(ws){
  const pc = window.POWER_CURVE || [];
  if (!pc.length || !Number.isFinite(ws)) return NaN;
  if (ws <= pc[0].ws) return pc[0].kw;
  for (let i=1;i<pc.length;i++) {
    if (ws <= pc[i].ws) {
      const a = pc[i-1], b = pc[i];
      const t = (ws - a.ws) / (b.ws - a.ws);
      return a.kw + t * (b.kw - a.kw);
    }
  }
  return pc[pc.length-1].kw;
};

// Temperature derating (if Average Ambient Temperature is provided)
window.expectedPowerKWFromWSTemp = function(ws, tempC){
  const p1 = window.expectedPowerKWFromWS(ws);
  if (!Number.isFinite(tempC)) return p1;
  // VBA rule: if T>35¬∞C then cap by P2 = 5950 - 110*T (kW)
  const p2 = (tempC > 35) ? Math.max(0, 5950 - 110*tempC) : Infinity;
  return Math.min(p1, p2);
};


let rawData = [];
let filteredData = [];
let displayData = [];
let variableNames = [];
let selectedVars = new Set();
let turbineFilter = '';
let selectedTurbines = new Set(); // NEW: multi-select turbines
let startDateFilter = null;
let endDateFilter = null;
// Pagination state
let currentPage = 1;
// Number of rows per page; adjust this number for performance vs. detail balance
let rowsPerPage = 200;

// Aggregation interval in minutes (default 10 minutes)
let intervalMinutes = 10;
// Category definitions and selection state
const categoryMap = {};
const categories = new Set();
let selectedCategories = new Set();

// Sorting state: which column and direction the table is currently sorted by.
// If column is null, no sorting is applied and displayData order is preserved.
let currentSort = { column: null, asc: true };

// Function to infer categories for variables
function inferCategories(vars) {
    vars.forEach(v => {
        let cat;
        const lower = v.toLowerCase();
        if (lower.includes('bearing')) {
            cat = 'Bearing';
        } else if (lower.includes('gearbox')) {
            cat = 'Gearbox';
        } else if (lower.includes('generator')) {
            cat = 'Generator';
        } else if (lower.includes('slipring')) {
            cat = 'Sliprings';
        } else if (lower.includes('trafo')) {
            cat = 'Trafo';
        } else if (lower.includes('temperature') || lower.includes('temp')) {
            cat = 'Temperature';
        } else if (lower.startsWith('average')) {
            cat = 'Average';
        } else {
            cat = 'Other';
        }
        categoryMap[v] = cat;
        categories.add(cat);
    });
}

// Populate category checkboxes
function populateCategoryList() {
    const listEl = document.getElementById('categoryList');
    listEl.innerHTML = '';
    Array.from(categories).sort().forEach(cat => {
        const item = document.createElement('label');
        item.className = 'category-item';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = selectedCategories.has(cat);
        checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
                selectedCategories.add(cat);
            } else {
                selectedCategories.delete(cat);
            }
            updateVariableListBasedOnCategories();
        });
        const span = document.createElement('span');
        span.textContent = cat;
        item.appendChild(checkbox);
        item.appendChild(span);
        listEl.appendChild(item);
    });
}

// Update variable list when category selection changes
function updateVariableListBasedOnCategories() {
    selectedVars.forEach(v => {
        if (!selectedCategories.has(categoryMap[v])) {
            selectedVars.delete(v);
        }
    });
    populateVariableList();
    applyFilters();
}

// Build turbine list (multi-select)
function populateTurbineList() {
    const listEl = document.getElementById('turbineList');
    if (!listEl) return;
    listEl.innerHTML = '';
    const searchTerm = document.getElementById('turbineSearch').value.trim().toLowerCase();
    const devices = Array.from(new Set(rawData.map(r => r['Device']).filter(Boolean))).sort();
    devices.forEach(dev => {
        if (searchTerm && !String(dev).toLowerCase().includes(searchTerm)) return;
        const item = document.createElement('div');
        item.className = 'turbine-item';
        item.textContent = dev;
        if (selectedTurbines.has(dev)) item.classList.add('selected');
        item.addEventListener('click', () => {
            if (selectedTurbines.has(dev)) {
                selectedTurbines.delete(dev);
            } else {
                selectedTurbines.add(dev);
            }
            populateTurbineList();
            applyFilters();
        });
        listEl.appendChild(item);
    });
}

// Build table based on filtered data and selected variables
function buildTable() {
    const thead = document.getElementById('tableHead');
    const tbody = document.getElementById('tableBody');
    thead.innerHTML = '';
    tbody.innerHTML = '';
    let dataArray = displayData || [];
    if (dataArray.length) {
        let cols = ['Date', 'Device'];
        const allSelected = selectedVars.size === 0 || selectedVars.size === variableNames.length;
        const displayVars = allSelected ? variableNames : Array.from(selectedVars);
        cols = cols.concat(displayVars);
        (function addTheoCol(){
            const windVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average wind speed'));
            if (windVarName && window.POWER_CURVE && window.POWER_CURVE.length){
                cols.push('Theoretical Power (kW)');
            }
        })();
        let sorted = dataArray;
        if (currentSort.column) {
            sorted = dataArray.slice().sort((a, b) => {
                const col = currentSort.column;
                let aval = a[col];
                let bval = b[col];
                if (col === 'Date') {
                    aval = new Date(a['Date'].replace(' ', 'T'));
                    bval = new Date(b['Date'].replace(' ', 'T'));
                    return currentSort.asc ? aval - bval : bval - aval;
                }
                const numA = parseFloat(aval);
                const numB = parseFloat(bval);
                if (!isNaN(numA) && !isNaN(numB)) {
                    return currentSort.asc ? numA - numB : numB - numA;
                }
                const sA = String(aval);
                const sB = String(bval);
                return currentSort.asc ? sA.localeCompare(sB) : sB.localeCompare(sA);
            });
        }
        dataArray = sorted;
        const trh = document.createElement('tr');
        cols.forEach(c => {
            const th = document.createElement('th');
            th.textContent = c;
            if (currentSort.column === c) {
                th.textContent += currentSort.asc ? ' ‚ñ≤' : ' ‚ñº';
            }
            th.style.cursor = 'pointer';
            th.addEventListener('click', () => {
                if (currentSort.column === c) {
                    currentSort.asc = !currentSort.asc;
                } else {
                    currentSort.column = c;
                    currentSort.asc = true;
                }
                currentPage = 1;
                buildTable();
            });
            trh.appendChild(th);
        });
        thead.appendChild(trh);
        const startIdx = (currentPage - 1) * rowsPerPage;
        const endIdx = startIdx + rowsPerPage;
        const pageData = dataArray.slice(startIdx, endIdx);
        pageData.forEach(row => {
            const tr = document.createElement('tr');
            cols.forEach(c => {
                const td = document.createElement('td');
                if (c === 'Theoretical Power (kW)'){
                const windVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average wind speed'));
                const wsVal = windVarName ? parseFloat(row[windVarName]) : NaN;
                const tempVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average ambient temperature'));
                const tC = tempVarName ? parseFloat(row[tempVarName]) : NaN;
                const th = Number.isFinite(wsVal) ? window.expectedPowerKWFromWSTemp(wsVal, tC) : NaN;
                td.textContent = Number.isFinite(th) ? (Math.round(th*1000)/1000).toString() : '';
            } else {
                td.textContent = row[c] !== undefined ? row[c] : '';
            }
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
    }
    const hScroll = document.getElementById('hScroll');
    const tableEl = document.getElementById('dataTable');
    const tableContainer = document.getElementById('tableContainer');
    if (hScroll && tableEl) {
        const inner = document.createElement('div');
        inner.style.width = tableEl.scrollWidth + 'px';
        inner.style.height = '1px';
        hScroll.innerHTML = '';
        hScroll.appendChild(inner);
        hScroll.scrollLeft = tableContainer.scrollLeft;
    }
    updatePaginationControls();
    updateChart();
}

// Apply all filters to rawData and update filteredData
function applyFilters() {
    if (!rawData.length) return;
    const turbSearch = turbineFilter.trim().toLowerCase();
    filteredData = rawData.filter(r => {
        let ok = true;
        const dev = r['Device'];
        // Device filter
        if (selectedTurbines.size > 0) {
            ok = ok && selectedTurbines.has(dev);
        } else if (turbSearch) {
            ok = ok && dev && String(dev).toLowerCase().includes(turbSearch);
        }
        // Date filter
        if (startDateFilter && endDateFilter) {
            const dateString = r['Date'];
            if (dateString) {
                const d = new Date(dateString);
                ok = ok && d >= startDateFilter && d <= endDateFilter;
            }
        }
        return ok;
    });
    updateDisplayData();
    currentPage = 1;
    buildTable();
}

// Populate variable list (similar to alarm list)
function populateVariableList() {
    const listEl = document.getElementById('variableList');
    listEl.innerHTML = '';
    const allItem = document.createElement('div');
    allItem.className = 'variable-item';
    allItem.textContent = 'ALL';
    const allSelected = selectedVars.size === 0 || selectedVars.size === variableNames.length;
    if (allSelected) allItem.classList.add('selected');
    allItem.addEventListener('click', () => {
        const applicable = variableNames.filter(v => {
            const catSelected = selectedCategories.has(categoryMap[v]);
            if (catSelected) return true;
            if (selectedCategories.has('Temperature')) {
                const vl = v.toLowerCase();
                return vl.includes('temperature') || vl.includes('temp');
            }
            return false;
        });
        const allSelectedNow = applicable.length > 0 && applicable.every(v => selectedVars.has(v));
        if (allSelectedNow) {
            applicable.forEach(v => selectedVars.delete(v));
        } else {
            applicable.forEach(v => selectedVars.add(v));
        }
        populateVariableList();
        applyFilters();
    });
    listEl.appendChild(allItem);
    const searchTerm = document.getElementById('variableSearch').value.toLowerCase();
    variableNames.forEach(name => {
        const lower = name.toLowerCase();
        let inSelected = selectedCategories.has(categoryMap[name]);
        if (!inSelected && selectedCategories.has('Temperature')) {
            if (lower.includes('temperature') || lower.includes('temp')) {
                inSelected = true;
            }
        }
        if (!inSelected) return;
        if (searchTerm && !lower.includes(searchTerm)) return;
        const item = document.createElement('div');
        item.className = 'variable-item';
        item.textContent = name;
        if (selectedVars.has(name)) item.classList.add('selected');
        item.addEventListener('click', () => {
            if (selectedVars.has(name)) {
                selectedVars.delete(name);
            } else {
                selectedVars.add(name);
            }
            populateVariableList();
            applyFilters();
        });
        listEl.appendChild(item);
    });
}

// Update pagination controls based on filteredData length and currentPage
function updatePaginationControls() {
    const controls = document.getElementById('paginationControls');
    if (!controls) return;
    controls.innerHTML = '';
    const totalRows = displayData ? displayData.length : 0;
    const totalPages = Math.ceil(totalRows / rowsPerPage);
    if (totalPages <= 1) return;
    const prevBtn = document.createElement('button');
    prevBtn.textContent = '<';
    prevBtn.disabled = currentPage === 1;
    prevBtn.addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage--;
            buildTable();
        }
    });
    controls.appendChild(prevBtn);
    const maxDisplayed = 5;
    let start = Math.max(1, currentPage - 2);
    let end = Math.min(totalPages, start + maxDisplayed - 1);
    if (end - start < maxDisplayed - 1) {
        start = Math.max(1, end - maxDisplayed + 1);
    }
    if (start > 1) {
        const firstBtn = document.createElement('button');
        firstBtn.textContent = '1';
        if (currentPage === 1) firstBtn.classList.add('active');
        firstBtn.addEventListener('click', () => {
            currentPage = 1;
            buildTable();
        });
        controls.appendChild(firstBtn);
        if (start > 2) {
            const dots = document.createElement('span');
            dots.textContent = '...';
            controls.appendChild(dots);
        }
    }
    for (let p = start; p <= end; p++) {
        const btn = document.createElement('button');
        btn.textContent = String(p);
        if (p === currentPage) btn.classList.add('active');
        btn.addEventListener('click', () => {
            currentPage = p;
            buildTable();
        });
        controls.appendChild(btn);
    }
    if (end < totalPages) {
        if (end < totalPages - 1) {
            const dots = document.createElement('span');
            dots.textContent = '...';
            controls.appendChild(dots);
        }
        const lastBtn = document.createElement('button');
        lastBtn.textContent = String(totalPages);
        if (currentPage === totalPages) lastBtn.classList.add('active');
        lastBtn.addEventListener('click', () => {
            currentPage = totalPages;
            buildTable();
        });
        controls.appendChild(lastBtn);
    }
    const nextBtn = document.createElement('button');
    nextBtn.textContent = '>';
    nextBtn.disabled = currentPage === totalPages;
    nextBtn.addEventListener('click', () => {
        if (currentPage < totalPages) {
            currentPage++;
            buildTable();
        }
    });
    controls.appendChild(nextBtn);
}

// Update displayData based on the current aggregation interval
function updateDisplayData() {
    if (!filteredData || !filteredData.length) {
        displayData = [];
        return;
    }
    if (intervalMinutes === 10) {
        displayData = filteredData.slice();
        return;
    }
    const groups = {};
    filteredData.forEach(row => {
        const dateStr = row['Date'];
        let d;
        if (dateStr) {
            try {
                const parts = dateStr.split(' ');
                const dateParts = parts[0].split('/');
                const timeParts = (parts[1] || '00:00:00').split(':');
                const year = parseInt(dateParts[0], 10);
                const month = parseInt(dateParts[1], 10) - 1;
                const day = parseInt(dateParts[2], 10);
                const hour = parseInt(timeParts[0], 10);
                const minute = parseInt(timeParts[1], 10);
                d = new Date(year, month, day, hour, minute);
            } catch (e) { d = null; }
        }
        if (!d || isNaN(d)) return;
        const ms = d.getTime();
        const bucketMs = Math.floor(ms / (intervalMinutes * 60000)) * (intervalMinutes * 60000);
        const bucketDate = new Date(bucketMs);
        const year = bucketDate.getFullYear();
        const month = String(bucketDate.getMonth() + 1).padStart(2, '0');
        const day = String(bucketDate.getDate()).padStart(2, '0');
        const hours = String(bucketDate.getHours()).padStart(2, '0');
        const minutes = String(bucketDate.getMinutes()).padStart(2, '0');
        const bucketKey = `${year}/${month}/${day} ${hours}:${minutes}:00.000`;
        const device = row['Device'];
        const key = bucketKey + '||' + device;
        if (!groups[key]) {
            groups[key] = { count: 0, Date: bucketKey, Device: device };
        }
        groups[key].count++;
        Object.keys(row).forEach(col => {
            if (col === 'Date' || col === 'Device') return;
            const val = parseFloat(row[col]);
            if (!isNaN(val)) {
                if (groups[key][col] === undefined) groups[key][col] = 0;
                groups[key][col] += val;
            }
        });
    });
    displayData = Object.values(groups).map(obj => {
        const count = obj.count || 1;
        const newRow = { Date: obj.Date, Device: obj.Device };
        Object.keys(obj).forEach(k => {
            if (k === 'count' || k === 'Date' || k === 'Device') return;
            newRow[k] = (obj[k] / count).toFixed(3);
        });
        return newRow;
    });
    displayData.sort((a, b) => {
        const parse = (str) => {
            const parts = str.split(' ');
            const dateParts = parts[0].split('/');
            const timeParts = (parts[1] || '00:00:00').split(':');
            const year = parseInt(dateParts[0], 10);
            const month = parseInt(dateParts[1], 10) - 1;
            const day = parseInt(dateParts[2], 10);
            const hour = parseInt(timeParts[0], 10);
            const minute = parseInt(timeParts[1], 10);
            return new Date(year, month, day, hour, minute);
        };
        const da = parse(a.Date);
        const db = parse(b.Date);
        if (da - db !== 0) return da - db;
        return a.Device.localeCompare(b.Device);
    });
}

function isPositiveVariable(varName) {
    const lower = varName.toLowerCase();
    if (lower.includes('temperature') || lower.includes('temp') || lower.includes('vibration') || lower.includes('rpm') || lower.includes('speed')) {
        return false;
    }
    return true;
}

// NEW: palette of dark hues
function darkColor(i, n) {
    const hue = (i * 360 / Math.max(1, n)) % 360;
    return `hsl(${hue}, 80%, 35%)`;
}

let chartGeomMain = null, chartGeomPower = null;
let seriesMain = null, seriesPower = null;
let currentDates = [];
function isAAP(name) {
    return String(name || '').toLowerCase().includes('average active power');
}
function setupOverlay(canvasEl, overlayEl) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvasEl.getBoundingClientRect();
    overlayEl.width = rect.width * dpr;
    overlayEl.height = rect.height * dpr;
    overlayEl.style.width = rect.width + 'px';
    overlayEl.style.height = rect.height + 'px';
    const ctx = overlayEl.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, rect.width, rect.height);
    return { ctx, rect };
}
function drawHairline(overlay, geom, idx) {
    if (!overlay || !geom || idx == null) return;
    const { ctx } = setupOverlay(geom.baseCanvas, overlay);
    const x = geom.leftPad + Math.max(0, Math.min(idx, currentDates.length - 1)) * geom.xStep;
    ctx.save();
    ctx.strokeStyle = '#d00';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, geom.topPad);
    ctx.lineTo(x, geom.topPad + geom.chartH);
    ctx.stroke();
    ctx.restore();
}

// Render chart in two modes + AAP chart + shared hairline
function updateChart() {
    const chartContainer = document.getElementById('chartContainer');
    const canvas = document.getElementById('chartCanvas');
    const overlay = document.getElementById('chartOverlay');
    const tooltip = document.getElementById('chartTooltip');

    const powerContainer = document.getElementById('powerChartContainer');
    const powerCanvas = document.getElementById('powerChartCanvas');
    const powerOverlay = document.getElementById('powerOverlay');
    const powerTooltip = document.getElementById('powerTooltip');

    if (!canvas || !chartContainer) return;

    let explicitVars = [];
    if (selectedVars.size > 0 && selectedVars.size <= variableNames.length) {
        explicitVars = Array.from(selectedVars);
    }
    const explicitTurbs = Array.from(selectedTurbines);
    const modeA = (displayData.length > 0 && explicitVars.length === 1);
    const modeB = (displayData.length > 0 && explicitTurbs.length === 1 && (explicitVars.length === 0 ? variableNames.length > 1 : explicitVars.length > 1));

    if (!modeA && !modeB) {
        chartContainer.style.display = 'none';
        if (powerContainer) powerContainer.style.display = 'none';
        return;
    }

    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, rect.width, rect.height);

    const leftPad = 60, rightPad = 20, topPad = 20, bottomPad = 46;
    const chartW = rect.width - leftPad - rightPad;
    const chartH = rect.height - topPad - bottomPad;

    const datesSet = new Set(displayData.map(r => r['Date']));
    const dates = Array.from(datesSet).sort((a, b) => new Date(a.replace(' ', 'T')) - new Date(b.replace(' ', 'T')));
    const xStep = chartW / Math.max(1, (dates.length - 1));
    currentDates = dates;

    let series = {};

    if (modeA) {
        const varName = explicitVars[0];
        if (!isAAP(varName)) {
          const devices = Array.from(new Set(displayData.map(r => r['Device'])));
          devices.forEach((dev, i) => {
              const vals = dates.map(d => {
                  const row = displayData.find(r => r['Date'] === d && r['Device'] === dev);
                  const v = row ? parseFloat(row[varName]) : null;
                  return isFinite(v) ? v : null;
              });
              series[`${dev} ‚Ä¢ ${varName}`] = { device: dev, var: varName, values: vals, color: darkColor(i, devices.length) };
          });
        }
    } else if (modeB) {
        const dev = explicitTurbs[0];
        const vars = (explicitVars.length > 0 ? explicitVars : variableNames).filter(vn => !isAAP(vn));
        vars.forEach((vn, i) => {
            const vals = dates.map(d => {
                const row = displayData.find(r => r['Date'] === d && r['Device'] === dev);
                const v = row ? parseFloat(row[vn]) : null;
                return isFinite(v) ? v : null;
            });
            series[`${dev} ‚Ä¢ ${vn}`] = { device: dev, var: vn, values: vals, color: darkColor(i, vars.length) };
        });
    }
    seriesMain = series;

    let yMin = Infinity, yMax = -Infinity;
    Object.values(series).forEach(s => s.values.forEach(v => {
        if (v === null) return;
        if (v < yMin) yMin = v;
        if (v > yMax) yMax = v;
    }));
    if (!isFinite(yMin) || !isFinite(yMax)) {
      chartContainer.style.display = 'none';
    }
    const pad = (yMax - yMin) * 0.1 || 1;
    yMin -= pad; yMax += pad;
    if (window.__yOverrideMain && isFinite(window.__yOverrideMain.min) && isFinite(window.__yOverrideMain.max)) {
        yMin = window.__yOverrideMain.min;
        yMax = window.__yOverrideMain.max;
    }
        if (window.__yOverrideMain && isFinite(window.__yOverrideMain.min) && isFinite(window.__yOverrideMain.max)) { yMin = window.__yOverrideMain.min; yMax = window.__yOverrideMain.max; }
// Axes
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(leftPad, topPad); ctx.lineTo(leftPad, topPad + chartH);
    ctx.moveTo(leftPad, topPad + chartH); ctx.lineTo(leftPad + chartW, topPad + chartH);
    ctx.stroke();

    // Y ticks
    const yTicks = 5;
    ctx.font = '12px Arial';
    for (let i = 0; i <= yTicks; i++) {
        const t = i / yTicks;
        const y = topPad + chartH - t * chartH;
        const val = (yMin + t * (yMax - yMin)).toFixed(2);
        ctx.fillStyle = '#222';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(val, leftPad - 6, y);
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.beginPath(); ctx.moveTo(leftPad, y); ctx.lineTo(leftPad + chartW, y); ctx.stroke();
    }

    // X labels
    const maxXLabels = 8;
    const skip = Math.ceil(dates.length / maxXLabels);
    ctx.fillStyle = '#222';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    for (let i = 0; i < dates.length; i += skip) {
        const x = leftPad + i * xStep;
        const label = dates[i].split(' ')[1];
        ctx.fillText(label, x, topPad + chartH + 6);
    }

    // Lines
    Object.values(series).forEach(s => {
        ctx.strokeStyle = s.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        let started = false;
        s.values.forEach((v, idx) => {
            if (v === null) { started = false; return; }
            const x = leftPad + idx * xStep;
            const y = topPad + chartH - (v - yMin) / (yMax - yMin) * chartH;
            if (!started) { ctx.moveTo(x, y); started = true; } else { ctx.lineTo(x, y); }
        });
        ctx.stroke();
    });

    chartContainer.style.display = 'block';
    chartGeomMain = { baseCanvas: canvas, leftPad, topPad, chartW, chartH, xStep, yMin, yMax };

    // ===== Second chart: AAP only =====
    const aapVarName = variableNames.find(v => isAAP(v));
    const wantsAAP = !!aapVarName && (explicitVars.length === 0 || explicitVars.includes(aapVarName));
    seriesPower = null;

    if (wantsAAP && powerContainer && powerCanvas) {
        const pctx = powerCanvas.getContext('2d');
        const prect = powerCanvas.getBoundingClientRect();
        powerCanvas.width = prect.width * dpr;
        powerCanvas.height = prect.height * dpr;
        pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        pctx.clearRect(0, 0, prect.width, prect.height);

        const Pleft = 60, Pright = 20, Ptop = 20, Pbottom = 40;
        const Pw = prect.width - Pleft - Pright;
        const Ph = prect.height - Ptop - Pbottom;
        const PxStep = Pw / Math.max(1, (dates.length - 1));

        // Build power-only series
        let sp = {};
        if (modeB && explicitTurbs.length === 1) {
            const dev = explicitTurbs[0];
            const vals = dates.map(d => {
                const row = displayData.find(r => r['Date'] === d && r['Device'] === dev);
                const v = row ? parseFloat(row[aapVarName]) : null;
                return isFinite(v) ? v : null;
            });
            sp[`${dev} ‚Ä¢ ${aapVarName}`] = { device: dev, var: aapVarName, values: vals, color: '#d62728' };
        } else {
            const devices = Array.from(new Set(displayData.map(r => r['Device'])));
            devices.forEach((dev, i) => {
                const vals = dates.map(d => {
                    const row = displayData.find(r => r['Date'] === d && r['Device'] === dev);
                    const v = row ? parseFloat(row[aapVarName]) : null;
                    return isFinite(v) ? v : null;
                });
                sp[`${dev} ‚Ä¢ ${aapVarName}`] = { device: dev, var: aapVarName, values: vals, color: darkColor(i, devices.length) };
            });
        }
        // === Theoretical from Average Wind Speed using embedded power curve ===
        (function addTheoreticalSeries(){
          const windVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average wind speed'));
          if (!windVarName || !(window.POWER_CURVE && window.POWER_CURVE.length)) return;
          const __expTurbs = (typeof explicitTurbs2 !== 'undefined' && explicitTurbs2 && explicitTurbs2.length ? explicitTurbs2
                               : (typeof explicitTurbs !== 'undefined' ? explicitTurbs : []));
          if (__expTurbs.length === 1) {
            const dev2 = __expTurbs[0];
            const tempVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average ambient temperature'));
            const valsTh = dates.map(d => {
              const row = displayData.find(r => r['Date'] === d && r['Device'] === dev2);
              const ws  = row ? parseFloat(row[windVarName]) : NaN;
              const tC  = row && tempVarName ? parseFloat(row[tempVarName]) : NaN;
              const th  = Number.isFinite(ws) ? window.expectedPowerKWFromWSTemp(ws, tC) : NaN;
              return Number.isFinite(th) ? th : null;
            });
            sp[`${dev2} ‚Ä¢ Theoretical Power (from WS)`] = { device: dev2, var: 'Theoretical Power (kW)', values: valsTh, color: '#006400', dashed: true, thick: true };
          } else {
            const devices2 = Array.from(new Set(displayData.map(r => r['Device'])));
            devices2.forEach((dev2, i2) => {
              const tempVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average ambient temperature'));
              const valsTh = dates.map(d => {
                const row = displayData.find(r => r['Date'] === d && r['Device'] === dev2);
                const ws  = row ? parseFloat(row[windVarName]) : NaN;
                const tC  = row && tempVarName ? parseFloat(row[tempVarName]) : NaN;
                const th  = Number.isFinite(ws) ? window.expectedPowerKWFromWSTemp(ws, tC) : NaN;
                return Number.isFinite(th) ? th : null;
              });
              sp[`${dev2} ‚Ä¢ Theoretical Power (from WS)`] = { device: dev2, var: 'Theoretical Power (kW)', values: valsTh, color: '#006400', dashed: true, thick: true };
            });
          }
        })();
        seriesPower = sp;
        // y-range power
        let PyMin = Infinity, PyMax = -Infinity;
        Object.values(sp).forEach(s => s.values.forEach(v => {
            if (v == null) return;
            if (v < PyMin) PyMin = v;
            if (v > PyMax) PyMax = v;
        }));
        const Ppad = (PyMax - PyMin) * 0.1 || 1;
        PyMin -= Ppad; PyMax += Ppad;
        if (window.__yOverridePower && isFinite(window.__yOverridePower.min) && isFinite(window.__yOverridePower.max)) {
            PyMin = window.__yOverridePower.min;
            PyMax = window.__yOverridePower.max;
        }
                if (window.__yOverridePower && isFinite(window.__yOverridePower.min) && isFinite(window.__yOverridePower.max)) { PyMin = window.__yOverridePower.min; PyMax = window.__yOverridePower.max; }
// Axes power
        pctx.strokeStyle = '#111';
        pctx.lineWidth = 1;
        pctx.beginPath();
        pctx.moveTo(Pleft, Ptop); pctx.lineTo(Pleft, Ptop + Ph);
        pctx.moveTo(Pleft, Ptop + Ph); pctx.lineTo(Pleft + Pw, Ptop + Ph);
        pctx.stroke(); pctx.setLineDash([]);

        // Y ticks power
        pctx.font = '12px Arial';
        for (let i = 0; i <= 5; i++) {
            const t = i / 5;
            const y = Ptop + Ph - t * Ph;
            const val = (PyMin + t * (PyMax - PyMin)).toFixed(2);
            pctx.fillStyle = '#222';
            pctx.textAlign = 'right';
            pctx.textBaseline = 'middle';
            pctx.fillText(val, Pleft - 6, y);
            pctx.strokeStyle = 'rgba(0,0,0,0.08)';
            pctx.beginPath(); pctx.moveTo(Pleft, y); pctx.lineTo(Pleft + Pw, y); pctx.stroke(); pctx.setLineDash([]);
        }
        // X labels power
        pctx.fillStyle = '#222';
        pctx.textAlign = 'center';
        pctx.textBaseline = 'top';
        for (let i = 0; i < dates.length; i += Math.ceil(dates.length / 8)) {
            const x = Pleft + i * PxStep;
            const label = dates[i].split(' ')[1];
            pctx.fillText(label, x, Ptop + Ph + 6);
        }
        // Lines power
        Object.values(sp).forEach(s => {
            pctx.strokeStyle = s.color;
            pctx.lineWidth = 2;
            pctx.beginPath();
            let started = false;
            s.values.forEach((v, idx) => {
                if (v == null) { started = false; return; }
                const x = Pleft + idx * PxStep;
                const y = Ptop + Ph - (v - PyMin) / (PyMax - PyMin) * Ph;
                if (!started) { pctx.moveTo(x, y); started = true; } else { pctx.lineTo(x, y); }
            });
            pctx.stroke(); pctx.setLineDash([]);
        });

        powerContainer.style.display = 'block';
        chartGeomPower = { baseCanvas: powerCanvas, leftPad: Pleft, topPad: Ptop, chartW: Pw, chartH: Ph, xStep: PxStep, yMin: PyMin, yMax: PyMax };
    } else {
        if (powerContainer) powerContainer.style.display = 'none';
        chartGeomPower = null;
        seriesPower = null;
    }


function buildTooltipHTML(series, idx) {
        if (!series || idx == null || !Array.isArray(series.values)) return '';
        const value = series.values[idx];
        const dateStr = (typeof currentDates !== 'undefined' && currentDates && currentDates[idx]) ? currentDates[idx] : '';
        const valText = (value == null || !isFinite(value)) ? '‚Äî' : String(Number(value.toFixed ? value.toFixed(3) : value));
        return `<div class="tooltip-card">
                  <div class="tt-body">
                    <div class="tt-row active">
                      <span class="tt-label">Variable</span>
                      <span class="tt-value">${series.var || series.label || ''}</span>
                    </div>
                    <div class="tt-row">
                      <span class="tt-label">Value</span>
                      <span class="tt-value">${valText}</span>
                    </div>
                    <div class="tt-row">
                      <span class="tt-label">Turbine</span>
                      <span class="tt-value">${series.device || ''}</span>
                    </div>
                    <div class="tt-row">
                      <span class="tt-label">Time</span>
                      <span class="tt-value">${dateStr}</span>
                    </div>
                  </div>
                </div>`;
}

    function handleMove(evt, which) {
const c = which === 'main' ? canvas : powerCanvas;
        const t = which === 'main' ? tooltip : powerTooltip;
        if (!c || !t) return;
        if (window.__isChartsFS) { t.style.position = 'fixed'; } else { t.style.position = 'absolute'; }
        if (window.__isChartsFS) { t.style.position = 'fixed'; t.style.zIndex = 10000; } else { t.style.position = 'absolute'; t.style.zIndex = ''; }
        const r = c.getBoundingClientRect();
        const mx = evt.clientX - r.left;
        const my = evt.clientY - r.top;
        const geom = which === 'main' ? chartGeomMain : chartGeomPower;
        if (!geom) return;

        const px = mx - geom.leftPad;
        const py = my - geom.topPad;

        if (px < 0 || px > geom.chartW || py < 0 || py > geom.chartH) {
            t.style.display = 'none';
            drawHairline(document.getElementById('chartOverlay'), chartGeomMain, null);
            drawHairline(document.getElementById('powerOverlay'), chartGeomPower, null);
            return;
        }

        const idx = Math.round(px / geom.xStep);

        drawHairline(document.getElementById('chartOverlay'), chartGeomMain, idx);
        drawHairline(document.getElementById('powerOverlay'), chartGeomPower, idx);

        // Map cursor Y to data value range so we can pick the closest series
        const vCursor = geom.yMax - (py / geom.chartH) * (geom.yMax - geom.yMin);

        const src = which === 'main' ? seriesMain : seriesPower;
        let best = null;
        let bestDist = Infinity;

        if (src) {
            Object.entries(src).forEach(([label, s]) => {
                const v = s.values ? s.values[idx] : undefined;
                if (v == null || !isFinite(v)) return;
                const d = Math.abs(v - vCursor);
                if (d < bestDist) { bestDist = d; best = Object.assign({ label }, s); }
            });
        }

        if (!best) {
            t.style.display = 'none';
            return;
        }

        window.selectedSeries = best;
        const html = buildTooltipHTML(best, idx);
        t.innerHTML = html;
        t.style.left = (evt.clientX + 10) + 'px';
        t.style.top  = (evt.clientY + 10) + 'px';
        t.style.display = 'block';
        if (window.__clampTooltip) window.__clampTooltip(t);
}
    function handleLeave() {
        if (tooltip) tooltip.style.display = 'none';
        if (powerTooltip) powerTooltip.style.display = 'none';
        drawHairline(document.getElementById('chartOverlay'), chartGeomMain, null);
        drawHairline(document.getElementById('powerOverlay'), chartGeomPower, null);
    }

    canvas.onmousemove = (e)=>handleMove(e,'main');
    canvas.onmouseleave = handleLeave;

    if (powerContainer && powerContainer.style.display !== 'none') {
        powerCanvas.onmousemove = (e)=>handleMove(e,'power');
        powerCanvas.onmouseleave = handleLeave;
    } else if (powerCanvas) {
        powerCanvas.onmousemove = null;
        powerCanvas.onmouseleave = null;
    }
}

// Quick filter helpers
function setToday() {
    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    startDateFilter = start;
    endDateFilter = now;
    document.getElementById('startDate').valueAsDate = start;
    document.getElementById('startTime').value = start.toTimeString().slice(0,5);
    document.getElementById('endDate').valueAsDate = now;
    document.getElementById('endTime').value = now.toTimeString().slice(0,5);
    applyFilters();
}
function setYesterday() {
    const now = new Date();
    const start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
    const end = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    startDateFilter = start;
    endDateFilter = end;
    document.getElementById('startDate').valueAsDate = start;
    document.getElementById('startTime').value = start.toTimeString().slice(0,5);
    document.getElementById('endDate').valueAsDate = end;
    document.getElementById('endTime').value = end.toTimeString().slice(0,5);
    applyFilters();
}
function setLast24h() {
    const now = new Date();
    const start = new Date(now.getTime() - 24 * 3600 * 1000);
    startDateFilter = start;
    endDateFilter = now;
    document.getElementById('startDate').valueAsDate = start;
    document.getElementById('startTime').value = start.toTimeString().slice(0,5);
    document.getElementById('endDate').valueAsDate = now;
    document.getElementById('endTime').value = now.toTimeString().slice(0,5);
    applyFilters();
}
function clearTime() {
    startDateFilter = null;
    endDateFilter = null;
    document.getElementById('startDate').value = '';
    document.getElementById('startTime').value = '';
    document.getElementById('endDate').value = '';
    document.getElementById('endTime').value = '';
    applyFilters();
}

// Update custom range filter when inputs change
function updateCustomTimeFilter() {
    const sd = document.getElementById('startDate').value;
    const st = document.getElementById('startTime').value;
    const ed = document.getElementById('endDate').value;
    const et = document.getElementById('endTime').value;
    if (sd && st && ed && et) {
        startDateFilter = new Date(sd + 'T' + st);
        endDateFilter = new Date(ed + 'T' + et);
    } else {
        startDateFilter = null;
        endDateFilter = null;
    }
    applyFilters();
}

// File upload handler
document.getElementById('csvInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(evt) {
        const lines = evt.target.result.trim().split(/\r?\n/);
        if (!lines.length) return;
        const headers = lines[0].split(';');
        rawData = [];
        for (let i = 1; i < lines.length; i++) {
            const row = lines[i].split(';');
            if (row.length !== headers.length) continue;
            const obj = {};
            for (let j = 0; j < headers.length; j++) {
                let key = headers[j];
                if (key.startsWith('\\uFEFF')) key = key.replace('\\uFEFF', '');
                obj[key] = row[j];
            }
            rawData.push(obj);
        }
        rawData.forEach(r => {
            if (r['\\uFEFFDevice']) { r['Device'] = r['\\uFEFFDevice']; delete r['\\uFEFFDevice']; }
            if (r['Date']) { r['Date'] = r['Date'].replace('T', ' '); }
        });
        if (rawData.length) {
            variableNames = Object.keys(rawData[0]).filter(k => k !== 'Device' && k !== 'Date');
        } else {
            variableNames = [];
        }
        categories.clear();
        Object.keys(categoryMap).forEach(k => delete categoryMap[k]);
        inferCategories(variableNames);
        selectedCategories = new Set(categories);
        selectedVars = new Set(variableNames);
        populateCategoryList();
        populateVariableList();
        selectedTurbines.clear();
        turbineFilter = '';
        document.getElementById('turbineSearch').value = '';
        populateTurbineList();

        clearTime();
        filteredData = rawData.slice();
        updateDisplayData();
        buildTable();
    };
    reader.readAsText(file);
});

// Search handlers
document.getElementById('turbineSearch').addEventListener('input', function(e) {
    turbineFilter = e.target.value;
    populateTurbineList();
    applyFilters();
});

document.getElementById('btnClearTurbine').addEventListener('click', function() {
    turbineFilter = '';
    document.getElementById('turbineSearch').value = '';
    selectedTurbines.clear();
    populateTurbineList();
    applyFilters();
});

document.getElementById('variableSearch').addEventListener('input', function() {
    populateVariableList();
});

// Date/time input listeners
document.getElementById('startDate').addEventListener('change', updateCustomTimeFilter);
document.getElementById('startTime').addEventListener('change', updateCustomTimeFilter);
document.getElementById('endDate').addEventListener('change', updateCustomTimeFilter);
document.getElementById('endTime').addEventListener('change', updateCustomTimeFilter);

// Quick filter buttons
document.getElementById('btnToday').addEventListener('click', setToday);
document.getElementById('btnYesterday').addEventListener('click', setYesterday);
document.getElementById('btnLast24').addEventListener('click', setLast24h);
document.getElementById('btnClearTime').addEventListener('click', clearTime);

// Aggregation interval selector
document.getElementById('intervalSelect').addEventListener('change', function() {
    intervalMinutes = parseInt(this.value);
    updateDisplayData();
    currentPage = 1;
    buildTable();
});

// Download buttons (unchanged)
document.getElementById('btnDownloadCSV').addEventListener('click', function() {
    if (!displayData || displayData.length === 0) return;
    let cols = ['Date', 'Device'];
    const allSelected = selectedVars.size === 0 || selectedVars.size === variableNames.length;
    const displayVars = allSelected ? variableNames : Array.from(selectedVars);
    cols = cols.concat(displayVars);
        (function addTheoCol(){
            const windVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average wind speed'));
            if (windVarName && window.POWER_CURVE && window.POWER_CURVE.length){
                cols.push('Theoretical Power (kW)');
            }
        })();
    let csv = cols.join(',') + '\n';
    displayData.forEach(row => {
        const vals = cols.map(col => row[col] !== undefined ? row[col] : '');
        csv += vals.join(',') + '\n';
    });
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'XMinutal_Report.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});

document.getElementById('btnDownloadXLS').addEventListener('click', function() {
    if (!displayData || displayData.length === 0) return;
    let cols = ['Date', 'Device'];
    const allSelected = selectedVars.size === 0 || selectedVars.size === variableNames.length;
    const displayVars = allSelected ? variableNames : Array.from(selectedVars);
    cols = cols.concat(displayVars);
        (function addTheoCol(){
            const windVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average wind speed'));
            if (windVarName && window.POWER_CURVE && window.POWER_CURVE.length){
                cols.push('Theoretical Power (kW)');
            }
        })();
    let html = '<table><tr>' + cols.map(c => `<th>${c}</th>`).join('') + '</tr>';
    displayData.forEach(row => {
        html += '<tr>' + cols.map(col => `<td>${row[col] !== undefined ? row[col] : ''}</td>`).join('') + '</tr>';
    });
    html += '</table>';
    const uri = 'data:application/vnd.ms-excel;base64,' + btoa(unescape(encodeURIComponent(html)));
    const link = document.createElement('a');
    link.href = uri;
    link.download = 'XMinutal_Report.xls';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});

document.getElementById('btnDownloadPDF').addEventListener('click', async function() {
    if (!displayData || displayData.length === 0) return;
    let cols = ['Date', 'Device'];
    const allSelected = selectedVars.size === 0 || selectedVars.size === variableNames.length;
    const displayVars = allSelected ? variableNames : Array.from(selectedVars);
    cols = cols.concat(displayVars);
        (function addTheoCol(){
            const windVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average wind speed'));
            if (windVarName && window.POWER_CURVE && window.POWER_CURVE.length){
                cols.push('Theoretical Power (kW)');
            }
        })();

    const pageWpt = 595.28;
    const pageHpt = 841.89;
    const dpi = 96;
    const pxW = Math.floor(pageWpt / 72 * dpi);
    const pxH = Math.floor(pageHpt / 72 * dpi);
    const margin = Math.floor(20 / 72 * dpi);
    const headerH = Math.floor(24 / 72 * dpi);
    const rowH = Math.floor(18 / 72 * dpi);

    function createPageCanvas() {
        const canvas = document.createElement('canvas');
        canvas.width = pxW;
        canvas.height = pxH;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, pxW, pxH);
        return { canvas, ctx };
    }
    function drawHeader(ctx, y0) {
        ctx.fillStyle = '#e6f2ff';
        ctx.fillRect(margin, y0, pxW - 2 * margin, headerH);
        ctx.fillStyle = '#004b8d';
        ctx.font = `${Math.floor(12 / 72 * dpi)}px Arial`;
        const colW = Math.floor((pxW - 2 * margin) / cols.length);
        let x = margin + 4;
        cols.forEach(col => {
            ctx.fillText(String(col), x, y0 + headerH - 6);
            x += colW;
        });
        return y0 + headerH;
    }
    function drawRow(ctx, row, y0) {
        ctx.fillStyle = '#000000';
        ctx.font = `${Math.floor(11 / 72 * dpi)}px Arial`;
        const colW = Math.floor((pxW - 2 * margin) / cols.length);
        let x = margin + 4;
        cols.forEach(col => {
            const text = row[col] !== undefined ? String(row[col]) : '';
            ctx.fillText(text, x, y0 + rowH - 4);
            x += colW;
        });
        ctx.strokeStyle = '#cce0ff';
        ctx.beginPath();
        ctx.moveTo(margin, y0 + rowH);
        ctx.lineTo(pxW - margin, y0 + rowH);
        ctx.stroke();
        return y0 + rowH;
    }

    const chartVisible = document.getElementById('chartContainer') && document.getElementById('chartContainer').style.display !== 'none';
    const chartCanvasEl = document.getElementById('chartCanvas');

    const pages = [];
    let rowIndex = 0;
    let pageNumber = 0;
    while (rowIndex < displayData.length || (pageNumber === 0 && chartVisible)) {
        const { canvas: pageCanvas, ctx } = createPageCanvas();
        let yPos = margin;
        if (pageNumber === 0 && chartVisible && chartCanvasEl && chartCanvasEl.width && chartCanvasEl.height) {
            const chartDataUrl = chartCanvasEl.toDataURL('image/png');
            const img = new Image();
            await new Promise(resolve => { img.onload = resolve; img.src = chartDataUrl; });
            const availableW = pxW - 2 * margin;
            const scale = availableW / img.width;
            let chartH = Math.round(img.height * scale);
            const maxChartH = Math.floor(pxH * 0.30);
            if (chartH > maxChartH) chartH = maxChartH;
            const chartW = Math.round(img.width * chartH / img.height);
            ctx.drawImage(img, margin, yPos, chartW, chartH);
            yPos += chartH + Math.floor(12 / 72 * dpi);
        }
        yPos = drawHeader(ctx, yPos);
        while (rowIndex < displayData.length && yPos + rowH <= pxH - margin) {
            yPos = drawRow(ctx, displayData[rowIndex], yPos);
            rowIndex++;
        }
        pages.push(pageCanvas);
        pageNumber++;
    }

    const pageImages = [];
    for (let i = 0; i < pages.length; i++) {
        const dataUrl = pages[i].toDataURL('image/jpeg', 0.9);
        const b64 = dataUrl.split(',')[1];
        const binStr = atob(b64);
        const binArr = new Uint8Array(binStr.length);
        for (let j = 0; j < binStr.length; j++) { binArr[j] = binStr.charCodeAt(j); }
        pageImages.push({ data: binArr });
    }

    function buildPDF(jpegPages) {
        const enc = new TextEncoder();
        const chunks = [];
        const offsets = [];
        let position = 0;
        function addChunk(u8) { offsets.push(position); chunks.push(u8); position += u8.length; }
        const encode = s => enc.encode(s);
        addChunk(encode('%PDF-1.3\n'));
        let objNum = 1;
        const pageObjs = [];
        jpegPages.forEach((pg, idx) => {
            const imgHeader = encode(`<< /Type /XObject /Subtype /Image /Width ${Math.floor(pageWpt)} /Height ${Math.floor(pageHpt)} /ColorSpace /DeviceRGB /BitsPerComponent 8 /Filter /DCTDecode /Length ${pg.data.length} >>\nstream\n`);
            const imgFooter = encode('\nendstream');
            const combined = new Uint8Array(imgHeader.length + pg.data.length + imgFooter.length);
            combined.set(imgHeader, 0);
            combined.set(pg.data, imgHeader.length);
            combined.set(imgFooter, imgHeader.length + pg.data.length);
            const imgObj = objNum++;
            pg.imgObj = imgObj;
            addChunk(encode(`${imgObj} 0 obj\n`));
            addChunk(combined);
            addChunk(encode('\nendobj\n'));

            const contentStr = `q\n${pageWpt} 0 0 ${pageHpt} 0 0 cm\n/Im${idx} Do\nQ\n`;
            const contentObj = objNum++;
            pg.contentObj = contentObj;
            addChunk(encode(`${contentObj} 0 obj\n<< /Length ${contentStr.length} >>\nstream\n${contentStr}\nendstream\nendobj\n`));

            const pageObj = objNum++;
            pg.pageObj = pageObj;
            pageObjs.push(pageObj);
        });
        const pagesObj = objNum++;
        const kidsString = pageObjs.map(n => `${n} 0 R`).join(' ');
        addChunk(encode(`${pagesObj} 0 obj\n<< /Type /Pages /Kids [ ${kidsString} ] /Count ${pageObjs.length} >>\nendobj\n`));

        jpegPages.forEach((pg, idx) => {
            const pageStr = `${pg.pageObj} 0 obj\n<< /Type /Page /Parent ${pagesObj} 0 R /MediaBox [0 0 ${pageWpt} ${pageHpt}] /Resources << /XObject << /Im${idx} ${pg.imgObj} 0 R >> >> /Contents ${pg.contentObj} 0 R >>\nendobj\n`;
            addChunk(encode(pageStr));
        });
        const catalogObj = objNum++;
        addChunk(encode(`${catalogObj} 0 obj\n<< /Type /Catalog /Pages ${pagesObj} 0 R >>\nendobj\n`));

        const xrefStart = position;
        let xref = `xref\n0 ${objNum}\n`;
        xref += '0000000000 65535 f \n';
        for (let i = 1; i < offsets.length; i++) {
            xref += String(offsets[i]).padStart(10, '0') + ' 00000 n \n';
        }
        addChunk(encode(xref));
        addChunk(encode(`trailer\n<< /Size ${objNum} /Root ${catalogObj} 0 R >>\nstartxref\n${xrefStart}\n%%EOF`));
        let total = 0;
        chunks.forEach(ch => { total += ch.length; });
        const pdf = new Uint8Array(total);
        let off = 0;
        chunks.forEach(ch => { pdf.set(ch, off); off += ch.length; });
        return pdf;
    }

    const pdfBytes = buildPDF(pageImages);
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'XMinutal_Report.pdf';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
});

// Sync horizontal scrolling
window.addEventListener('DOMContentLoaded', () => {
    const hScroll = document.getElementById('hScroll');
    const tableContainer = document.getElementById('tableContainer');
    if (hScroll && tableContainer) {
        hScroll.addEventListener('scroll', () => { tableContainer.scrollLeft = hScroll.scrollLeft; });
        tableContainer.addEventListener('scroll', () => { hScroll.scrollLeft = tableContainer.scrollLeft; });
    }

    // Soft UI helpers
    var toggle = document.getElementById('sidebarToggle');
    var topBtn = document.getElementById('scrollTop');
    var bottomBtn = document.getElementById('scrollBottom');
    if (toggle) {
      toggle.addEventListener('click', function() {
        document.body.classList.toggle('sidebar-open');
      });
    }
    if (topBtn) {
      topBtn.addEventListener('click', function(){ window.scrollTo({ top: 0, behavior: 'smooth' }); });
    }
    if (bottomBtn) {
      bottomBtn.addEventListener('click', function(){ window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }); });
    }
    // Close sidebar when clicking backdrop on mobile
    document.addEventListener('click', function(e){
      if (document.body.classList.contains('sidebar-open')) {
        var sb = document.getElementById('sidebar');
        if (sb && !sb.contains(e.target) && !toggle.contains(e.target)) {
          document.body.classList.remove('sidebar-open');
        }
      }
    }, true);
});
  </script>

  <script id="theme-toggle-script">
  (function() {
    function applyTheme(t) {
      document.documentElement.setAttribute('data-theme', t);
      try { localStorage.setItem('theme', t); } catch(e) {}
      var btn = document.getElementById('themeToggle');
      if (btn) btn.textContent = (t === 'dark') ? 'üåû' : 'üåô';
    }
    var saved = null;
    try { saved = localStorage.getItem('theme'); } catch(e) {}
    if (saved) {
      applyTheme(saved);
    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      applyTheme('dark');
    } else {
      applyTheme('light');
    }
    document.addEventListener('DOMContentLoaded', function() {
      var btn = document.getElementById('themeToggle');
      if (!btn) return;
      btn.addEventListener('click', function() {
        var cur = document.documentElement.getAttribute('data-theme') || 'light';
        applyTheme(cur === 'dark' ? 'light' : 'dark');
      });
    });
  })();
  </script>

  <script id="pro-tooltip-logic">
  (function(){
    // Re-implement updateChart with series highlight + pro tooltip
    function drawSeriesOverlay(overlay, geom, series, idx) {
      if (!overlay || !geom || !series) return;
      const dpr = window.devicePixelRatio || 1;
      const rect = geom.baseCanvas.getBoundingClientRect();
      overlay.width = rect.width * dpr;
      overlay.height = rect.height * dpr;
      overlay.style.width = rect.width + 'px';
      overlay.style.height = rect.height + 'px';
      const ctx = overlay.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, rect.width, rect.height);
      // Full highlighted series line
      ctx.lineWidth = 3;
      ctx.strokeStyle = series.color || '#3b82f6';
      ctx.shadowColor = series.color || '#3b82f6';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      let started = false;
      series.values.forEach((v, i) => {
        if (v == null) { started = false; return; }
        const x = geom.leftPad + i * geom.xStep;
        const y = geom.topPad + geom.chartH - (v - geom.yMin) / (geom.yMax - geom.yMin) * geom.chartH;
        if (!started) { ctx.moveTo(x, y); started = true; } else { ctx.lineTo(x, y); }
      });
      ctx.stroke();
      // Focus point (if an index is provided)
      if (typeof idx === 'number' && series.values[idx] != null) {
        const v = series.values[idx];
        const x = geom.leftPad + idx * geom.xStep;
        const y = geom.topPad + geom.chartH - (v - geom.yMin) / (geom.yMax - geom.yMin) * geom.chartH;
        ctx.shadowBlur = 10;
        ctx.fillStyle = series.color || '#3b82f6';
        ctx.beginPath(); ctx.arc(x, y, 4.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x, y, 4.5, 0, Math.PI*2); ctx.stroke();
      }
    }

    // Helper to compute y-range from a series map
    function computeYRange(seriesMap) {
      let yMin = Infinity, yMax = -Infinity;
      Object.values(seriesMap || {}).forEach(s => (s.values||[]).forEach(v => {
        if (v == null) return;
        if (v < yMin) yMin = v;
        if (v > yMax) yMax = v;
      }));
      if (!isFinite(yMin) || !isFinite(yMax)) { yMin = 0; yMax = 1; }
      const pad = (yMax - yMin) * 0.1 || 1;
      return { yMin: yMin - pad, yMax: yMax + pad };
    }

    // Replacement updateChart
    window.updateChart = function updateChart(){
      const chartContainer = document.getElementById('chartContainer');
      const canvas = document.getElementById('chartCanvas');
      const overlay = document.getElementById('chartOverlay');
      const tooltip = document.getElementById('chartTooltip');

      const powerContainer = document.getElementById('powerChartContainer');
      const powerCanvas = document.getElementById('powerChartCanvas');
      const powerOverlay = document.getElementById('powerOverlay');
      const powerTooltip = document.getElementById('powerTooltip');

      if (!canvas || !chartContainer) return;

      let explicitVars = [];
      if (selectedVars.size > 0 && selectedVars.size <= variableNames.length) explicitVars = Array.from(selectedVars);
      const explicitTurbs = Array.from(selectedTurbines);

      const modeA = (displayData.length > 0 && explicitVars.length === 1);
      const modeB = (displayData.length > 0 && explicitTurbs.length === 1 && (explicitVars.length === 0 ? variableNames.length > 1 : explicitVars.length > 1));

      if (!modeA && !modeB) {
        chartContainer.style.display = 'none';
        if (powerContainer) powerContainer.style.display = 'none';
        return;
      }

      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, rect.width, rect.height);

      const leftPad = 60, rightPad = 20, topPad = 20, bottomPad = 46;
      const chartW = rect.width - leftPad - rightPad;
      const chartH = rect.height - topPad - bottomPad;

      const datesSet = new Set(displayData.map(r => r['Date']));
      const dates = Array.from(datesSet).sort((a, b) => new Date(a.replace(' ', 'T')) - new Date(b.replace(' ', 'T')));
      const xStep = chartW / Math.max(1, (dates.length - 1));
      currentDates = dates;

      let series = {};
      if (modeA) {
        const varName = explicitVars[0];
        if (!isAAP(varName)) {
          const devices = Array.from(new Set(displayData.map(r => r['Device'])));
          devices.forEach((dev, i) => {
            const vals = dates.map(d => {
              const row = displayData.find(r => r['Date'] === d && r['Device'] === dev);
              const v = row ? parseFloat(row[varName]) : null;
              return isFinite(v) ? v : null;
            });
            series[`${dev} ‚Ä¢ ${varName}`] = { device: dev, var: varName, values: vals, color: darkColor(i, devices.length) };
          });
        }
      } else if (modeB) {
        const dev = explicitTurbs[0];
        const vars = (explicitVars.length > 0 ? explicitVars : variableNames).filter(vn => !isAAP(vn));
        vars.forEach((vn, i) => {
          const vals = dates.map(d => {
            const row = displayData.find(r => r['Date'] === d && r['Device'] === dev);
            const v = row ? parseFloat(row[vn]) : null;
            return isFinite(v) ? v : null;
          });
          series[`${dev} ‚Ä¢ ${vn}`] = { device: dev, var: vn, values: vals, color: darkColor(i, vars.length) };
        });
      }
      seriesMain = series;

      // y-range
      const rng = computeYRange(series);
      const yMin = rng.yMin, yMax = rng.yMax;

      // Axes
      ctx.strokeStyle = '#111'; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(leftPad, topPad); ctx.lineTo(leftPad, topPad + chartH);
      ctx.moveTo(leftPad, topPad + chartH); ctx.lineTo(leftPad + chartW, topPad + chartH);
      ctx.stroke();

      // Y ticks
      ctx.font = '12px Arial';
      for (let i = 0; i <= 5; i++) {
        const t = i / 5;
        const y = topPad + chartH - t * chartH;
        const val = (yMin + t * (yMax - yMin)).toFixed(2);
        ctx.fillStyle = '#222';
        ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        ctx.fillText(val, leftPad - 6, y);
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.beginPath(); ctx.moveTo(leftPad, y); ctx.lineTo(leftPad + chartW, y); ctx.stroke();
      }

      // X labels
      const maxXLabels = 8;
      const skip = Math.ceil(dates.length / maxXLabels);
      ctx.fillStyle = '#222'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
      for (let i = 0; i < dates.length; i += skip) {
        const x = leftPad + i * xStep;
        const label = dates[i].split(' ')[1];
        ctx.fillText(label, x, topPad + chartH + 6);
      }

      // Lines
      Object.values(series).forEach(s => {
        ctx.strokeStyle = s.color; ctx.lineWidth = 2; ctx.beginPath();
        let started = false;
        s.values.forEach((v, idx) => {
          if (v === null) { started = false; return; }
          const x = leftPad + idx * xStep;
          const y = topPad + chartH - (v - yMin) / (yMax - yMin) * chartH;
          if (!started) { ctx.moveTo(x, y); started = true; } else { ctx.lineTo(x, y); }
        });
        ctx.stroke();
      });

      chartContainer.style.display = 'block';
      chartGeomMain = { baseCanvas: canvas, leftPad, topPad, chartW, chartH, xStep, yMin, yMax };

      // ==== Power/AAP chart ====
      const aapVarName = variableNames.find(v => isAAP(v));
      const wantsAAP = !!aapVarName && ( (selectedVars.size === 0) || Array.from(selectedVars).includes(aapVarName) );
      seriesPower = null;

      if (wantsAAP && powerContainer && powerCanvas) {
        const pctx = powerCanvas.getContext('2d');
        const prect = powerCanvas.getBoundingClientRect();
        powerCanvas.width = prect.width * dpr;
        powerCanvas.height = prect.height * dpr;
        pctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        pctx.clearRect(0, 0, prect.width, prect.height);

        const Pleft = 60, Pright = 20, Ptop = 20, Pbottom = 40;
        const Pw = prect.width - Pleft - Pright;
        const Ph = prect.height - Ptop - Pbottom;
        const PxStep = Pw / Math.max(1, (dates.length - 1));

        let sp = {};
        const explicitTurbs2 = Array.from(selectedTurbines);
        if (explicitTurbs2.length === 1) {
          const dev = explicitTurbs2[0];
          const vals = dates.map(d => {
            const row = displayData.find(r => r['Date'] === d && r['Device'] === dev);
            const v = row ? parseFloat(row[aapVarName]) : null;
            return isFinite(v) ? v : null;
          });
          sp[`${dev} ‚Ä¢ ${aapVarName}`] = { device: dev, var: aapVarName, values: vals, color: '#d62728' };
        } else {
          const devices = Array.from(new Set(displayData.map(r => r['Device'])));
          devices.forEach((dev, i) => {
            const vals = dates.map(d => {
              const row = displayData.find(r => r['Date'] === d && r['Device'] === dev);
              const v = row ? parseFloat(row[aapVarName]) : null;
              return isFinite(v) ? v : null;
            });
            sp[`${dev} ‚Ä¢ ${aapVarName}`] = { device: dev, var: aapVarName, values: vals, color: darkColor(i, devices.length) };
          });
        }
        // === Theoretical from Average Wind Speed using embedded power curve ===
        (function addTheoreticalSeries(){
          const windVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average wind speed'));
          if (!windVarName || !(window.POWER_CURVE && window.POWER_CURVE.length)) return;
          const __expTurbs = (typeof explicitTurbs2 !== 'undefined' && explicitTurbs2 && explicitTurbs2.length ? explicitTurbs2
                               : (typeof explicitTurbs !== 'undefined' ? explicitTurbs : []));
          if (__expTurbs.length === 1) {
            const dev2 = __expTurbs[0];
            const tempVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average ambient temperature'));
            const valsTh = dates.map(d => {
              const row = displayData.find(r => r['Date'] === d && r['Device'] === dev2);
              const ws  = row ? parseFloat(row[windVarName]) : NaN;
              const tC  = row && tempVarName ? parseFloat(row[tempVarName]) : NaN;
              const th  = Number.isFinite(ws) ? window.expectedPowerKWFromWSTemp(ws, tC) : NaN;
              return Number.isFinite(th) ? th : null;
            });
            sp[`${dev2} ‚Ä¢ Theoretical Power (from WS)`] = { device: dev2, var: 'Theoretical Power (kW)', values: valsTh, color: '#006400', dashed: true, thick: true };
          } else {
            const devices2 = Array.from(new Set(displayData.map(r => r['Device'])));
            devices2.forEach((dev2, i2) => {
              const tempVarName = (variableNames || []).find(v => String(v).toLowerCase().includes('average ambient temperature'));
              const valsTh = dates.map(d => {
                const row = displayData.find(r => r['Date'] === d && r['Device'] === dev2);
                const ws  = row ? parseFloat(row[windVarName]) : NaN;
                const tC  = row && tempVarName ? parseFloat(row[tempVarName]) : NaN;
                const th  = Number.isFinite(ws) ? window.expectedPowerKWFromWSTemp(ws, tC) : NaN;
                return Number.isFinite(th) ? th : null;
              });
              sp[`${dev2} ‚Ä¢ Theoretical Power (from WS)`] = { device: dev2, var: 'Theoretical Power (kW)', values: valsTh, color: '#006400', dashed: true, thick: true };
            });
          }
        })();
        seriesPower = sp;
        const rngP = computeYRange(sp);
        const PyMin = rngP.yMin, PyMax = rngP.yMax;

        pctx.strokeStyle = '#111'; pctx.lineWidth = 1;
        pctx.beginPath();
        pctx.moveTo(Pleft, Ptop); pctx.lineTo(Pleft, Ptop + Ph);
        pctx.moveTo(Pleft, Ptop + Ph); pctx.lineTo(Pleft + Pw, Ptop + Ph);
        pctx.stroke(); pctx.setLineDash([]);

        pctx.font = '12px Arial';
        for (let i = 0; i <= 5; i++) {
          const t = i / 5;
          const y = Ptop + Ph - t * Ph;
          const val = (PyMin + t * (PyMax - PyMin)).toFixed(2);
          pctx.fillStyle = '#222';
          pctx.textAlign = 'right'; pctx.textBaseline = 'middle';
          pctx.fillText(val, Pleft - 6, y);
          pctx.strokeStyle = 'rgba(0,0,0,0.08)';
          pctx.beginPath(); pctx.moveTo(Pleft, y); pctx.lineTo(Pleft + Pw, y); pctx.stroke(); pctx.setLineDash([]);
        }

        pctx.fillStyle = '#222'; pctx.textAlign = 'center'; pctx.textBaseline = 'top';
        for (let i = 0; i < dates.length; i += Math.ceil(dates.length / 8)) {
          const x = Pleft + i * PxStep;
          const label = dates[i].split(' ')[1];
          pctx.fillText(label, x, Ptop + Ph + 6);
        }

        Object.values(sp).forEach(s => {
          pctx.strokeStyle = s.color; pctx.lineWidth = (s.thick?3:2); pctx.setLineDash(s.dashed ? [8,4] : []); pctx.beginPath();
          let started = false;
          s.values.forEach((v, idx) => {
            if (v == null) { started = false; return; }
            const x = Pleft + idx * PxStep;
            const y = Ptop + Ph - (v - PyMin) / (PyMax - PyMin) * Ph;
            if (!started) { pctx.moveTo(x, y); started = true; } else { pctx.lineTo(x, y); }
          });
          pctx.stroke(); pctx.setLineDash([]);
        });

        powerContainer.style.display = 'block';
        chartGeomPower = { baseCanvas: powerCanvas, leftPad: Pleft, topPad: Ptop, chartW: Pw, chartH: Ph, xStep: PxStep, yMin: PyMin, yMax: PyMax };
      } else {
        if (powerContainer) powerContainer.style.display = 'none';
        chartGeomPower = null;
        seriesPower = null;
      }


function buildTooltipHTML(series, idx) {
        if (!series || idx == null || !Array.isArray(series.values)) return '';
        const value = series.values[idx];
        const dateStr = (typeof currentDates !== 'undefined' && currentDates && currentDates[idx]) ? currentDates[idx] : '';
        const valText = (value == null || !isFinite(value)) ? '‚Äî' : String(Number(value.toFixed ? value.toFixed(3) : value));
        return `<div class="tooltip-card">
                  <div class="tt-body">
                    <div class="tt-row active">
                      <span class="tt-label">Variable</span>
                      <span class="tt-value">${series.var || series.label || ''}</span>
                    </div>
                    <div class="tt-row">
                      <span class="tt-label">Value</span>
                      <span class="tt-value">${valText}</span>
                    </div>
                    <div class="tt-row">
                      <span class="tt-label">Turbine</span>
                      <span class="tt-value">${series.device || ''}</span>
                    </div>
                    <div class="tt-row">
                      <span class="tt-label">Time</span>
                      <span class="tt-value">${dateStr}</span>
                    </div>
                  </div>
                </div>`;
}

      function nearestSeriesAt(src, geom, idx, my) {
        if (!src || !geom) return null;
        let best = null, bestDist = Infinity;
        Object.entries(src).forEach(([label, s]) => {
          const v = s.values[idx];
          if (v == null) return;
          const y = geom.topPad + geom.chartH - (v - geom.yMin) / (geom.yMax - geom.yMin) * geom.chartH;
          const d = Math.abs(y - my);
          if (d < bestDist) { bestDist = d; best = { label, series: s }; }
        });
        return best;
      }

      function handleMove(evt, which) {
const c = which === 'main' ? canvas : powerCanvas;
        const t = which === 'main' ? tooltip : powerTooltip;
        if (!c || !t) return;
        if (window.__isChartsFS) { t.style.position = 'fixed'; } else { t.style.position = 'absolute'; }
        if (window.__isChartsFS) { t.style.position = 'fixed'; t.style.zIndex = 10000; } else { t.style.position = 'absolute'; t.style.zIndex = ''; }
        const r = c.getBoundingClientRect();
        const mx = evt.clientX - r.left;
        const my = evt.clientY - r.top;
        const geom = which === 'main' ? chartGeomMain : chartGeomPower;
        if (!geom) return;

        const px = mx - geom.leftPad;
        const py = my - geom.topPad;

        if (px < 0 || px > geom.chartW || py < 0 || py > geom.chartH) {
            t.style.display = 'none';
            drawHairline(document.getElementById('chartOverlay'), chartGeomMain, null);
            drawHairline(document.getElementById('powerOverlay'), chartGeomPower, null);
            return;
        }

        const idx = Math.round(px / geom.xStep);

        drawHairline(document.getElementById('chartOverlay'), chartGeomMain, idx);
        drawHairline(document.getElementById('powerOverlay'), chartGeomPower, idx);

        // Map cursor Y to data value range so we can pick the closest series
        const vCursor = geom.yMax - (py / geom.chartH) * (geom.yMax - geom.yMin);

        const src = which === 'main' ? seriesMain : seriesPower;
        let best = null;
        let bestDist = Infinity;

        if (src) {
            Object.entries(src).forEach(([label, s]) => {
                const v = s.values ? s.values[idx] : undefined;
                if (v == null || !isFinite(v)) return;
                const d = Math.abs(v - vCursor);
                if (d < bestDist) { bestDist = d; best = Object.assign({ label }, s); }
            });
        }

        if (!best) {
            t.style.display = 'none';
            return;
        }

        window.selectedSeries = best;
        const html = buildTooltipHTML(best, idx);
        t.innerHTML = html;
        t.style.left = (evt.clientX + 10) + 'px';
        t.style.top  = (evt.clientY + 10) + 'px';
        t.style.display = 'block';
        if (window.__clampTooltip) window.__clampTooltip(t);
}

      function handleLeave() {
        if (tooltip) tooltip.style.display = 'none';
        if (powerTooltip) powerTooltip.style.display = 'none';
        const ov1 = document.getElementById('chartOverlay');
        const ov2 = document.getElementById('powerOverlay');
        if (ov1) { const c1 = ov1.getContext('2d'); c1 && c1.clearRect(0,0,ov1.width,ov1.height); }
        if (ov2) { const c2 = ov2.getContext('2d'); c2 && c2.clearRect(0,0,ov2.width,ov2.height); }
        drawHairline(document.getElementById('chartOverlay'), chartGeomMain, null);
        drawHairline(document.getElementById('powerOverlay'), chartGeomPower, null);
      }

      canvas.onmousemove = (e)=>handleMove(e,'main');
      canvas.onmouseleave = handleLeave;
      if (powerContainer && powerContainer.style.display !== 'none') {
        powerCanvas.onmousemove = (e)=>handleMove(e,'power');
        powerCanvas.onmouseleave = handleLeave;
      } else if (powerCanvas) {
        powerCanvas.onmousemove = null;
        powerCanvas.onmouseleave = null;
      }
    };
  })();
  </script>

  <script id="tooltip-portal">
  (function(){
    function moveToBody(id){
      var el = document.getElementById(id);
      if (el && el.parentElement !== document.body) {
        document.body.appendChild(el);
      }
      if (el){
        el.style.position = 'fixed';
        el.style.zIndex = '2147483647';
        el.style.pointerEvents = 'none';
      }
    }
    function clampTooltipToViewport(el){
      if (!el) return;
      const rect = el.getBoundingClientRect();
      let dx = 0, dy = 0;
      if (rect.right > window.innerWidth) dx = window.innerWidth - rect.right - 8;
      if (rect.bottom > window.innerHeight) dy = window.innerHeight - rect.bottom - 8;
      if (dx || dy){
        el.style.transform = `translate(${dx}px, ${dy}px)`;
      } else {
        el.style.transform = 'translate(0,0)';
      }
    }
    // Expose for other scripts to call after updating tooltip content/position
    window.__clampTooltip = clampTooltipToViewport;

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){
        moveToBody('chartTooltip');
        moveToBody('powerTooltip');
      });
    } else {
      moveToBody('chartTooltip');
      moveToBody('powerTooltip');
    }
  })();
  </script>

<script id="fullscreen-yzoom">
(function(){
  window.__yOverrideMain = null;
  window.__yOverridePower = null;
  window.__isChartsFS = false;
  window.__chartsOrigUpdate = null;
  let __restore = null;

    function bindHandlers(){
    const canvas = document.getElementById('chartCanvas');
    const overlay = document.getElementById('chartOverlay');
    const powerCanvas = document.getElementById('powerChartCanvas');
    const powerOverlay = document.getElementById('powerOverlay');

    if (canvas){
      canvas.addEventListener('wheel', (e)=>onWheelY('main', e), { passive: false });
      canvas.ondblclick = ()=>resetY('main');
    }
    if (overlay){
      overlay.addEventListener('wheel', (e)=>onWheelY('main', e), { passive: false });
      overlay.ondblclick = ()=>resetY('main');
      overlay.onmousemove = (e)=>handleMove(e,'main');
      overlay.onmouseleave = handleLeave;
    }
    if (powerCanvas){
      powerCanvas.addEventListener('wheel', (e)=>onWheelY('power', e), { passive: false });
      powerCanvas.ondblclick = ()=>resetY('power');
    }
    if (powerOverlay){
      powerOverlay.addEventListener('wheel', (e)=>onWheelY('power', e), { passive: false });
      powerOverlay.ondblclick = ()=>resetY('power');
      powerOverlay.onmousemove = (e)=>handleMove(e,'power');
      powerOverlay.onmouseleave = handleLeave;
    }
  }

  function onWheelY(which, evt){
    evt.preventDefault();
    const geom = (which === 'main') ? window.chartGeomMain : window.chartGeomPower;
    if (!geom) return;
    const c = (which === 'main') ? document.getElementById('chartCanvas') : document.getElementById('powerChartCanvas');
    if (!c) return;
    const r = c.getBoundingClientRect();
    const mx = evt.clientX - r.left;
    const my = evt.clientY - r.top;
    const px = mx - geom.leftPad;
    const py = my - geom.topPad;
    const range = (geom.yMax - geom.yMin) || 1;
    const factor = Math.exp(-evt.deltaY * 0.001);
    const vCursor = geom.yMax - (py / geom.chartH) * range;
    let newMin = vCursor - (vCursor - geom.yMin) / factor;
    let newMax = vCursor + (geom.yMax - vCursor) / factor;
    if (!isFinite(newMin) || !isFinite(newMax) || newMax - newMin < 1e-9) return;

    if (which === 'main') window.__yOverrideMain = {min: newMin, max: newMax};
    else window.__yOverridePower = {min: newMin, max: newMax};
    // call the original update to redraw using injected y-overrides
    if (window.__chartsOrigUpdate) window.__chartsOrigUpdate();
  }

  function resetY(which){
    if (which === 'main') window.__yOverrideMain = null; else window.__yOverridePower = null;
    if (window.__chartsOrigUpdate) window.__chartsOrigUpdate();
  }

        if (pcont){
        pcont.style.minHeight = '28vh';
        const pc = document.getElementById('powerChartCanvas');
        if (pc){ pc.style.width = '100%'; pc.style.height = '100%'; }
      }

      window.__isChartsFS = true;
      if (window.__chartsOrigUpdate) window.__chartsOrigUpdate();
      bindHandlers();
    } else {
      const overlay = document.getElementById('chartsFullscreenOverlay');
      if (__restore && __restore.contParent){
        __restore.contParent.insertBefore(cont, __restore.contNext);
      }
      if (__restore && pcont && __restore.pParent){
        __restore.pParent.insertBefore(pcont, __restore.pNext);
      }
      if (overlay) overlay.remove();

      cont.style.minHeight = '';
      const c = document.getElementById('chartCanvas');
      if (c){ c.style.width = ''; c.style.height = ''; }
      if (pcont){
        pcont.style.minHeight = '';
        const pc = document.getElementById('powerChartCanvas');
        if (pc){ pc.style.width = ''; pc.style.height = ''; }
      }

      window.__isChartsFS = false;
      if (window.__chartsOrigUpdate) window.__chartsOrigUpdate();
      bindHandlers();
    }
  }

  function hook(){
    if (!window.updateChart){ setTimeout(hook, 60); return; }
    if (window.__chartsOrigUpdate) return; // already hooked
    window.__chartsOrigUpdate = window.updateChart;
    window.updateChart = function(){
      window.__chartsOrigUpdate();
      ensureFSButton();
      bindHandlers();
    };
    // first-time setup
    ensureFSButton();
    bindHandlers();
  }

  document.addEventListener('DOMContentLoaded', hook);
  window.addEventListener('load', hook);
})();
</script>



<script id="fs-patch-script">
(function(){
  function getVisibleContainer(){
    var c = document.getElementById('chartContainer');
    var p = document.getElementById('powerChartContainer');
    var vis = function(el){
      if (!el) return false;
      var cs = window.getComputedStyle(el);
      if (!cs) return el.offsetParent !== null;
      return cs.display !== 'none' && cs.visibility !== 'hidden' && el.offsetParent !== null;
    };
    return vis(c) ? c : (vis(p) ? p : (p || c));
  }

  window.toggleFullscreenCharts = function(){
    var target = getVisibleContainer();
    if (!target) return;

    if (!document.body.__fsOn){
      var overlay = document.createElement('div');
      overlay.id = 'chartsFullscreenLayer';
      overlay.addEventListener('click', function(e){ if (e.target === overlay) exitFS(); });
      overlay.__onEsc = function(ev){ if ((ev.key||'') === 'Escape') exitFS(); };
      document.addEventListener('keydown', overlay.__onEsc);
      document.body.appendChild(overlay);

      document.body.__fsOn = {
        target: target,
        parent: target.parentNode,
        next: target.nextSibling,
        minHeight: target.style.minHeight
      };

      overlay.appendChild(target);
      target.style.minHeight = '68vh';

      var canvas = target.querySelector('canvas');
      if (canvas){
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.maxHeight = 'none';
      }

      try{ if (typeof window.updateChart==='function') window.updateChart(); }catch(e){}
      ensureFSButton();
    } else {
      exitFS();
    }

    function exitFS(){
      var st = document.body.__fsOn || {};
      var overlay = document.getElementById('chartsFullscreenLayer');
      if (st.target && st.parent){
        if (st.next) st.parent.insertBefore(st.target, st.next); else st.parent.appendChild(st.target);
        st.target.style.minHeight = st.minHeight || '';
        var canvas = st.target.querySelector('canvas');
        if (canvas){ canvas.style.width = ''; canvas.style.height = ''; }
      }
      if (overlay){
        try { document.removeEventListener('keydown', overlay.__onEsc); } catch(e) {}
        overlay.remove();
      }
      document.body.__fsOn = null;
      try{ if (typeof window.updateChart==='function') window.updateChart(); }catch(e){}
      ensureFSButton();
    }
  };

  window.ensureFSButton = function(){
    var target = getVisibleContainer();
    if (!target) return;
    if (window.getComputedStyle(target).position === 'static') target.style.position = 'relative';

    var btn = document.getElementById('btnToggleFullscreenCharts');
    if (!btn){
      btn = document.createElement('button');
      btn.id = 'btnToggleFullscreenCharts';
      btn.type = 'button';
      btn.title = 'Fullscreen / Exit';
      btn.textContent = '‚§¢';
      btn.addEventListener('click', window.toggleFullscreenCharts);
    }
    if (btn.parentNode !== target) target.appendChild(btn);
  };

  function initFS(){
    ensureFSButton();
    var c1 = document.getElementById('chartContainer');
    var c2 = document.getElementById('powerChartContainer');
    var watch = function(el){
      if(!el || el.__fsObs) return;
      var obs = new MutationObserver(ensureFSButton);
      obs.observe(el, {childList:true, subtree:true, attributes:true, attributeFilter:['style','class']});
      el.__fsObs = obs;
    };
    watch(c1); watch(c2);
    window.addEventListener('resize', ensureFSButton);
    document.addEventListener('keydown', function(e){ if ((e.key||'').toLowerCase()==='f') window.toggleFullscreenCharts(); });
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive'){
    setTimeout(initFS, 0);
  } else {
    document.addEventListener('DOMContentLoaded', initFS);
    window.addEventListener('load', initFS);
  }
})();
</script>

<script>
/* === Hook Download PDF -> optimized print === */
(function(){
  if (window.__pdf_better__) return; window.__pdf_better__ = true;

  function beforePrint(){
    document.body.classList.add('print-landscape');
  }
  function afterPrint(){
    document.body.classList.remove('print-landscape');
  }

  // Clean up after print in all browsers
  window.addEventListener('afterprint', afterPrint);
  if (window.matchMedia) {
    const mq = window.matchMedia('print');
    try{ mq.addEventListener('change', e => { if(!e.matches) afterPrint(); }); }catch(_){}
  }

  function hook(el){
    if (!el) return;
    el.addEventListener('click', function(ev){
      ev.preventDefault();
      try { beforePrint(); } catch(_){}
      window.print();
    });
  }

  // Known button id in this file
  hook(document.getElementById('btnDownloadPDF'));

  // Fallback: delegate by text
  document.addEventListener('click', function(e){
    const a = e.target.closest('button,a');
    if (!a) return;
    const txt = (a.textContent||'').trim().toLowerCase();
    if (txt.includes('download pdf') || txt === 'pdf'){
      e.preventDefault();
      try { beforePrint(); } catch(_){}
      window.print();
    }
  }, true);
})();
</script>
<script>
/* === No-cancel-download guard for PDF === */
(function(){
  if (window.__pdf_cancel_guard__) return; window.__pdf_cancel_guard__ = true;

  // Global switch: we fully replace "download PDF" with print preview.
  // Block programmatic PDF downloads (blob:/application/pdf) while this guard is active.
  var BLOCK_PDF_DOWNLOADS = true;

  // Monkey-patch anchor.click to block blob/pdf while guard is on
  (function(){
    var _orig = HTMLAnchorElement.prototype.click;
    HTMLAnchorElement.prototype.click = function(){
      try{
        if (BLOCK_PDF_DOWNLOADS){
          var href = this.getAttribute('href') || '';
          var dl   = (this.getAttribute('download')||'').toLowerCase();
          var type = (this.getAttribute('type')||'').toLowerCase();
          var isPDF = href.endsWith('.pdf') || href.startsWith('blob:') || dl.includes('pdf') || type.includes('pdf');
          if (isPDF) { return; } // swallow click
        }
      }catch(_){}
      return _orig.apply(this, arguments);
    };
  })();

  // Capture-phase click: stop other handlers for "Download PDF" elements
  function isPdfTrigger(el){
    if(!el) return false;
    if (el.id === 'btnDownloadPDF') return true;
    var t = (el.textContent||'').trim().toLowerCase();
    if (t.includes('download pdf') || t === 'pdf') return true;
    if (el.matches('[data-action="download-pdf"],[data-export="pdf"],[data-pdf]')) return true;
    if (el.tagName === 'A'){
      var href = el.getAttribute('href')||'';
      if (href.endsWith('.pdf') || href.startsWith('blob:')) return true;
    }
    return false;
  }

  function triggerPrint(e, el){
    e.preventDefault();
    e.stopPropagation();
    if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    // Neutralize attributes so nothing fires
    if (el && el.tagName === 'A'){
      el.dataset._oldHref = el.getAttribute('href') || '';
      el.dataset._oldDownload = el.getAttribute('download') || '';
      el.removeAttribute('href'); el.removeAttribute('download');
      setTimeout(function(){ // restore later (in case user tries again)
        if (el && el.dataset){
          if (el.dataset._oldHref) el.setAttribute('href', el.dataset._oldHref);
          if (el.dataset._oldDownload) el.setAttribute('download', el.dataset._oldDownload);
        }
      }, 1000);
    }
    window.print();
  }

  document.addEventListener('click', function(e){
    var el = e.target.closest('a,button'); if (!el) return;
    if (!isPdfTrigger(el)) return;
    triggerPrint(e, el);
  }, true); // capture to beat existing handlers
})();
</script>
<script>
/* === Single-print guard: prevent double print dialogs after Cancel === */
(function(){
  if (window.__pdf_single_guard__) return; window.__pdf_single_guard__ = true;

  var printing = false;
  var resetTimer = null;

  function isPdfTrigger(el){
    if(!el) return false;
    if (el.id === 'btnDownloadPDF') return true;
    var t = (el.textContent||'').trim().toLowerCase();
    if (t.includes('download pdf') || t === 'pdf') return true;
    if (el.matches && el.matches('[data-action="download-pdf"],[data-export="pdf"],[data-pdf]')) return true;
    if (el.tagName === 'A'){
      var href = el.getAttribute('href')||'';
      if (href.endsWith('.pdf') || href.startsWith('blob:')) return true;
    }
    return false;
  }

  function resetPrintingFlag(){
    printing = false;
    if (resetTimer){ clearTimeout(resetTimer); resetTimer = null; }
  }

  // Wrap native window.print so even external calls cannot open twice
  var _origPrint = window.print;
  window.print = function(){
    if (printing) return;
    printing = true;
    try{
      return _origPrint.call(window);
    } finally {
      // Fallback: if 'afterprint' doesn't fire (some browsers), auto-reset after 5s
      if (resetTimer) clearTimeout(resetTimer);
      resetTimer = setTimeout(resetPrintingFlag, 5000);
    }
  };

  // When print dialog closes (OK or Cancel), allow future prints again
  window.addEventListener('afterprint', resetPrintingFlag);
  if (window.matchMedia){
    try{
      var mq = window.matchMedia('print');
      mq.addEventListener('change', function(e){ if (!e.matches) resetPrintingFlag(); });
    }catch(_){}
  }

  // Intercept clicks on any "PDF" triggers and ensure single-fire
  document.addEventListener('click', function(e){
    var el = e.target && e.target.closest && e.target.closest('a,button');
    if (!el || !isPdfTrigger(el)) return;
    // Neutralize any inline onclick/href that might also call print/download
    if (el.hasAttribute('onclick')) { el.dataset._oldOnclick = el.getAttribute('onclick'); el.setAttribute('onclick','return false;'); }
    if (el.tagName === 'A'){
      el.dataset._oldHref = el.getAttribute('href')||'';
      el.removeAttribute('href');
      // restore later just in case
      setTimeout(function(){
        if (el.dataset._oldHref) el.setAttribute('href', el.dataset._oldHref);
        if (el.dataset._oldOnclick){ el.setAttribute('onclick', el.dataset._oldOnclick); el.removeAttribute('data-_oldOnclick'); }
      }, 1000);
    }
    e.preventDefault();
    e.stopPropagation();
    if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    window.print(); // will honor the guard
  }, true); // capture
})();
</script>
<script>
/* === Robust single-print + cooldown (prevents second dialog after Cancel) === */
(function(){
  if (window.__pdf_cooldown_guard__) return; window.__pdf_cooldown_guard__ = true;

  var printing = false;
  var cooldownUntil = 0;

  function now(){ return Date.now(); }
  function inCooldown(){ return now() < cooldownUntil; }
  function startCooldown(ms){ cooldownUntil = now() + (ms||1500); }

  // Wrap native window.print
  var _origPrint = window.print;
  window.print = function(){
    if (printing || inCooldown()) return;
    printing = true;
    try {
      return _origPrint.call(window);
    } finally {
      // Safety: if no afterprint, enforce cooldown anyway
      startCooldown(2000);
      setTimeout(function(){ printing = false; }, 0);
    }
  };

  // When dialog closes (OK/Cancel), activate cooldown window to swallow stray calls
  function endPrintSession(){
    printing = false;
    startCooldown(2000); // block any immediate re-open
  }
  window.addEventListener('afterprint', endPrintSession);
  if (window.matchMedia){
    try{
      var mq = window.matchMedia('print');
      mq.addEventListener('change', function(e){ if (!e.matches) endPrintSession(); });
    }catch(_){}
  }

  // Absolute last line of defense: prevent late asynchronous re-triggers
  // by temporarily removing any click handlers on the PDF control while printing.
  document.addEventListener('click', function(e){
    var el = e.target && e.target.closest && e.target.closest('a,button');
    if (!el) return;
    var txt = (el.textContent||'').toLowerCase();
    var isPDF = el.id==='btnDownloadPDF' || txt.includes('download pdf') || txt.trim()==='pdf' ||
                (el.matches && el.matches('[data-action="download-pdf"],[data-export="pdf"],[data-pdf]'));
    if (!isPDF) return;
    // Capture phase: if we've just ended a print (cooldown active), swallow everything.
    if (printing || inCooldown()){
      e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      return;
    }
  }, true);
})();
</script>
<script>
/* === Apply red highlight when a variable exceeds its limit === */
(function(){
  if (window.__limits_cf__) return; window.__limits_cf__ = true;

  // Map of header label -> limit (Celsius)
  // Matching is case-insensitive and tolerant to minor variations.
  const LIMITS = [
    {match:/\bBearing\s+D\.?E\.?\s+Temperature\b.*10M/i, limit:95},
    {match:/\bBearing\s+N\.?D\.?E\.?\s+Temperature\b.*10M/i, limit:95},
    {match:/\bGearbox\b.*bearing temperature\b.*10M/i, limit:88},
    {match:/\bGearbox\b.*oil temperature\b.*10M/i, limit:75},
    {match:/\bGenerator\b.*windings temperature\s*1\b.*10M/i, limit:150},
    {match:/\bGenerator\b.*windings temperature\s*2\b.*10M/i, limit:150},
    {match:/\bGenerator\b.*windings temperature\s*3\b.*10M/i, limit:150},
    {match:/\bGenerator\b.*sliprings temperature\b.*10M/i, limit:75},
    {match:/\bTrafo\s*1\b.*winding temperature\b.*10M/i, limit:140},
    {match:/\bTrafo\s*2\b.*winding temperature\b.*10M/i, limit:140},
    {match:/\bTrafo\s*3\b.*winding temperature\b.*10M/i, limit:140},
  ];

  function toNumber(v){
    if (v==null) return NaN;
    let s = String(v).trim().replace(/\u00a0/g,'').replace(/\s+/g,' ');
    // Replace comma decimal if present
    if ((s.match(/,/g)||[]).length > (s.match(/\./g)||[]).length) {
      s = s.replace(/\./g,'').replace(/,/g,'.');
    } else {
      s = s.replace(/,/g,'');
    }
    const n = Number(s);
    return isFinite(n) ? n : NaN;
  }

  function buildColumnMap(table){
    const map = {}; // colIndex -> {limit}
    const ths = (table.tHead && table.tHead.rows[0]) ? Array.from(table.tHead.rows[0].cells) : [];
    ths.forEach((th, i) => {
      const label = (th.textContent||'').trim();
      for (const r of LIMITS){
        if (r.match.test(label)){
          map[i] = {limit: r.limit, label};
          break;
        }
      }
    });
    return map;
  }

  function applyLimits(table){
    if (!table) return;
    const colMap = buildColumnMap(table);
    if (!Object.keys(colMap).length) return; // nothing to do

    const bodies = table.tBodies ? Array.from(table.tBodies) : [];
    bodies.forEach(tb => {
      Array.from(tb.rows).forEach(tr => {
        Array.from(tr.cells).forEach((td, i) => {
          const rule = colMap[i];
          if (!rule) return;
          const val = toNumber(td.textContent);
          if (isNaN(val)) return;
          // mark near-limit if >90% of limit, over-limit if >limit
          td.classList.remove('over-limit','near-limit');
          if (val > rule.limit) td.classList.add('over-limit');
          else if (val >= rule.limit*0.9) td.classList.add('near-limit');
        });
      });
    });
  }

  function run(){
    const tbl = document.getElementById('dataTable') || document.querySelector('table');
    applyLimits(tbl);
  }

  // Hook into buildTable if present
  const _bt = window.buildTable;
  if (typeof _bt === 'function'){
    window.buildTable = function(){ const r=_bt.apply(this, arguments); run(); return r; };
  }
  window.addEventListener('DOMContentLoaded', run);
  window.addEventListener('load', run);
})();
</script>
<script>
/* === Build "Exceedances" table ignoring Aggregation Interval filter when possible === */
(function(){
  if (window.__exceed_table__) return; window.__exceed_table__ = true;

  // reuse LIMITS from previous script if present; otherwise define here too
  var LIMITS = (window.__LIMITS_MAP__) || [
    {match:/\bBearing\s+D\.?E\.?\s+Temperature\b.*10M/i, limit:95, key:'Bearing D.E. Temperature max 10M (¬∫C)'},
    {match:/\bBearing\s+N\.?D\.?E\.?\s+Temperature\b.*10M/i, limit:95, key:'Bearing N.D.E. Temperature max 10M (¬∫C)'},
    {match:/\bGearbox\b.*bearing temperature\b.*10M/i, limit:88, key:'Gearbox bearing temperature max 10M (¬∫C)'},
    {match:/\bGearbox\b.*oil temperature\b.*10M/i, limit:75, key:'Gearbox oil temperature max 10M (¬∫C)'},
    {match:/\bGenerator\b.*windings temperature\s*1\b.*10M/i, limit:150, key:'Generator windings temperature 1 max 10M (¬∫C)'},
    {match:/\bGenerator\b.*windings temperature\s*2\b.*10M/i, limit:150, key:'Generator windings temperature 2 max 10M (¬∫C)'},
    {match:/\bGenerator\b.*windings temperature\s*3\b.*10M/i, limit:150, key:'Generator windings temperature 3 max 10M (¬∫C)'},
    {match:/\bGenerator\b.*sliprings temperature\b.*10M/i, limit:75, key:'Generator‚Äôs sliprings temperature max 10M (¬∫C)'},
    {match:/\bTrafo\s*1\b.*winding temperature\b.*10M/i, limit:140, key:'Trafo 1 winding temperature max 10M (¬∫C)'},
    {match:/\bTrafo\s*2\b.*winding temperature\b.*10M/i, limit:140, key:'Trafo 2 winding temperature max 10M (¬∫C)'},
    {match:/\bTrafo\s*3\b.*winding temperature\b.*10M/i, limit:140, key:'Trafo 3 winding temperature max 10M (¬∫C)'},
  ];
  window.__LIMITS_MAP__ = LIMITS;

  function toNumber(v){
    if (v==null) return NaN;
    var s = String(v).trim().replace(/\u00a0/g,'').replace(/\s+/g,' ');
    if ((s.match(/,/g)||[]).length > (s.match(/\./g)||[]).length) { s = s.replace(/\./g,'').replace(/,/g,'.'); }
    else { s = s.replace(/,/g,''); }
    var n = Number(s); return isFinite(n)?n:NaN;
  }

  function guessFullDataset(){
    // Try common globals from the app
    var candidates = ['fullData','allData','rawData','originalData','masterData','dataset','data','_allRows','__all'];
    for (var i=0;i<candidates.length;i++){
      var g = window[candidates[i]];
      if (Array.isArray(g) && g.length && typeof g[0]==='object') return g;
    }
    return null;
  }

  function buildColumnIndexFromHead(table){
    var map = {}; // label(normalized) -> index
    if (!table || !table.tHead) return map;
    var ths = table.tHead.rows[0] ? Array.from(table.tHead.rows[0].cells) : [];
    ths.forEach(function(th,i){ map[(th.textContent||'').trim()] = i; });
    return map;
  }

  function findColumnByRegex(headMap, regex){
    for (var label in headMap){
      if (regex.test(label)) return headMap[label];
    }
    return -1;
  }

  function computeExceedsFromDOM(table){
    var out = [];
    if (!table) return out;
    var headMap = buildColumnIndexFromHead(table);
    var dateIdx = findColumnByRegex(headMap, /\bDate\b/i);
    var devIdx  = findColumnByRegex(headMap, /\bDevice\b|\bWTG\b|\bWTG Tag\b/i);
    var body = table.tBodies[0];
    if (!body) return out;
    var colRules = Object.keys(headMap).map(function(label){
      var rule = null; for (var i=0;i<LIMITS.length;i++){ if (LIMITS[i].match.test(label)) { rule = LIMITS[i]; break; } }
      return {idx: headMap[label], label: label, rule: rule};
    }).filter(function(x){ return x.rule; });

    Array.from(body.rows).forEach(function(tr){
      var date = (tr.cells[dateIdx] && tr.cells[dateIdx].textContent.trim()) || '';
      var dev  = (tr.cells[devIdx] && tr.cells[devIdx].textContent.trim()) || '';
      colRules.forEach(function(cr){
        var td = tr.cells[cr.idx]; if (!td) return;
        var val = toNumber(td.textContent);
        if (!isNaN(val) && val > cr.rule.limit){
          out.push({device: dev, variable: cr.label, date: date, value: val, limit: cr.rule.limit});
        }
      });
    });
    return out;
  }

  function computeExceedsFromObjects(rows){
    var out = [];
    if (!rows || !rows.length) return out;
    // Try to map keys by regex
    var sample = rows[0];
    function keyBy(re){ for (var k in sample){ if (re.test(k)) return k; } return null; }
    var kDate = keyBy(/\bDate\b/i);
    var kDev  = keyBy(/\bDevice\b|\bWTG\b|\bWTG Tag\b/i);
    var keysWithRules = [];
    LIMITS.forEach(function(r){
      var k = keyBy(r.match);
      if (k) keysWithRules.push({key:k, rule:r});
    });
    if (!kDate || !kDev || !keysWithRules.length) return out;
    rows.forEach(function(row){
      var date = row[kDate], dev = row[kDev];
      keysWithRules.forEach(function(kr){
        var val = toNumber(row[kr.key]);
        if (!isNaN(val) && val > kr.rule.limit){
          out.push({device: dev, variable: kr.key, date: date, value: val, limit: kr.rule.limit});
        }
      });
    });
    return out;
  }

  function renderTable(exceeds){
    var wrap = document.getElementById('exceedWrap');
    if (!wrap){
      wrap = document.createElement('section');
      wrap.id = 'exceedWrap';
      wrap.innerHTML = '<header><h3>Exceedances analysis (ignore Aggregation Interval)</h3><div class="actions"><button id="exceedCsvBtn">Download CSV</button></div></header><div class="inner"></div>';
      // Append at the bottom of main content:
      (document.getElementById('main') || document.body).appendChild(wrap);
    }
    var inner = wrap.querySelector('.inner');
    if (!exceeds.length){ inner.innerHTML = '<div class="empty">No exceedances found.</div>'; return; }
    var html = ['<div style="max-height:340px; overflow:auto;"><table id="exceedTable"><thead><tr><th>Device</th><th>Variable</th><th>Date & Time</th><th style="text-align:right">Value</th><th style="text-align:right">Limit</th></tr></thead><tbody>'];
    exceeds.forEach(function(x){
      html.push('<tr><td>'+escapeHtml(String(x.device||''))+'</td><td>'+escapeHtml(String(x.variable||''))+'</td><td>'+escapeHtml(String(x.date||''))+'</td><td class="v">'+String(x.value)+'</td><td class="v">'+String(x.limit)+'</td></tr>');
    });
    html.push('</tbody></table></div>');
    inner.innerHTML = html.join('');
    // CSV download
    var btn = document.getElementById('exceedCsvBtn');
    if (btn){
      btn.onclick = function(){
        var rows = [['Device','Variable','Date & Time','Value','Limit']].concat(exceeds.map(function(x){ return [x.device, x.variable, x.date, x.value, x.limit]; }));
        var csv = rows.map(r=> r.map(f=> `"${String(f).replace(/"/g,'""')}"`).join(',')).join('\n');
        var blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a'); a.href = url; a.download = 'exceedances.csv'; a.click();
        setTimeout(function(){ URL.revokeObjectURL(url); }, 0);
      };
    }
  }

  function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  function run(){
    var table = document.getElementById('dataTable') || document.querySelector('table');
    var full = guessFullDataset();
    var exceeds = full ? computeExceedsFromObjects(full) : computeExceedsFromDOM(table);
    renderTable(exceeds);
  }

  // Hook after table builds and at load
  var _bt = window.buildTable;
  if (typeof _bt === 'function'){
    window.buildTable = function(){ var r=_bt.apply(this, arguments); run(); return r; };
  }
  window.addEventListener('DOMContentLoaded', run);
  window.addEventListener('load', run);
})();
</script>

<script id="exceed-refresh-logic">
(function(){
  if (window.__exceed_refresh_logic__) return; window.__exceed_refresh_logic__ = true;

  // Read red cells first; fallback to full dataset if available; else parse visible DOM.
  function getTable(){ return document.getElementById('dataTable') || document.querySelector('table'); }
  function headerLabels(tbl){ if (!tbl || !tbl.tHead || !tbl.tHead.rows[0]) return []; return Array.from(tbl.tHead.rows[0].cells).map(th => (th.textContent||'').trim()); }
  function idxBy(labels, re){ for (let i=0;i<labels.length;i++){ if (re.test(labels[i])) return i; } return -1; }
  function toNumber(s){ if(s==null) return NaN; s=String(s).trim(); if(!s) return NaN; const c=(s.match(/,/g)||[]).length, d=(s.match(/\./g)||[]).length; if(c>d) s=s.replace(/\./g,'').replace(/,/g,'.'); else s=s.replace(/,/g,''); const n=Number(s); return isFinite(n)?n:NaN; }
  function ensureWrap(){
    let wrap = document.getElementById('exceedWrap');
    if (!wrap){
      wrap = document.createElement('section');
      wrap.id = 'exceedWrap';
      wrap.innerHTML = '<header><h3>Exceedances analysis</h3><div class="actions"><button id="exceedRefreshBtn">Refresh</button><button id="exceedCsvBtn">Download CSV</button></div></header><div class="inner"><div class="empty">No exceedances yet.</div></div>';
      (document.getElementById('main') || document.body).appendChild(wrap);
    }
    return wrap;
  }
  function render(rows){
    const wrap = ensureWrap();
    const inner = wrap.querySelector('.inner');
    if (!rows || !rows.length){ inner.innerHTML = '<div class="empty">No exceedances found.</div>'; return; }
    const html = ['<div style="max-height:340px; overflow:auto;"><table id="exceedTable"><thead><tr><th>Device</th><th>Variable</th><th>Date & Time</th><th style="text-align:right">Value</th><th style="text-align:right">Limit</th></tr></thead><tbody>'];
    rows.forEach(r => html.push(`<tr><td>${escapeHtml(r.device||'')}</td><td>${escapeHtml(r.variable||'')}</td><td>${escapeHtml(r.date||'')}</td><td class="v">${r.value}</td><td class="v">${r.limit||''}</td></tr>`));
    html.push('</tbody></table></div>');
    inner.innerHTML = html.join('');

    // CSV
    const btn = document.getElementById('exceedCsvBtn');
    if (btn){
      btn.onclick = function(){
        const rowsCSV = [['Device','Variable','Date & Time','Value','Limit']].concat(rows.map(r=>[r.device,r.variable,r.date,r.value,r.limit||'']));
        const csv = rowsCSV.map(a => a.map(x => `"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='exceedances.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),0);
      };
    }
  }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  function collectFromRed(){
    const tbl = getTable(); if (!tbl) return [];
    const labels = headerLabels(tbl);
    const dateIdx = idxBy(labels, /\bDate\b|Timestamp/i);
    const devIdx  = idxBy(labels, /\bDevice\b|\bWTG\b|\bWTG Tag\b|WTG\s*ID/i);
    const bodies = [];
    if (tbl.tBodies && tbl.tBodies[0]) bodies.push(tbl.tBodies[0]);
    const inner = document.querySelector('.x-virtual-tbody table tbody');
    if (inner) bodies.push(inner);
    const out = [];
    bodies.forEach(body => {
      Array.from(body.querySelectorAll('td.over-limit')).forEach(td => {
        const tr = td.parentElement;
        const idx = Array.prototype.indexOf.call(tr.children, td);
        const variable = labels[idx] || ('Column ' + (idx+1));
        const val = toNumber(td.textContent);
        const device = (devIdx>=0 && tr.children[devIdx]) ? tr.children[devIdx].textContent.trim() : '';
        const date   = (dateIdx>=0 && tr.children[dateIdx]) ? tr.children[dateIdx].textContent.trim()   : '';
        const limit  = td.getAttribute('data-limit') || '';
        out.push({device, variable, date, value: val, limit});
      });
    });
    // dedupe
    const seen = new Set(), uniq=[];
    out.forEach(r => { const k = [r.device,r.variable,r.date,r.value].join('|'); if(!seen.has(k)){ seen.add(k); uniq.push(r);} });
    return uniq;
  }

  function collectFromFull(){
    // Try full data arrays if available
    const names = ['fullData','allData','rawData','originalData','masterData','dataset','data','_allRows','__all','rows'];
    let ds=null;
    for (let n of names){ if (Array.isArray(window[n]) && window[n].length){ ds=window[n]; break; } }
    if (!ds) return [];
    // Build indexes from header labels
    const tbl = getTable(); const labels = headerLabels(tbl);
    function findLabel(re){ for (let i=0;i<labels.length;i++){ if (re.test(labels[i])) return labels[i]; } return null; }
    const kDate = findLabel(/\bDate\b|Timestamp/i);
    const kDev  = findLabel(/\bDevice\b|\bWTG\b|\bWTG Tag\b|WTG\s*ID/i);
    // Limits mapping based on given picture
    const rules = [
      {re:/Bearing\s+D\.?E\.?\s+Temperature.*10M/i, limit:95},
      {re:/Bearing\s+N\.?D\.?E\.?\s+Temperature.*10M/i, limit:95},
      {re:/Gearbox.*bearing temperature.*10M/i, limit:88},
      {re:/Gearbox.*oil temperature.*10M/i, limit:75},
      {re:/Generator.*windings temperature\s*1.*10M/i, limit:150},
      {re:/Generator.*windings temperature\s*2.*10M/i, limit:150},
      {re:/Generator.*windings temperature\s*3.*10M/i, limit:150},
      {re:/Generator.*sliprings temperature.*10M/i, limit:75},
      {re:/Trafo\s*1.*winding temperature.*10M/i, limit:140},
      {re:/Trafo\s*2.*winding temperature.*10M/i, limit:140},
      {re:/Trafo\s*3.*winding temperature.*10M/i, limit:140},
    ];
    const keyRules = [];
    const sample = ds[0] || {};
    for (let r of rules){
      // find a matching key in data object OR label that matches and exists in row
      let k = null;
      for (let key in sample){ if (r.re.test(key)) { k = key; break; } }
      if (!k){
        // fallback: try label text
        const lab = labels.find(l => r.re.test(l));
        if (lab && lab in sample) k = lab;
      }
      if (k) keyRules.push({key:k, limit:r.limit, label:k});
    }
    if (!kDate || !kDev || !keyRules.length) return [];
    const out = [];
    ds.forEach(row => {
      keyRules.forEach(v => {
        const val = toNumber(row[v.key]);
        if (!isNaN(val) && val > v.limit){
          out.push({device: String(row[kDev]||''), variable: v.label, date: String(row[kDate]||''), value: val, limit: v.limit});
        }
      });
    });
    // dedupe
    const seen = new Set(), uniq=[];
    out.forEach(r => { const k = [r.device,r.variable,r.date,r.value].join('|'); if(!seen.has(k)){ seen.add(k); uniq.push(r);} });
    return uniq;
  }

  function buildExceedances(){
    // Prefer red cells (guaranteed after limits pass ran); fallback to full dataset
    let rows = collectFromRed();
    if (!rows.length){ rows = collectFromFull(); }
    render(rows);
  }

  // Wire the button
  function wire(){
    ensureWrap();
    const btn = document.getElementById('exceedRefreshBtn');
    if (btn && !btn.__wired){
      btn.__wired = true;
      btn.addEventListener('click', buildExceedances);
    }
  }
  document.addEventListener('DOMContentLoaded', wire);
  window.addEventListener('load', function(){ wire(); setTimeout(buildExceedances, 0); });

  // Auto after CSV file chosen
  document.addEventListener('change', function(e){
    const el = e.target; if (!el || el.tagName!=='INPUT') return;
    if ((el.getAttribute('type')||'').toLowerCase()!=='file') return;
    // Wait a bit for table/limits to process then build
    setTimeout(buildExceedances, 800);
    // also poll briefly
    let tries=0; const iv=setInterval(function(){ tries++; buildExceedances(); if (tries>10) clearInterval(iv); }, 1000);
  }, true);

  // Rebuild after table rebuilds
  const _bt = window.buildTable;
  if (typeof _bt === 'function'){
    window.buildTable = function(){ const r=_bt.apply(this, arguments); setTimeout(buildExceedances, 0); return r; };
  }

  // Expose manual API
  window.refreshExceedances = buildExceedances;
})();
</script>

<script>
/* === Robust Refresh wiring + immediate build from red cells === */
(function(){
  if (window.__exceed_fixbtn__) return; window.__exceed_fixbtn__ = true;

  function getTable(){ return document.getElementById('dataTable') || document.querySelector('table'); }
  function headerLabels(tbl){ if (!tbl || !tbl.tHead || !tbl.tHead.rows[0]) return []; return Array.from(tbl.tHead.rows[0].cells).map(th => (th.textContent||'').trim()); }
  function idxBy(labels, re){ for (let i=0;i<labels.length;i++){ if (re.test(labels[i])) return i; } return -1; }
  function toNumber(s){ if(s==null) return NaN; s=String(s).trim(); if(!s) return NaN; const c=(s.match(/,/g)||[]).length, d=(s.match(/\./g)||[]).length; if(c>d) s=s.replace(/\./g,'').replace(/,/g,'.'); else s=s.replace(/,/g,''); const n=Number(s); return isFinite(n)?n:NaN; }
  function ensureWrap(){
    let wrap = document.getElementById('exceedWrap');
    if (!wrap){
      wrap = document.createElement('section');
      wrap.id = 'exceedWrap';
      wrap.innerHTML = '<header><h3>Exceedances analysis</h3><div class="actions"><button id="exceedRefreshBtn">Refresh</button><button id="exceedCsvBtn">Download CSV</button></div></header><div class="inner"><div class="empty">No exceedances yet.</div></div>';
      (document.getElementById('main') || document.body).appendChild(wrap);
    } else {
      // ensure button exists
      if (!wrap.querySelector('#exceedRefreshBtn')){
        const actions = wrap.querySelector('.actions') || wrap.querySelector('header') || wrap;
        const btn = document.createElement('button'); btn.id='exceedRefreshBtn'; btn.textContent='Refresh';
        actions.insertBefore(btn, actions.firstChild);
      }
    }
    // toast
    if (!document.getElementById('exToast')){ const t=document.createElement('div'); t.id='exToast'; document.body.appendChild(t); }
    return wrap;
  }
  function toast(msg){ const t=document.getElementById('exToast'); if(!t) return; t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1600); }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  function collectFromRed(){
    const tbl = getTable(); if (!tbl) return [];
    const labels = headerLabels(tbl);
    const dateIdx = idxBy(labels, /\bDate\b|Timestamp/i);
    const devIdx  = idxBy(labels, /\bDevice\b|\bWTG\b|\bWTG Tag\b|WTG\s*ID/i);
    const bodies = [];
    if (tbl.tBodies && tbl.tBodies[0]) bodies.push(tbl.tBodies[0]);
    const inner = document.querySelector('.x-virtual-tbody table tbody'); if (inner) bodies.push(inner);
    const out=[];
    bodies.forEach(body=>{
      body.querySelectorAll('td.over-limit').forEach(td=>{
        const tr = td.parentElement;
        const idx = Array.prototype.indexOf.call(tr.children, td);
        const variable = labels[idx] || ('Column ' + (idx+1));
        const val = toNumber(td.textContent);
        const device = (devIdx>=0 && tr.children[devIdx]) ? tr.children[devIdx].textContent.trim() : '';
        const date   = (dateIdx>=0 && tr.children[dateIdx]) ? tr.children[dateIdx].textContent.trim()   : '';
        const limit  = td.getAttribute('data-limit') || '';
        out.push({device, variable, date, value: val, limit});
      });
    });
    // dedupe
    const seen=new Set(), uniq=[];
    out.forEach(r=>{ const k=[r.device,r.variable,r.date,r.value].join('|'); if(!seen.has(k)){ seen.add(k); uniq.push(r);} });
    return uniq;
  }

  function render(rows){
    ensureWrap();
    const inner = document.querySelector('#exceedWrap .inner');
    if (!rows.length){ inner.innerHTML = '<div class="empty">No exceedances found.</div>'; return; }
    const html = ['<div style="max-height:340px; overflow:auto;"><table id="exceedTable"><thead><tr><th>Device</th><th>Variable</th><th>Date & Time</th><th style="text-align:right">Value</th><th style="text-align:right">Limit</th></tr></thead><tbody>'];
    rows.forEach(r=> html.push(`<tr><td>${escapeHtml(r.device||'')}</td><td>${escapeHtml(r.variable||'')}</td><td>${escapeHtml(r.date||'')}</td><td class="v">${r.value}</td><td class="v">${r.limit||''}</td></tr>`));
    html.push('</tbody></table></div>');
    inner.innerHTML = html.join('');
  }

  function build(){ const rows = collectFromRed(); render(rows); toast(rows.length?('Added '+rows.length+' exceedance(s)'):('No exceedances found')); }

  // Delegated click so it works even if button gets re-rendered
  document.addEventListener('click', function(e){
    const btn = e.target.closest && e.target.closest('#exceedRefreshBtn, button, a');
    if (!btn) return;
    const txt = (btn.textContent||'').trim().toLowerCase();
    if (btn.id==='exceedRefreshBtn' || txt==='refresh' || txt==='ÿ™ÿ≠ÿØŸäÿ´' || txt.includes('exceed')){
      e.preventDefault(); e.stopPropagation();
      ensureWrap(); build();
    }
  }, true);

  // Run automatically after load and after CSV choose
  window.addEventListener('load', function(){ ensureWrap(); setTimeout(build, 300); setTimeout(build, 1200); });
  document.addEventListener('change', function(e){
    const el = e.target; if (!el || el.tagName!=='INPUT' || (el.getAttribute('type')||'').toLowerCase()!=='file') return;
    setTimeout(build, 800); setTimeout(build, 2000);
  }, true);

  // Also after table rebuild
  if (typeof window.buildTable === 'function'){
    const _bt = window.buildTable;
    window.buildTable = function(){ const r=_bt.apply(this, arguments); setTimeout(build, 0); return r; };
  }
})();
</script>

<script id="exceed-force-hilite">
(function(){
  if (window.__exceed_force_hilite__) return; window.__exceed_force_hilite__ = true;

  const LIMITS = [
    {re:/\bBearing\s+D\.?E\.?\s+Temperature\b.*10M/i, limit:95},
    {re:/\bBearing\s+N\.?D\.?E\.?\s+Temperature\b.*10M/i, limit:95},
    {re:/\bGearbox\b.*bearing temperature\b.*10M/i, limit:88},
    {re:/\bGearbox\b.*oil temperature\b.*10M/i, limit:75},
    {re:/\bGenerator\b.*windings temperature\s*1\b.*10M/i, limit:150},
    {re:/\bGenerator\b.*windings temperature\s*2\b.*10M/i, limit:150},
    {re:/\bGenerator\b.*windings temperature\s*3\b.*10M/i, limit:150},
    {re:/\bGenerator\b.*sliprings temperature\b.*10M/i, limit:75},
    {re:/\bTrafo\s*1\b.*winding temperature\b.*10M/i, limit:140},
    {re:/\bTrafo\s*2\b.*winding temperature\b.*10M/i, limit:140},
    {re:/\bTrafo\s*3\b.*winding temperature\b.*10M/i, limit:140},
  ];

  function getTable(){ return document.getElementById('dataTable') || document.querySelector('table'); }
  function headerLabels(tbl){ if (!tbl || !tbl.tHead || !tbl.tHead.rows[0]) return []; return Array.from(tbl.tHead.rows[0].cells).map(th => (th.textContent||'').trim()); }
  function idxBy(labels, re){ for (let i=0;i<labels.length;i++){ if (re.test(labels[i])) return i; } return -1; }
  function toNumber(s){ if (s==null) return NaN; s=String(s).trim(); if(!s) return NaN; const c=(s.match(/,/g)||[]).length, d=(s.match(/\./g)||[]).length; if(c>d) s=s.replace(/\./g,'').replace(/,/g,'.'); else s=s.replace(/,/g,''); const n=Number(s); return isFinite(n)?n:NaN; }

  function ensureHighlights(){
    const tbl = getTable(); if (!tbl) return 0;
    const labels = headerLabels(tbl); if (!labels.length) return 0;

    // map columns to limits
    const colLimits = {}; // idx -> limit
    labels.forEach((lab,i)=>{
      for (const r of LIMITS){ if (r.re.test(lab)){ colLimits[i] = r.limit; break; } }
    });
    if (!Object.keys(colLimits).length) return 0;

    // bodies (support virtualized)
    const bodies = [];
    if (tbl.tBodies && tbl.tBodies[0]) bodies.push(tbl.tBodies[0]);
    const inner = document.querySelector('.x-virtual-tbody table tbody'); if (inner) bodies.push(inner);

    let colored = 0;
    bodies.forEach(body=>{
      Array.from(body.rows).forEach(tr=>{
        Array.from(tr.cells).forEach((td,i)=>{
          const lim = colLimits[i]; if (lim==null) return;
          const val = toNumber(td.textContent);
          if (!isNaN(val)){
            td.classList.remove('over-limit','near-limit');
            if (val > lim){ td.classList.add('over-limit'); td.setAttribute('data-limit', String(lim)); colored++; }
            else if (val >= lim*0.9){ td.classList.add('near-limit'); td.setAttribute('data-limit', String(lim)); }
          }
        });
      });
    });
    return colored;
  }

  // Wire into existing refresh pipeline if present
  window.__ensureLimitsHighlights = ensureHighlights;

  // Patch the existing build() if defined by previous script
  if (window.refreshExceedancesFromRed || window.refreshExceedances){
    const origA = window.refreshExceedancesFromRed;
    window.refreshExceedancesFromRed = function(){ ensureHighlights(); if (origA) origA(); };
    const origB = window.refreshExceedances;
    window.refreshExceedances = function(){ ensureHighlights(); if (origB) origB(); };
  }

  // If no API, add our own refresh button wiring (idempotent)
  function runRefresh(){
    ensureHighlights();
    // If collect function exists use it, else fall back to our own quick collector:
    var btn = document.getElementById('exceedRefreshBtn');
    if (btn && !btn.__wired_force){
      btn.__wired_force = true;
      btn.addEventListener('click', function(){
        ensureHighlights();
        // Trigger old collectors
        if (window.refreshExceedancesFromRed) window.refreshExceedancesFromRed();
        else if (window.refreshExceedances) window.refreshExceedances();
      });
    }
  }

  // Auto: after CSV and after load, with retries until we see any red cells
  function autoKick(){
    let tries = 0;
    const iv = setInterval(function(){
      tries++;
      const colored = ensureHighlights();
      if (document.querySelector('td.over-limit') || tries>30){
        clearInterval(iv);
        if (window.refreshExceedancesFromRed) window.refreshExceedancesFromRed();
        else if (window.refreshExceedances) window.refreshExceedances();
      }
    }, 300);
  }

  window.addEventListener('load', function(){ runRefresh(); autoKick(); });
  document.addEventListener('change', function(e){
    const el = e.target; if (el && el.tagName==='INPUT' && (el.getAttribute('type')||'').toLowerCase()==='file'){ setTimeout(autoKick, 400); }
  }, true);
})();
</script>

<script id="exceed-allpages">
(function(){
  if (window.__exceed_allpages_force__) return; window.__exceed_allpages_force__ = true;

  // Helpers
  function getTable(){ return document.getElementById('dataTable') || document.querySelector('table'); }
  function labels(){ const t=getTable(); if(!t||!t.tHead||!t.tHead.rows[0]) return []; return Array.from(t.tHead.rows[0].cells).map(th=>(th.textContent||'').trim()); }
  function idxBy(labs,re){ for(let i=0;i<labs.length;i++){ if(re.test(labs[i]))return i; } return -1; }
  function toNumber(s){ if(s==null) return NaN; s=String(s).trim(); if(!s) return NaN; const c=(s.match(/,/g)||[]).length, d=(s.match(/\./g)||[]).length; if(c>d) s=s.replace(/\./g,'').replace(/,/g,'.'); else s=s.replace(/,/g,''); const n=Number(s); return isFinite(n)?n:NaN; }

  // Collect from current DOM (uses classes added by ensureHighlights)
  function collectFromThisPage(){
    const tbl=getTable(); if(!tbl) return [];
    const labs=labels(); const dateIdx=idxBy(labs,/\bDate\b|Timestamp/i); const devIdx=idxBy(labs,/\bDevice\b|\bWTG\b|\bWTG Tag\b|WTG\s*ID/i);
    const bodies=[]; if (tbl.tBodies&&tbl.tBodies[0]) bodies.push(tbl.tBodies[0]);
    const inner=document.querySelector('.x-virtual-tbody table tbody'); if(inner) bodies.push(inner);
    const rows=[];
    bodies.forEach(body=>{
      body.querySelectorAll('td.over-limit').forEach(td=>{
        const tr=td.parentElement; const idx=Array.prototype.indexOf.call(tr.children,td);
        const variable=labs[idx]||('Column '+(idx+1));
        const device=(devIdx>=0 && tr.children[devIdx])?tr.children[devIdx].textContent.trim():'';
        const date  =(dateIdx>=0 && tr.children[dateIdx])?tr.children[dateIdx].textContent.trim():'';
        const limit = td.getAttribute('data-limit')||'';
        const val   = toNumber(td.textContent);
        rows.push({device, variable, date, value:val, limit});
      });
    });
    return rows;
  }

  // Pagination API discovery
  function findPagination(){
    // Look for numbered page buttons
    const root = document;
    const pager = root.querySelector('#paginationControls, .pagination, .pager, nav[aria-label*="Pagination" i]') || root;
    const btns = Array.from(pager.querySelectorAll('button, a')).filter(el=>{
      const t=(el.textContent||'').trim();
      return /^\d+$/.test(t) || /next|prev|previous|first|last/i.test(t) || el.hasAttribute('data-page');
    });
    if (!btns.length) return null;
    // Determine current page by aria-current or class active/selected
    function current(){
      const cur = pager.querySelector('[aria-current="page"], .active, .selected, .is-active, .current');
      if (cur){ const t=(cur.textContent||cur.getAttribute('data-page')||'').trim(); const n=parseInt(t,10); return isFinite(n)?n:null; }
      // Fallback: look for disabled prev to infer
      return null;
    }
    function gotoPage(n){
      // Try direct page button
      let target = btns.find(b => parseInt((b.textContent||b.getAttribute('data-page')||'').trim(),10)===n);
      if (target){ target.click(); return true; }
      return false;
    }
    function pagesCount(){
      // Max numbered button
      let max=0;
      btns.forEach(b=>{ const t=parseInt((b.textContent||b.getAttribute('data-page')||'').trim(),10); if(isFinite(t)) max=Math.max(max,t); });
      return max || null;
    }
    // Try also API methods some tables expose
    const api = window.tableApi || window.gridApi || window.dataTable || window.dt || null;
    return {root:pager, btns, current, gotoPage, pagesCount, api};
  }

  // Wait until table body mutates
  function waitTableChange(timeoutMs){
    return new Promise(resolve=>{
      const tbl=getTable(); const body = (tbl && tbl.tBodies && tbl.tBodies[0]) ? tbl.tBodies[0] : document.querySelector('.x-virtual-tbody table tbody');
      if (!body){ setTimeout(resolve, 250); return; }
      const mo=new MutationObserver(()=>{ mo.disconnect(); resolve(); });
      mo.observe(body, {childList:true, subtree:false});
      setTimeout(()=>{ try{mo.disconnect();}catch(_){} resolve(); }, timeoutMs||1200);
    });
  }

  async function collectAllPages(){
    // If full dataset globals exist, we shouldn't be here; but still, try pagination traversal
    const pager = findPagination();
    // Always include current page first
    if (window.__ensureLimitsHighlights) window.__ensureLimitsHighlights();
    let all = collectFromThisPage();
    if (!pager){ return dedupe(all); }
    const labs=labels();
    // Count pages
    const total = pager.pagesCount ? pager.pagesCount() : null;
    const visited = new Set();
    // Try numbered traversal 1..N if we know N
    let restore = pager.current ? pager.current() : null;
    async function go(n){
      if (!pager.gotoPage(n)) return false;
      await waitTableChange(1200);
      if (window.__ensureLimitsHighlights) window.__ensureLimitsHighlights();
      all = all.concat(collectFromThisPage());
      return true;
    }
    if (total && total>1){
      for (let p=1; p<=total; p++){
        if (visited.has(p)) continue;
        visited.add(p);
        await go(p);
      }
    } else {
      // Fallback: click "Next" until it no longer changes
      let guard=0, lastSignature='';
      function signature(){
        const tbody = (getTable()?.tBodies?.[0]) || document.querySelector('.x-virtual-tbody table tbody');
        if (!tbody) return '';
        const first = tbody.querySelector('tr td')?.textContent || '';
        const count = tbody ? tbody.rows.length : 0;
        return first+'|'+count;
      }
      while(guard++<50){
        const next = pager.root.querySelector('button[aria-label*="Next" i], a[aria-label*="Next" i], .next, [rel="next"]');
        const sig = signature();
        if (!next) break;
        next.click();
        await waitTableChange(1200);
        const sig2 = signature();
        if (sig2===sig) break; // no page change
        if (window.__ensureLimitsHighlights) window.__ensureLimitsHighlights();
        all = all.concat(collectFromThisPage());
      }
    }
    // Restore page if possible
    if (restore!=null && pager.gotoPage){ pager.gotoPage(restore); await waitTableChange(300); if (window.__ensureLimitsHighlights) window.__ensureLimitsHighlights(); }
    return dedupe(all);
  }

  function dedupe(rows){
    const seen=new Set(), out=[];
    rows.forEach(r=>{ const k=[r.device,r.variable,r.date,r.value].join('|'); if(!seen.has(k)){ seen.add(k); out.push(r);} });
    return out;
  }

  // Hook the existing render to accept external rows
  function render(rows){
    let wrap = document.getElementById('exceedWrap');
    if (!wrap){
      wrap = document.createElement('section');
      wrap.id='exceedWrap';
      wrap.innerHTML = '<header><h3>Exceedances analysis</h3><div class="actions"><button id="exceedRefreshBtn">Refresh</button><button id="exceedCsvBtn">Download CSV</button></div></header><div class="inner"></div>';
      (document.getElementById('main')||document.body).appendChild(wrap);
    }
    const inner = wrap.querySelector('.inner');
    if (!rows.length){ inner.innerHTML = '<div class="empty">No exceedances found.</div>'; return; }
    const html = ['<div style="max-height:340px; overflow:auto;"><table id="exceedTable"><thead><tr><th>Device</th><th>Variable</th><th>Date & Time</th><th style="text-align:right">Value</th><th style="text-align:right">Limit</th></tr></thead><tbody>'];
    rows.forEach(r => html.push(`<tr><td>${escapeHtml(r.device||'')}</td><td>${escapeHtml(r.variable||'')}</td><td>${escapeHtml(r.date||'')}</td><td class="v">${r.value}</td><td class="v">${r.limit||''}</td></tr>`));
    html.push('</tbody></table></div>');
    inner.innerHTML = html.join('');
  }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  // Wire the button to all-pages collection
  function wire(){
    const btn = document.getElementById('exceedRefreshBtn');
    if (!btn) return;
    if (btn.__wired_allpages) return;
    btn.__wired_allpages = true;
    btn.addEventListener('click', async function(e){
      e.preventDefault();
      // Try full-data route first (if previous scripts exposed refreshExceedances), else all-pages traversal
      if (typeof window.refreshExceedancesFromRed === 'function'){ window.refreshExceedancesFromRed(); }
      // Then enforce all-pages sweep
      const rows = await collectAllPages();
      render(rows);
    });
  }

  window.addEventListener('load', wire);
  document.addEventListener('DOMContentLoaded', wire);
  // Also auto-run shortly after CSV picked
  document.addEventListener('change', function(e){
    const el = e.target; if (!el || el.tagName!=='INPUT' || (el.getAttribute('type')||'').toLowerCase()!=='file') return;
    setTimeout(async ()=>{ const rows = await collectAllPages(); render(rows); }, 1200);
  }, true);
})();
</script>

<script id="exceed-sort-sweep">
(function(){
  if (window.__exceed_sort_sweep__) return; window.__exceed_sort_sweep__ = true;

  const LIMITS_REGEX = [
    /\bBearing\s+D\.?E\.?\s+Temperature\b.*10M/i,
    /\bBearing\s+N\.?D\.?E\.?\s+Temperature\b.*10M/i,
    /\bGearbox\b.*bearing temperature\b.*10M/i,
    /\bGearbox\b.*oil temperature\b.*10M/i,
    /\bGenerator\b.*windings temperature\s*1\b.*10M/i,
    /\bGenerator\b.*windings temperature\s*2\b.*10M/i,
    /\bGenerator\b.*windings temperature\s*3\b.*10M/i,
    /\bGenerator\b.*sliprings temperature\b.*10M/i,
    /\bTrafo\s*1\b.*winding temperature\b.*10M/i,
    /\bTrafo\s*2\b.*winding temperature\b.*10M/i,
    /\bTrafo\s*3\b.*winding temperature\b.*10M/i
  ];

  function getTable(){ return document.getElementById('dataTable') || document.querySelector('table'); }
  function labels(){
    const t=getTable(); if(!t||!t.tHead||!t.tHead.rows[0]) return [];
    return Array.from(t.tHead.rows[0].cells).map(th => (th.textContent||'').trim());
  }
  function limitColumns(){
      if (window.__EXCEED_TARGET_INDICES__ && Array.isArray(window.__EXCEED_TARGET_INDICES__) && window.__EXCEED_TARGET_INDICES__.length){
        return window.__EXCEED_TARGET_INDICES__;
      }
      // fallback to previous behavior:

    const labs=labels();
    const out=[];
    for (let i=0;i<labs.length;i++){
      if (LIMITS_REGEX.some(re => re.test(labs[i]))){ out.push({index:i, label:labs[i]}); }
    }
    return out;
  }
  function ariaSort(th){
    return (th.getAttribute('aria-sort')||'').toLowerCase() || (th.className||'').toLowerCase();
  }
  function isDesc(th){
    const s=ariaSort(th);
    return s.includes('desc');
  }
  function isSortable(th){
    // heuristic: has onclick, role=columnheader, or data-sort, or cursor pointer
    const style = getComputedStyle(th);
    return th.matches('[role="columnheader"],[data-sort],.sortable,th') && (th.onclick || style.cursor==='pointer' || th.matches('[aria-sort], .sort, .sortable'));
  }

  function waitForBodyChange(timeoutMs){
    return new Promise(resolve=>{
      const tbl=getTable(); const body = (tbl && tbl.tBodies && tbl.tBodies[0]) ? tbl.tBodies[0] : document.querySelector('.x-virtual-tbody table tbody');
      if (!body){ setTimeout(resolve, 250); return; }
      const mo=new MutationObserver(()=>{ mo.disconnect(); resolve(); });
      mo.observe(body, {childList:true, subtree:false});
      setTimeout(()=>{ try{mo.disconnect();}catch(_){ } resolve(); }, timeoutMs||1200);
    });
  }

  function collectFromRed(){
    const tbl=getTable(); if(!tbl) return [];
    const labs=labels();
    function idxBy(re){ for (let i=0;i<labs.length;i++){ if(re.test(labs[i])) return i; } return -1; }
    const dateIdx = idxBy(/\bDate\b|Timestamp/i);
    const devIdx  = idxBy(/\bDevice\b|\bWTG\b|\bWTG Tag\b|WTG\s*ID/i);
    const bodies=[];
    if (tbl.tBodies && tbl.tBodies[0]) bodies.push(tbl.tBodies[0]);
    const inner=document.querySelector('.x-virtual-tbody table tbody'); if(inner) bodies.push(inner);
    function toNumber(s){ if(s==null) return NaN; s=String(s).trim(); if(!s) return NaN; const c=(s.match(/,/g)||[]).length, d=(s.match(/\./g)||[]).length; if(c>d) s=s.replace(/\./g,'').replace(/,/g,'.'); else s=s.replace(/,/g,''); const n=Number(s); return isFinite(n)?n:NaN; }
    const out=[];
    bodies.forEach(b=> b.querySelectorAll('td.over-limit').forEach(td=>{
      const tr = td.parentElement;
      const idx = Array.prototype.indexOf.call(tr.children, td);
      const variable = labs[idx] || ('Column '+(idx+1));
      const device = (devIdx>=0 && tr.children[devIdx]) ? tr.children[devIdx].textContent.trim() : '';
      const date   = (dateIdx>=0 && tr.children[dateIdx]) ? tr.children[dateIdx].textContent.trim()   : '';
      const limit  = td.getAttribute('data-limit') || '';
      const value  = toNumber(td.textContent);
      out.push({device, variable, date, value, limit});
    }));
    // dedupe
    const seen=new Set(), uniq=[];
    out.forEach(r=>{ const k=[r.device,r.variable,r.date,r.value].join('|'); if(!seen.has(k)){ seen.add(k); uniq.push(r);} });
    return uniq;
  }

  function render(rows){
    let wrap = document.getElementById('exceedWrap');
    if (!wrap){
      wrap = document.createElement('section');
      wrap.id='exceedWrap';
      wrap.innerHTML = '<header><h3>Exceedances analysis</h3><div class="actions"><button id="exceedRefreshBtn">Refresh</button><button id="exceedCsvBtn">Download CSV</button></div></header><div class="inner"></div>';
      (document.getElementById('main')||document.body).appendChild(wrap);
    }
    const inner = wrap.querySelector('.inner');
    if (!rows.length){ inner.innerHTML = '<div class="empty">No exceedances found.</div>'; return; }
    const html = ['<div style="max-height:340px; overflow:auto;"><table id="exceedTable"><thead><tr><th>Device</th><th>Variable</th><th>Date & Time</th><th style="text-align:right">Value</th><th style="text-align:right">Limit</th></tr></thead><tbody>'];
    rows.forEach(r => html.push(`<tr><td>${escapeHtml(r.device||'')}</td><td>${escapeHtml(r.variable||'')}</td><td>${escapeHtml(r.date||'')}</td><td class="v">${r.value}</td><td class="v">${r.limit||''}</td></tr>`));
    html.push('</tbody></table></div>');
    inner.innerHTML = html.join('');
    // CSV
    const btn = document.getElementById('exceedCsvBtn');
    if (btn){
      btn.onclick = function(){
        const rowsCSV = [['Device','Variable','Date & Time','Value','Limit']].concat(rows.map(r=>[r.device,r.variable,r.date,r.value,r.limit||'']));
        const csv = rowsCSV.map(a => a.map(x => `"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='exceedances.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),0);
      };
    }
  }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  async function ensureDescending(th){
    if (!th) return;
    // Try up to 3 clicks to reach descending
    for (let i=0;i<3;i++){
      if (isDesc(th)) return;
      th.click();
      await waitForBodyChange(1000);
    }
  }

  async function sortSweepAndCollect(){
    const tbl = getTable(); if (!tbl) return;
    const labs = labels();
    const limitedCols = limitColumns();
    if (!limitedCols.length){ render([]); return; }

    // Remember current sorted th (if any) to restore later
    const currentTh = (tbl.tHead && tbl.tHead.rows[0]) ? Array.from(tbl.tHead.rows[0].cells).find(th => /desc|asc/i.test((th.getAttribute('aria-sort')||'') + ' ' + th.className)) : null;

    let all = [];
    for (const c of limitedCols){
      const th = (tbl.tHead && tbl.tHead.rows[0]) ? tbl.tHead.rows[0].cells[c.index] : null;
      if (!th || !isSortable(th)) continue;
      await ensureDescending(th);
      if (window.__ensureLimitsHighlights) window.__ensureLimitsHighlights();
      const part = collectFromRed();
      all = all.concat(part);
    }

    // Restore previous sort if we had one
    if (currentTh){
      // Click until we leave it in (at least) descending or its original state (best-effort)
      currentTh.click();
      await waitForBodyChange(600);
    }

    // Deduplicate and render
    const seen=new Set(), uniq=[];
    all.forEach(r=>{ const k=[r.device,r.variable,r.date,r.value].join('|'); if(!seen.has(k)){ seen.add(k); uniq.push(r);} });
    render(uniq);
  }

  // Wire button + autorun after CSV
  function wire(){
    const btn = document.getElementById('exceedRefreshBtn');
    if (btn && !btn.__wired_sweep){
      btn.__wired_sweep = true;
      btn.addEventListener('click', function(e){ e.preventDefault(); sortSweepAndCollect(); });
    }
  }
  window.addEventListener('load', wire);
  document.addEventListener('DOMContentLoaded', wire);
  document.addEventListener('change', function(e){
    const el = e.target; if (!el || el.tagName!=='INPUT' || (el.getAttribute('type')||'').toLowerCase()!=='file') return;
    setTimeout(sortSweepAndCollect, 1200);
  }, true);

  // Optional: expose API
  window.exceedSortSweep = sortSweepAndCollect;
})();
</script>

<script id="exceed-sort-targets">
(function(){
  // If the targeted list is already present, do nothing
  if (window.__exceed_sort_targets__) return; window.__exceed_sort_targets__ = true;

  // Explicit labels to sweep only (case-insensitive match after normalization)
  const TARGET_LABELS = [
    "Max of Bearing D.E. Temperature max 10M (¬∫C)",
    "Max of Bearing N.D.E. Temperature max 10M (¬∫C)",
    "Max of Gearbox bearing temperature max 10M (¬∫C)",
    "Max of Gearbox oil temperature max 10M (¬∫C)",
    "Max of Generator windings temperature 1 max 10M (¬∫C)",
    "Max of Generator windings temperature 2 max 10M (¬∫C)",
    "Max of Generator windings temperature 3 max 10M (¬∫C)",
    "Max of Generator‚Äôs sliprings temperature max 10M (¬∫C)",
    "Max of Trafo 1 winding temperature max 10M (¬∫C)",
    "Max of Trafo 2 winding temperature max 10M (¬∫C)",
    "Max of Trafo 3 winding temperature max 10M (¬∫C)"
  ].map(s => s.toLowerCase().replace(/\s+/g, ' ').trim());

  function getTable(){ return document.getElementById('dataTable') || document.querySelector('table'); }
  function headLabels(){
    const t=getTable(); if(!t||!t.tHead||!t.tHead.rows[0]) return [];
    return Array.from(t.tHead.rows[0].cells).map(th => (th.textContent||'').replace(/\s+/g,' ').trim());
  }

  // Monkey-patch the sweep function (if exists) to limit to targets only
  if (typeof window.exceedSortSweep === 'function'){
    const _sweep = window.exceedSortSweep;
    window.exceedSortSweep = async function(){
      // expose targeted indices for the original sweep to read
      window.__EXCEED_TARGET_INDICES__ = (function(){
        const labels = headLabels();
        const idx = [];
        labels.forEach((lab,i)=>{
          const norm = lab.toLowerCase().replace(/\s+/g,' ').trim();
          if (TARGET_LABELS.includes(norm)) idx.push({index:i,label:lab});
        });
        return idx;
      })();
      return _sweep.apply(this, arguments);
    };
  }

  // If original sweep looks up its own columns, we also override a helper global it may use
  window.__EXCEED_TARGET_LABELS__ = TARGET_LABELS;
})();
</script>

<script id="exceed-persist-log-v3">
(function(){
  if (window.__exceed_persist_log_v3__) return; window.__exceed_persist_log_v3__ = true;
  const LS_KEY = 'exceed_log_v1';
  let _collecting = false;

  // ===== Panel creation (no Hide button) =====
  function ensureLogPanel(){
    let wrap = document.getElementById('exceedLogWrap');
    if (!wrap){
      wrap = document.createElement('section');
      wrap.id = 'exceedLogWrap';
      wrap.style.marginTop = '1rem';
      wrap.innerHTML = `
        <header style="display:flex;align-items:center;gap:.5rem;">
          <h3 style="margin:0;">Exceedances ‚Äî Saved Log</h3>
          <div class="actions" style="margin-left:auto;display:flex;gap:.5rem;">
            <button id="exceedLogRefreshBtn" title="Collect from current view/programmatic collectors">Collect Now</button>
            <button id="exceedLogDownloadBtn">Download Log CSV</button>
            <button id="exceedLogPdfBtn">Export PDF</button>
            <button id="exceedLogClearBtn">Clear Log</button>
          </div>
        </header>
        <div class="inner" style="margin-top:.5rem;">
          <div class="empty">No saved exceedances yet.</div>
        </div>
      `;
      // place after original exceed section if present, else at end of #main or body
      const original = document.getElementById('exceedWrap');
      if (original && original.parentNode){
        original.parentNode.insertBefore(wrap, original.nextSibling);
      } else {
        (document.getElementById('main') || document.body).appendChild(wrap);
      }
    }
    return wrap;
  }

  // Add an "Saved Log" opener button in the original toolbar (non-invasive)
  function addOpenButtonToOriginal(){
    const original = document.getElementById('exceedWrap');
    if (!original) return;
    const actions = original.querySelector('.actions') || original.querySelector('header');
    if (!actions || document.getElementById('openSavedLogBtn')) return;
    const btn = document.createElement('button');
    btn.id = 'openSavedLogBtn';
    btn.textContent = 'Saved Log';
    btn.style.marginLeft = '8px';
    actions.appendChild(btn);
    btn.addEventListener('click', ()=>{
      const p = ensureLogPanel();
      p.style.display = '';   // ensure visible
      renderLog();
      p.scrollIntoView({behavior:'smooth', block:'start'});
    });
  }

  // ===== Storage helpers =====
  function readLog(){ try { return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); } catch(_){ return []; } }
  function saveLog(rows){ localStorage.setItem(LS_KEY, JSON.stringify(rows)); }
  function keyOf(r){ return [r.device||'', r.variable||'', r.date||'', String(r.value)].join('|'); }

  function mergeIntoLog(newRows){
    if (!Array.isArray(newRows) || !newRows.length) return;
    const log = readLog();
    const seen = new Set(log.map(keyOf));
    newRows.forEach(r=>{
      const k = keyOf(r);
      if (!seen.has(k)){
        seen.add(k);
        log.push({
          device: String(r.device||''),
          variable: String(r.variable||''),
          date: String(r.date||''),
          value: Number(r.value),
          limit: (r.limit!==undefined && r.limit!==null) ? r.limit : ''
        });
      }
    });
    // sort by date asc then device
    log.sort((a,b)=>{
      const da = new Date(String(a.date).replace(' ', 'T'));
      const db = new Date(String(b.date).replace(' ', 'T'));
      if (!isNaN(da) && !isNaN(db) && da - db !== 0) return da - db;
      return String(a.device).localeCompare(String(b.device));
    });
    saveLog(log);
  }

  // ===== Collectors =====
  function parseRowsFromExceedTable(){
    const tbl = document.getElementById('exceedTable');
    if (!tbl || !tbl.tBodies || !tbl.tBodies[0]) return [];
    const out = [];
    Array.from(tbl.tBodies[0].rows).forEach(tr=>{
      const tds = tr.cells;
      if (!tds || tds.length < 5) return;
      out.push({
        device: (tds[0].textContent||'').trim(),
        variable: (tds[1].textContent||'').replace(/[‚ñ≤‚ñº]\s*$/,'').trim(),
        date: (tds[2].textContent||'').trim(),
        value: Number((tds[3].textContent||'').replace(/,/g,'')),
        limit: (tds[4].textContent||'').trim()
      });
    });
    return out;
  }

  function tryCollectProgrammatically(){
    try{
      if (typeof window.collectFromRed === 'function'){
        let r = window.collectFromRed(true);
        if (Array.isArray(r) && r.length) return r;
      }
    }catch(_){}
    try{
      if (typeof window.collectFromFull === 'function'){
        let r = window.collectFromFull(true);
        if (Array.isArray(r) && r.length) return r;
      }
    }catch(_){}
    return [];
  }

  async function collectNow(){
    if (_collecting) return;
    _collecting = true;
    try{
      let rows = tryCollectProgrammatically();
      if (!rows.length){
        rows = parseRowsFromExceedTable();
      }
      mergeIntoLog(rows);
    } finally {
      _collecting = false;
    }
  }

  // ===== Render =====
  function esc(s){ return String(s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function renderRows(rows){
    const wrap = ensureLogPanel();
    const inner = wrap.querySelector('.inner');
    if (!rows.length){ inner.innerHTML = '<div class="empty">No saved exceedances yet.</div>'; return; }
    const html = ['<div style="max-height:340px; overflow:auto;"><table><thead><tr><th>Device</th><th>Variable</th><th>Date & Time</th><th style="text-align:right">Value</th><th style="text-align:right">Limit</th></tr></thead><tbody>'];
    rows.forEach(r=>{
      html.push(`<tr><td>${esc(r.device||'')}</td><td>${esc(r.variable||'')}</td><td>${esc(r.date||'')}</td><td style="text-align:right">${esc(r.value)}</td><td style="text-align:right">${esc(r.limit||'')}</td></tr>`);
    });
    html.push('</tbody></table></div>');
    inner.innerHTML = html.join('');
  }
  function renderLog(){ renderRows(readLog()); }

  // ===== Wire buttons (no Hide references) =====
  function wirePanelButtons(){
    const wrap = ensureLogPanel();
    const btnDownload = wrap.querySelector('#exceedLogDownloadBtn');
    const btnClear = wrap.querySelector('#exceedLogClearBtn');
    const btnRefresh = wrap.querySelector('#exceedLogRefreshBtn');
    const btnPdf = wrap.querySelector('#exceedLogPdfBtn');
    // Bind the download button only once per element to avoid multiple CSV downloads.
    if (btnDownload && !btnDownload.__exLogCsvBound) {
      btnDownload.addEventListener('click', downloadLogCSV);
      btnDownload.__exLogCsvBound = true;
    }
    if (btnClear) btnClear.addEventListener('click', ()=>{
      try { localStorage.removeItem(LS_KEY); } catch(e){ console.warn('Failed to clear log:', e); }
      renderLog();
    });
    if (btnPdf) btnPdf.addEventListener('click', exportLogPDF);
    if (btnRefresh) btnRefresh.addEventListener('click', async ()=>{
      await collectNow();
      renderLog();
    });

    // Remove any previously registered delegated click listener to prevent duplicate downloads
    // Note: Delegated listener was removed in this version to avoid double invocation
  }

  function exportLogPDF(){
    const log = readLog();
    // Build HTML for a printable A4 document
    const today = new Date();
    const pad = n => String(n).padStart(2,'0');
    const timestamp = `${today.getFullYear()}-${pad(today.getMonth()+1)}-${pad(today.getDate())} ${pad(today.getHours())}:${pad(today.getMinutes())}`;

    const rowsHtml = (log.length ? log : []).map(r => `
      <tr>
        <td>${esc(r.device||'')}</td>
        <td>${esc(r.variable||'')}</td>
        <td>${esc(r.date||'')}</td>
        <td class="num">${esc(r.value)}</td>
        <td class="num">${esc(r.limit||'')}</td>
      </tr>
    `).join('');

    const docHtml = `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Exceedances ‚Äî Saved Log (Export)</title>
<style>
  @page { size: A4; margin: 18mm 15mm; }
  :root { --ink:#111; --muted:#666; --line:#ddd; }
  * { box-sizing:border-box; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color: var(--ink); }
  header { display:flex; align-items:flex-end; justify-content:space-between; border-bottom:1px solid var(--line); padding-bottom:8px; margin-bottom:12px; }
  header h1 { font-size: 20px; margin:0; letter-spacing: .2px; }
  header .meta { font-size: 11px; color: var(--muted); text-align:right; }
  .stats { display:flex; gap:8px; font-size: 11px; color: var(--muted); margin-bottom:6px; }
  table { width:100%; border-collapse:collapse; font-size:12px; }
  thead th { text-align:left; border-bottom:1px solid var(--ink); padding:6px 8px; font-weight:600; }
  tbody td { border-bottom:1px solid var(--line); padding:6px 8px; vertical-align:top; }
  tbody tr:nth-child(even) td { background:#fafafa; }
  td.num { text-align:right; }
  footer { position: fixed; bottom: 0; left:0; right:0; font-size: 11px; color: var(--muted); display:flex; justify-content:space-between; border-top:1px solid var(--line); padding-top:6px; }
  .pageno:after { content: counter(page) " / " counter(pages); }
  /* Avoid table header orphan */
  thead { display: table-header-group; }
  tfoot { display: table-footer-group; }</style>
</head>
<body>
  <header>
    <h1>Exceedances ‚Äî Saved Log</h1>
    <div class="meta">
      Generated: ${timestamp}<br>
      Total rows: ${log.length}
    </div>
  </header>

  <div class="stats">
    <div>Devices: <strong>${new Set((log||[]).map(r=>r.device||'')).size}</strong></div>
    <div>Variables: <strong>${new Set((log||[]).map(r=>r.variable||'')).size}</strong></div>
  </div>

  <table>
    <thead>
      <tr>
        <th>Device</th>
        <th>Variable</th>
        <th>Date &amp; Time</th>
        <th style="text-align:right">Value</th>
        <th style="text-align:right">Limit</th>
      </tr>
    </thead>
    <tbody>
      ${rowsHtml || '<tr><td colspan="5" style="text-align:center;color:#999;padding:24px 8px;">No saved exceedances.</td></tr>'}
    </tbody>
  </table>

  <footer>
    <div>Exported by Saved Log</div>
    <div class="pageno"></div>
  </footer>
</body>
</html>`;

    const win = window.open('', '_blank');
    if (!win) { alert('Popup blocked. Please allow popups to export PDF.'); return; }
    win.document.open();
    win.document.write(docHtml);
    win.document.close();
    // Give it a moment to render before triggering print (user can choose "Save as PDF")
    setTimeout(()=>{ win.focus(); win.print(); }, 400);
  }

  function downloadLogCSV(){
    // Use a simple reentrancy lock to prevent duplicate downloads if the click event
    // somehow fires multiple times in quick succession.
    if (window.__exlog_dl_lock) return;
    window.__exlog_dl_lock = true;
    setTimeout(() => { window.__exlog_dl_lock = false; }, 700);

    // Determine whether to export the filtered view of the Saved Log or the full log from storage.
    let csvRows = [];
    let header = [];
    const wrap = document.getElementById('exceedLogWrap');
    const table = wrap && wrap.querySelector('table');
    if (table) {
      const thead = table.tHead;
      const tbody = table.tBodies && table.tBodies[0];
      if (thead && tbody) {
        // Get header text from the current DOM (strip sort arrows)
        header = Array.from(thead.querySelectorAll('th')).map(function(th){
          const txt = (th.firstChild && th.firstChild.nodeType === 3 ? th.firstChild.nodeValue : th.textContent || '');
          return txt.replace(/[‚ñ≤‚ñº]/g, '').trim();
        });
        // Collect visible rows only
        const visibleRows = Array.from(tbody.rows).filter(function(r){
          return r.style.display !== 'none';
        }).map(function(r){
          return Array.from(r.cells).map(function(td){ return td.textContent.trim(); });
        });
        if (visibleRows.length) {
          csvRows = [header].concat(visibleRows);
        }
      }
    }
    // If no visible rows collected, fall back to the full saved log from localStorage
    if (!csvRows.length) {
      const log = readLog();
      csvRows = [['Device','Variable','Date & Time','Value','Limit']].concat(
        (log || []).map(function(x){
          return [String(x.device || ''), String(x.variable || ''), String(x.date || ''), String(x.value || ''), (x.limit !== undefined && x.limit !== null) ? String(x.limit) : ''];
        })
      );
    }
    // Build CSV string with proper escaping. To prevent Excel from auto-formatting the
    // Date & Time column into a time-only value, prefix cells in the third column
    // (index 2) with a single quote. This forces Excel to treat the value as text
    // while leaving the displayed value unchanged.
    const csv = csvRows.map(function(row){
      return row.map(function(cell, idx){
        let v = String(cell);
        if (idx === 2) {
          v = '\'' + v;
        }
        v = v.replace(/"/g, '""');
        return '"' + v + '"';
      }).join(',');
    }).join('\n');

    // Create a Blob and object URL for the CSV; this approach ensures that
    // downloads work reliably across browsers and avoids issues with data URIs.
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'exceedances_log.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    // Fallback: open in a new tab so the user can save manually; this also
    // triggers URL revocation in a safe place.
    setTimeout(function(){
      try {
        window.open(url, '_blank');
      } catch (_) {
        /* no-op */
      }
      URL.revokeObjectURL(url);
    }, 0);
    return false;
  }

  // ===== Hooks: collect after refresh/build/file input =====
  function wireHooks(){
    document.addEventListener('click', function(e){
      const btn = e.target.closest && e.target.closest('#exceedRefreshBtn');
      if (!btn) return;
      setTimeout(collectNow, 250);
    }, true);
    document.addEventListener('change', function(ev){
      const el = ev.target;
      if (el && el.tagName==='INPUT' && (el.type||'').toLowerCase()==='file'){
        setTimeout(collectNow, 1200);
      }
    }, true);
    if (typeof window.buildTable === 'function' && !window.buildTable.__exlog_v3_patched){
      const _bt = window.buildTable;
      window.buildTable = function(){ const r=_bt.apply(this, arguments); setTimeout(collectNow, 0); return r; };
      window.buildTable.__exlog_v3_patched = true;
    }
  }

  // ===== Init: make panel visible by default and wire everything =====
  window.addEventListener('load', function(){
    ensureLogPanel().style.display = ''; // visible by default
    addOpenButtonToOriginal();
    wirePanelButtons();
    wireHooks();
    // initial collect to populate panel if possible
    setTimeout(function(){ collectNow(); renderLog(); }, 500);
  });

  // Debug helpers
  window.__getExceedLog = function(){ return readLog(); };
  window.__clearExceedLog = function(){ localStorage.removeItem(LS_KEY); };
})();
</script>

<style>
/* Sort indicators + search input styling */
#exceedLogWrap th.sortable{cursor:pointer;position:relative;user-select:none;padding-right:18px;}
#exceedLogWrap th.sortable .arrow{position:absolute;right:6px;top:50%;transform:translateY(-50%);font-size:11px;opacity:.7;}
#exceedTurbineSearch{padding:6px 8px;border:1px solid #d1d5db;border-radius:8px}
</style>
<script>
(function(){
  function parseDateCell(txt){
    if(!txt) return NaN;
    var s=String(txt).trim();
    // normalize: "YYYY/MM/DD HH:mm:ss(.SSS)"
    s=s.replace(/\//g,'-').replace(' ', 'T');
    var d=new Date(s);
    if(isNaN(d)){ s=s.replace(/\.\d+$/,''); d=new Date(s); }
    return d.getTime();
  }

  function enhanceOneTable(table){
    if(!table) return;
    var thead=table.tHead, tbody=table.tBodies && table.tBodies[0];
    if(!thead || !tbody) return;

    // prevent rebinding if same node already enhanced
    if(table.__exlogEnhanced) return;
    table.__exlogEnhanced = true;

    var headers = Array.from(thead.querySelectorAll('th'));
    headers.forEach(function(th, idx){
      th.classList.add('sortable');
      // clear previous arrow if any (from a prior render)
      var old = th.querySelector('.arrow'); if(old) old.remove();
      var arrow=document.createElement('span'); arrow.className='arrow'; arrow.textContent=''; th.appendChild(arrow);

      th.addEventListener('click', function(){
        var state = th.getAttribute('data-sort') || 'none';
        var dir = state === 'asc' ? 'desc' : 'asc';
        headers.forEach(function(h){ h.removeAttribute('data-sort'); h.classList.remove('asc','desc'); var a=h.querySelector('.arrow'); if(a) a.textContent=''; });
        th.setAttribute('data-sort', dir);
        th.classList.add(dir);
        arrow.textContent = dir==='asc' ? '‚ñ≤' : '‚ñº';

        var rows = Array.from(tbody.rows);
        var isDateCol = (idx===2);
        var isNumeric = (idx===3 || idx===4);
        rows.sort(function(a,b){
          var A = a.cells[idx]?a.cells[idx].textContent.trim():'';
          var B = b.cells[idx]?b.cells[idx].textContent.trim():'';
          var va,vb;
          if(isDateCol){ va=parseDateCell(A); vb=parseDateCell(B); }
          else if(isNumeric){ va=parseFloat(A.replace(/,/g,'')); vb=parseFloat(B.replace(/,/g,'')); if(isNaN(va)) va=-Infinity; if(isNaN(vb)) vb=-Infinity; }
          else { va=A.toLowerCase(); vb=B.toLowerCase(); }
          var cmp = va<vb?-1:(va>vb?1:0);
          return dir==='asc'?cmp:-cmp;
        });
        rows.forEach(function(r){ tbody.appendChild(r); });
      });
    });
  }

  function ensureSearch(wrap, tbody){
    var actions = wrap.querySelector('header .actions') || wrap.querySelector('header');
    if(!actions) return;
    var input = document.getElementById('exceedTurbineSearch');
    if(!input){
      input = document.createElement('input');
      input.type='search';
      input.id='exceedTurbineSearch';
      input.placeholder='Search turbine (Device)...';
      input.style.marginLeft='8px';
      actions.appendChild(input);
    }
    // Rebind handler (idempotent)
    input.oninput = function(){
      var q = this.value.trim().toLowerCase();
      Array.from(tbody.rows).forEach(function(r){
        var device = r.cells[0]?r.cells[0].textContent.toLowerCase():'';
        r.style.display = !q || device.indexOf(q)!==-1 ? '' : 'none';
      });
    };
  }

  function enhanceSavedLog(){
    var wrap = document.getElementById('exceedLogWrap');
    if(!wrap) return false;
    var table = wrap.querySelector('table');
    if(!table) return false;
    var tbody = table.tBodies && table.tBodies[0]; if(!tbody) return false;
    enhanceOneTable(table);
    ensureSearch(wrap, tbody);
    return true;
  }

  // Observe the document for the Saved Log panel creation
  function waitForPanelAndEnhance(){
    if(enhanceSavedLog()) return; // already present
    var obs = new MutationObserver(function(){
      if(enhanceSavedLog()){
        obs.disconnect();
        // also watch the inner content for re-renders to re-apply on new table nodes
        var wrap = document.getElementById('exceedLogWrap');
        var target = wrap && (wrap.querySelector('.inner') || wrap);
        if(target){
          var obs2 = new MutationObserver(function(){
            // small delay to allow DOM fill
            setTimeout(enhanceSavedLog, 0);
          });
          obs2.observe(target, {childList:true, subtree:true});
        }
      }
    });
    obs.observe(document.body || document.documentElement, {childList:true, subtree:true});
  }

  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', waitForPanelAndEnhance);
  } else {
    waitForPanelAndEnhance();
  }
})();
</script>


<script>
/* Override Export PDF to use the CURRENT DOM (sorted/filtered rows) */
(function(){
  function exportCurrentTableToPDF(){
    var wrap = document.getElementById('exceedLogWrap');
    if (!wrap) return;
    var table = wrap.querySelector('table');
    if (!table) return;

    var thead = table.tHead;
    var tbody = table.tBodies && table.tBodies[0];
    if (!thead || !tbody) return;

    // Build header cells text (without sort arrows)
    var headers = Array.from(thead.querySelectorAll('th')).map(function(th){
      return (th.firstChild && th.firstChild.nodeType === 3 ? th.firstChild.nodeValue : th.textContent || '').replace(/[‚ñ≤‚ñº]/g,'').trim();
    });

    // Collect VISIBLE rows only, in current order
    var rows = Array.from(tbody.rows).filter(function(r){
      return r.style.display !== 'none';
    }).map(function(r){
      return Array.from(r.cells).map(function(td){ return td.textContent.trim(); });
    });

    // Build print-friendly HTML
    var styles = [
      'body{ -webkit-print-color-adjust:exact; print-color-adjust:exact; margin:0; padding:24px; font: 13px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#0f172a;}',
      'h1{ margin:0 0 12px; font: 600 18px/1 system-ui, sans-serif;}',
      'table{ width:100%; border-collapse:collapse; table-layout:fixed;}',
      'th, td{ border:1px solid #e5e7eb; padding:6px 8px; text-align:left; vertical-align:top;}',
      'th{ background:#1d4ed8; color:#fff; }',
      'td:nth-child(4), td:nth-child(5){ text-align:right; }',
      '@page { size: A4; margin: 10mm; }'
    ].join('\n');

    var html = '<!doctype html><html><head><meta charset="utf-8"><title>Exceedances ‚Äî Saved Log</title><style>'+styles+'</style><style>
/* === UI Zoom controls === */
.zoom-controls{ display:inline-flex; align-items:center; gap:6px; margin-left:6px; }
.zoom-controls button{
  appearance:none; border:1px solid var(--border, #e2e8f0); background:var(--panel, #fff); color:var(--text, #0f172a);
  border-radius:10px; padding:6px 10px; font-size:14px; cursor:pointer; box-shadow:var(--shadow-sm, 0 1px 2px rgba(16, 24, 40, 0.04));
}
.zoom-controls button:hover{ transform:translateY(-1px); box-shadow:var(--shadow-md, 0 6px 18px rgba(16, 24, 40, 0.10)); }
.zoom-controls .zoom-readout{ min-width:54px; text-align:center; font-variant-numeric:tabular-nums; font-weight:600; }
body[data-zoom-fallback="1"]{ 
  transform: scale(var(--ui-zoom, 1)); transform-origin: top left; 
  width: calc(100% / var(--ui-zoom, 1)); 
}
</style>
</head><body>';
    html += '<h1>Exceedances ‚Äî Saved Log</h1>';
    html += '<table><thead><tr>' + headers.map(function(h){ return '<th>'+h+'</th>'; }).join('') + '</tr></thead><tbody>';
    rows.forEach(function(cells){
      html += '<tr>' + cells.map(function(v, idx){
        // keep numeric alignment on Value/Limit columns
        var align = (idx===3 || idx===4) ? ' style="text-align:right"' : '';
        return '<td'+align+'>'+v+'</td>';
      }).join('') + '</tr>';
    });
    html += '</tbody></table></body></html>';

    var win = window.open('', '_blank');
    if (!win) { alert('Popup blocked. Please allow popups to export PDF.'); return; }
    win.document.open();
    win.document.write(html);
    win.document.close();
    // Give it a moment before triggering print (user can choose "Save as PDF")
    setTimeout(function(){ try { win.focus(); win.print(); } catch(e){} }, 400);
  }

  // Capture the PDF button click BEFORE existing handlers and override
  document.addEventListener('click', function(e){
    var btn = e.target && (e.target.closest && e.target.closest('#exceedLogPdfBtn'));
    if (!btn) return;
    e.preventDefault();
    if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    e.stopPropagation();
    exportCurrentTableToPDF();
  }, true);
})();
</script>

<script>
/* === Exceedances Limit Fallback Patch v3 (idempotent) === */
(function(){
  if (window.__fix_exceed_limits_v3__) return; window.__fix_exceed_limits_v3__ = true;

  // 1) Map: variable name -> limit (regex)
  const LIMITS = (window.__LIMITS_MAP__) || [
    {match:/\bBearing\s+D\.?E\.?\s+Temperature\b.*10\s*M/i, limit:95},
    {match:/\bBearing\s+N\.?D\.?E\.?\s+Temperature\b.*10\s*M/i, limit:95},
    {match:/\bGearbox\b.*bearing\s+temperature\b.*10\s*M/i, limit:88},
    {match:/\bGearbox\b.*oil\s+temperature\b.*10\s*M/i, limit:75},
    {match:/\bGenerator\b.*windings\s+temperature\s*1\b.*10\s*M/i, limit:150},
    {match:/\bGenerator\b.*windings\s+temperature\s*2\b.*10\s*M/i, limit:150},
    {match:/\bGenerator\b.*windings\s+temperature\s*3\b.*10\s*M/i, limit:150},
    {match:/\bGenerator\b.*sliprings\s+temperature\b.*10\s*M/i, limit:75},
    {match:/\bTrafo\s*1\b.*winding\s+temperature\b.*10\s*M/i, limit:140},
    {match:/\bTrafo\s*2\b.*winding\s+temperature\b.*10\s*M/i, limit:140},
    {match:/\bTrafo\s*3\b.*winding\s+temperature\b.*10\s*M/i, limit:140},
  ];

  function limitFromVariable(v){
    const s = String(v||'').replace(/\s+/g,' ').trim();
    for (const r of LIMITS){ if (r.match.test(s)) return r.limit; }
    return '';
  }

  // 2) Ensure highlighted TDs have data-limit (using header text)
  function setMissingDataLimitOnHighlightedCells() {
    try{
      const tbl = document.getElementById('dataTable') || document.querySelector('table');
      if (!tbl || !tbl.tHead || !tbl.tBodies) return;
      const headerRow = (tbl.tHead.rows && tbl.tHead.rows[0]) ? tbl.tHead.rows[0] : null;
      const heads = headerRow ? Array.from(headerRow.cells).map(th => (th.textContent||'').trim()) : [];
      Array.from(tbl.tBodies).forEach(tb=>{
        Array.from(tb.rows).forEach(tr=>{
          Array.from(tr.cells).forEach((td,i)=>{
            if ((td.classList && (td.classList.contains('over-limit') || td.classList.contains('near-limit'))) 
                && !td.getAttribute('data-limit')){
              const lim = limitFromVariable(heads[i]||'');
              if (lim) td.setAttribute('data-limit', String(lim));
            }
          });
        });
      });
    }catch(_){}
  }

  // 3) Wrap data collectors once they exist (poll until available)
  function installWrappers(){
    let patched = 0;
    function wrap(name, handler){
      const fn = window[name];
      if (typeof fn === 'function' && !fn.__wrapped_for_limits){
        window[name] = function(){
          const r = fn.apply(this, arguments);
          try{ return handler(r); }catch(_){ return r; }
        };
        window[name].__wrapped_for_limits = true;
        patched++;
      }
    }
    wrap('collectFromRed', function(rows){
      (rows||[]).forEach(r=>{ if (!r.limit) r.limit = limitFromVariable(r.variable); });
      return rows;
    });
    wrap('parseRowsFromExceedTable', function(rows){
      (rows||[]).forEach(r=>{ if (!r.limit) r.limit = limitFromVariable(r.variable); });
      return rows;
    });
    // mergeIntoLog(newRows) doesn't return rows, so patch by proxy
    const m = window['mergeIntoLog'];
    if (typeof m === 'function' && !m.__wrapped_for_limits){
      window['mergeIntoLog'] = function(newRows){
        try{ (newRows||[]).forEach(r=>{ if (!r.limit) r.limit = limitFromVariable(r.variable); }); }catch(_){}
        return m.apply(this, arguments);
      };
      window['mergeIntoLog'].__wrapped_for_limits = true;
      patched++;
    }
    return patched;
  }

  // 4) Fill Limit column in DOM tables if empty
  function fillLimitInDom(){
    // Exceedances table
    const ex = document.getElementById('exceedTable');
    if (ex && ex.tBodies && ex.tBodies[0]){
      Array.from(ex.tBodies[0].rows).forEach(tr=>{
        const tds = tr.cells; if (!tds || tds.length < 5) return;
        const varText = (tds[1].textContent||'').trim();
        const limitCell = tds[4];
        if (!limitCell.textContent.trim()){
          const lim = limitFromVariable(varText);
          if (lim) limitCell.textContent = String(lim);
        }
      });
    }
    // Saved Log table (rendered inside #exceedLogInner > table or similar)
    const wrap = document.getElementById('exceedLogInner') || document.querySelector('#exceedLogWrap .inner') || document.querySelector('#exceedLogWrap') || document.querySelector('#exceedWrap .inner');
    const tbl = wrap ? wrap.querySelector('table') : null;
    if (tbl && tbl.tBodies && tbl.tBodies[0]){
      Array.from(tbl.tBodies[0].rows).forEach(tr=>{
        const tds = tr.cells; if (!tds || tds.length < 5) return;
        const varText = (tds[1].textContent||'').trim();
        const limitCell = tds[4];
        if (!limitCell.textContent.trim()){
          const lim = limitFromVariable(varText);
          if (lim) limitCell.textContent = String(lim);
        }
      });
    }
  }

  // 5) Keep trying for a short while until everything is ready
  function tick(){
    try{ setMissingDataLimitOnHighlightedCells(); }catch(_){}
    try{ fillLimitInDom(); }catch(_){}
    installWrappers();
  }

  // Initial
  document.addEventListener('DOMContentLoaded', function(){ tick(); });
  window.addEventListener('load', function(){
    tick();
    let n=0; const iv = setInterval(function(){ n++; tick(); if (n>20) clearInterval(iv); }, 500);
  });

  // React to DOM changes (table reload / new CSV)
  const mo = new MutationObserver(()=>{ tick(); });
  mo.observe(document.documentElement || document.body, {childList:true, subtree:true});

  // Expose (optional manual call)
  window.__fixExceedLimits_v3_tick = tick;

})();
</script>

<script>
(function(){
  function ready(fn){ if (document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
  ready(function(){
    var TOOLTIP_ID = 'powerTooltip';
    var CONT_ID = 'powerChartContainer';
    var origParent = null, origNext = null;

    function getTip(){ return document.getElementById(TOOLTIP_ID); }
    function getCont(){ return document.getElementById(CONT_ID); }

    function moveTipIntoContainer(){
      var tip = getTip(), cont = getCont();
      if (!tip || !cont) return;
      if (tip.parentElement === cont) return;
      // remember original position to restore later
      origParent = tip.parentElement;
      origNext = tip.nextSibling;
      // make sure container can host absolutely-positioned tooltip
      var cs = getComputedStyle(cont);
      if (cs.position === 'static') cont.style.position = 'relative';
      tip.style.position = 'absolute';
      tip.style.zIndex = '10002';
      tip.style.pointerEvents = 'none'; // tooltip itself doesn't capture, overlay does
      cont.appendChild(tip);
    }
    function restoreTipToBody(){
      var tip = getTip();
      if (!tip) return;
      // if we saved a parent, restore to its original spot; else fallback to body
      if (origParent){
        if (origNext && origNext.parentNode === origParent) origParent.insertBefore(tip, origNext);
        else origParent.appendChild(tip);
      } else {
        document.body.appendChild(tip);
      }
      tip.style.zIndex = '10002';
      tip.style.pointerEvents = 'none';
    }

    // Keep tooltip inside the fullscreen subtree
    document.addEventListener('fullscreenchange', function(){
      var cont = getCont();
      if (!cont) return;
      if (document.fullscreenElement === cont){
        moveTipIntoContainer();
      } else {
        // Exit fullscreen -> restore tooltip to original place
        restoreTipToBody();
      }
    });

    // Also handle the case when button uses class-based pseudo-FS
    var mo = new MutationObserver(function(){
      var cont = getCont();
      if (!cont) return;
      if (cont.classList.contains('is-fullscreen-power')){
        moveTipIntoContainer();
      } else {
        restoreTipToBody();
      }
    });
    mo.observe(document.body, { attributes: true, subtree: true, attributeFilter: ['class'] });

    // Initial small sync
    setTimeout(function(){
      // If already in FS at load time (unlikely), ensure it's inside
      var cont = getCont();
      if (cont && (document.fullscreenElement === cont || cont.classList.contains('is-fullscreen-power'))){
        moveTipIntoContainer();
      }
    }, 0);
  });
})();
</script>


<script>
(function(){
  function addZoomControls(){
    var bar = document.querySelector('.topbar .toolbar');
    if (!bar || document.getElementById('zoomMinus')) return;
    var wrap = document.createElement('div');
    wrap.className = 'zoom-controls';
    wrap.innerHTML = '<button id="zoomMinus" title="ÿ™ÿµÿ∫Ÿäÿ± (Ctrl -)">‚àí</button>' +
                     '<span class="zoom-readout" id="zoomReadout">100%</span>' +
                     '<button id="zoomPlus" title="ÿ™ŸÉÿ®Ÿäÿ± (Ctrl +)">+</button>' +
                     '<button id="zoomReset" title="ÿ•ÿπÿßÿØÿ© 100%">Reset</button>';
    bar.appendChild(wrap);
  }

  var Z_MIN = 0.7, Z_MAX = 1.6, STEP = 0.1;
  function clamp(v){ return Math.min(Z_MAX, Math.max(Z_MIN, v)); }

  function applyZoom(z){
    z = clamp(z);
    var root = document.documentElement;
    var supportsZoom = (typeof CSS !== 'undefined' && CSS.supports && CSS.supports('zoom', '1'));
    if (supportsZoom){
      root.style.zoom = z;
      document.body.removeAttribute('data-zoom-fallback');
    }else{
      root.style.zoom = '';
      document.body.setAttribute('data-zoom-fallback','1');
      root.style.setProperty('--ui-zoom', String(z));
    }
    try { localStorage.setItem('uiZoom', String(z)); } catch(e){}
    var r = document.getElementById('zoomReadout');
    if (r) r.textContent = Math.round(z*100) + '%';
    // Re-measure & redraw charts
    setTimeout(function(){
      try{ if (typeof window.updateChart === 'function') window.updateChart(); }catch(e){}
      window.dispatchEvent(new Event('resize'));
    }, 50);
  }

  function getZoom(){ 
    var z = 1;
    try { z = parseFloat(localStorage.getItem('uiZoom') || '1'); } catch(e){ z = 1; }
    if (!isFinite(z)) z = 1; 
    return clamp(z);
  }

  function init(){
    addZoomControls();
    applyZoom(getZoom());
    var minus = document.getElementById('zoomMinus');
    var plus  = document.getElementById('zoomPlus');
    var reset = document.getElementById('zoomReset');
    if (minus) minus.onclick = function(){ applyZoom(getZoom() - STEP); };
    if (plus)  plus.onclick  = function(){ applyZoom(getZoom() + STEP); };
    if (reset) reset.onclick = function(){ applyZoom(1); };

    // Keyboard shortcuts: Ctrl/Cmd + '+' or '-' to zoom, '0' to reset
    document.addEventListener('keydown', function(e){
      if (!(e.ctrlKey || e.metaKey)) return;
      if (e.key === '+' || e.key === '='){ e.preventDefault(); applyZoom(getZoom() + STEP); }
      else if (e.key === '-' || e.key === '_'){ e.preventDefault(); applyZoom(getZoom() - STEP); }
      else if (e.key === '0'){ e.preventDefault(); applyZoom(1); }
    });
  }

  if (document.readyState !== 'loading') init();
  else document.addEventListener('DOMContentLoaded', init);
})();
</script>

</body>
</html>