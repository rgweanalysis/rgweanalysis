
<!DOCTYPE html>

<html dir="rtl" lang="ar">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>üìà ÿ™ŸÜÿ®ÿ§ ÿßŸÑÿ±Ÿäÿßÿ≠ ŸàÿßŸÑÿ≠ÿ±ÿßÿ±ÿ©</title>
<script src="https://cdn.tailwindcss.com"></script>
<script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.3/jspdf.plugin.autotable.min.js"></script>
<script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.min.js"></script>
    <!-- Charts CSS and modal styling -->
    <style id="chart-modal-style">
      /* Modal overlay for daily charts */
      #chartModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
      }
      #chartContainer {
        position: absolute;
        /* Anchor the container near the top to maximize visible height */
        top: 5vh;
        bottom: 5vh;
        left: 50%;
        transform: translateX(-50%);
        /* Increase the modal size so three charts are visible without scrolling */
        width: 95%;
        max-width: 1000px;
        /* With top and bottom defined, height is constrained automatically */
        overflow-y: auto;
        background: white;
        border-radius: 1rem;
        padding: 1rem;
        direction: rtl;
      }
      #chartContainer h3 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: #111827;
      }
      #chartContainer canvas {
        width: 100%;
        /* Reduce height of each chart so three graphs can fit on the screen */
        height: 170px;
        margin-bottom: 1rem;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        background: #ffffff;
      }
      #chartModal .close-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background: #e5e7eb;
        border-radius: 9999px;
        padding: 0.25rem 0.75rem;
        font-size: 0.75rem;
        color: #374151;
        cursor: pointer;
      }
      #crosshairInfo {
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
        color: #374151;
        text-align: center;
        direction: rtl;
      }

      /* Chart label styling */
      .chart-label {
        font-size: 0.875rem;
        font-weight: 600;
        color: #374151;
        margin-top: 0.5rem;
        margin-bottom: 0.25rem;
        text-align: right;
      }

      /* Download button styling */
      #downloadChartBtn,
      #downloadChartPdfBtn {
        display: inline-block;
        background-color: #2563eb;
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        margin-top: 0.5rem;
        margin-right: 0.5rem;
        cursor: pointer;
      }
    </style>
<style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "Helvetica Neue", Arial; }
    .fade-in { animation: fade .3s ease-in-out; }
    @keyframes fade { from {opacity:0; transform: translateY(6px)} to {opacity:1; transform: translateY(0)} }
    .lang-select {
#modelSelect{min-width:180px}
 border-radius: 9999px; padding: 6px 10px; border: 1px solid #e5e7eb; background: white; }
  </style>
<style id="rgwe-brand-style">
  :root { --rgwe-brand: #14a3d9; }
  header .max-w-6xl { position: relative; }
  #title-ar, #title-en{
    color: var(--rgwe-brand) !important;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    text-align: center !important;
    margin: 0;
    display: inline-block;
    flex-basis: auto;
    white-space: nowrap;
  }
</style>
<!-- Hide monthly note to avoid showing the 16-day limitation text and other messages -->
<style id="rgwe-monthly-note-hide">
  #monthlyNote { display: none !important; }
</style>

<!-- THEME: Apply early to avoid FOUC -->
<script>
(function(){
  try{
    var t = localStorage.getItem('rgwe_theme');
    if(!t){ t = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; }
    if(t === 'dark'){ document.documentElement.classList.add('dark'); }
  }catch(_){}
})();
</script>
<script>
// === Daily charts modal and drawing functions ===
(function(){
  // Global variables for crosshair index and datasets
  let crosshairIndex = null;
  let windData = [];
  let prodData = [];
  let tempData = [];
  let hourLabels = [];
  let windUnitLabel = '';
  // Track the currently displayed day index for chart PDF generation
  window._activeChartDayIndex = null;

  // Show the modal and populate charts for a given day index
  window.showChartsForDay = function(dayIndex){
    // remember the active day index for PDF export
    window._activeChartDayIndex = dayIndex;
    const store = window.__lastForecast;
    const data = store && store.data;
    // Reset arrays
    windData = [];
    prodData = [];
    tempData = [];
    hourLabels = [];
    crosshairIndex = null;
    let windUnit = 'ms';
    if (store && store.windUnit) windUnit = store.windUnit;
    windUnitLabel = (windUnit === 'ms' ? 'ŸÖ/ÿ´' : windUnit);
    let haveHourly = false;
    if (data && data.daily && data.hourly && Array.isArray(data.hourly.time)){
      const hourlyTimes = data.hourly.time;
      const hIdx = hoursForDay(dayIndex, hourlyTimes);
      if (Array.isArray(hIdx) && hIdx.length > 0){
        haveHourly = true;
        // Determine wind array for current height
        let windKey = 'wind_speed_' + (window.__windHeight || 80) + 'm';
        const windArray = data.hourly[windKey] || [];
        hIdx.forEach(function(k){
          // hour label
          const t = hourlyTimes[k];
          const hhmm = (typeof t === 'string' && t.includes('T')) ? t.split('T')[1].substring(0,5) : '';
          hourLabels.push(hhmm);
          // wind in ms then convert to unit
          const w = windArray[k];
          let wMs = Number.isFinite(w) ? convertToMs(w, windUnit) : NaN;
          let wConverted;
          switch(windUnit){
            case 'kmh': wConverted = wMs * 3.6; break;
            case 'mph': wConverted = wMs * 2.23694; break;
            case 'kn':  wConverted = wMs * 1.94384; break;
            default: wConverted = wMs; break;
          }
          windData.push(Number.isFinite(wConverted) ? +wConverted.toFixed(2) : 0);
          // expected production (MW)
          let prod = 0;
          if (Number.isFinite(wMs)) {
            try{
              if (typeof expectedProductionMWFromSheet === 'function'){
                prod = expectedProductionMWFromSheet(wMs);
              }else if(typeof expectedProd === 'function'){
                prod = expectedProd(wMs);
              }else{
                prod = 0;
              }
            }catch(e){ prod = 0; }
          }
          prodData.push(Number.isFinite(prod) ? +prod.toFixed(3) : 0);
          // temperature
          const tempVal = data.hourly.temperature_2m && data.hourly.temperature_2m[k];
          tempData.push(Number.isFinite(tempVal) ? +tempVal.toFixed(1) : 0);
        });
      }
    }
    // If no hourly data, fallback to synthetic series using saved daily min/max
    if (!haveHourly) {
      const fallbackAll = window.__fallbackData || {};
      const fb = fallbackAll[dayIndex];
      if (!fb) {
        alert('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ© ŸÑŸáÿ∞ÿß ÿßŸÑŸäŸàŸÖ.');
        return;
      }
      // 24 hours labels (00:00 to 23:00)
      for(let h=0; h<24; h++){
        const hh = h.toString().padStart(2, '0');
        hourLabels.push(hh + ':00');
        // create a simple sinusoidal curve between min and max
        const frac = (Math.sin((h / 24) * Math.PI * 2 - Math.PI/2) + 1) / 2;
        const w = fb.wmin + (fb.wmax - fb.wmin) * frac;
        windData.push(+w.toFixed(2));
        // estimate production
        let prod = 0;
        const wMs = (typeof convertToMs === 'function') ? convertToMs(w, windUnit) : w;
        try{
          if (typeof expectedProductionMWFromSheet === 'function'){
            prod = expectedProductionMWFromSheet(wMs);
          }else if(typeof expectedProd === 'function'){
            prod = expectedProd(wMs);
          }
        }catch(_){ prod = 0; }
        prodData.push(+prod.toFixed(3));
        // synthetic temperature: sinusoidal opposite phase
        const fracT = (Math.sin(((h+6) / 24) * Math.PI * 2 - Math.PI/2) + 1) / 2;
        const t = fb.tmin + (fb.tmax - fb.tmin) * fracT;
        tempData.push(+t.toFixed(1));
      }
    }
    // Update title
    const titleEl = document.getElementById('chartTitle');
    if (titleEl) {
      let iso;
      if (data && data.daily && data.daily.time) {
        iso = data.daily.time[dayIndex];
      }
      if (!iso && window.__extendedDates && window.__extendedDates[dayIndex]){
        iso = window.__extendedDates[dayIndex];
      }
      if (iso) {
        titleEl.textContent = 'ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä ŸÑŸäŸàŸÖ ' + formatDate(iso, 'ar-EG');
      } else {
        titleEl.textContent = 'ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä ŸÑŸäŸàŸÖ';
      }
    }
    // Show modal
    const modal = document.getElementById('chartModal');
    if(modal) modal.style.display = 'block';
    // Resize canvases based on container
    const windCanvas = document.getElementById('windChart');
    const prodCanvas = document.getElementById('prodChart');
    const tempCanvas = document.getElementById('tempChart');
    [windCanvas, prodCanvas, tempCanvas].forEach(function(cv){
      if (cv) {
        cv.width = cv.clientWidth;
        cv.height = cv.clientHeight;
      }
    });
    // Draw charts
    drawCharts();
    // Attach event listeners
    attachCanvasEvents(windCanvas);
    attachCanvasEvents(prodCanvas);
    attachCanvasEvents(tempCanvas);
  };

  window.hideCharts = function(){
    const modal = document.getElementById('chartModal');
    if(modal) modal.style.display = 'none';
  };

  function attachCanvasEvents(canvas){
    canvas.onmousemove = function(ev){
      const rect = canvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      updateCrosshairByPosition(x, canvas.width);
    };
    canvas.onmouseleave = function(){
      crosshairIndex = null;
      drawCharts();
      const infoEl = document.getElementById('crosshairInfo');
      if(infoEl) infoEl.textContent = '';
    };
  }

  function updateCrosshairByPosition(xPixel, canvasWidth){
    // compute index from xPixel relative to chart area
    // Assume paddingLeft = 40, paddingRight = 10
    const paddingLeft = 40;
    const paddingRight = 10;
    const chartWidth = canvasWidth - paddingLeft - paddingRight;
    const relative = (xPixel - paddingLeft) / chartWidth;
    let idx = Math.round(relative * (windData.length - 1));
    if (idx < 0) idx = 0;
    if (idx > windData.length - 1) idx = windData.length - 1;
    crosshairIndex = idx;
    drawCharts();
    // Update info overlay
    const infoEl = document.getElementById('crosshairInfo');
    if (infoEl && crosshairIndex !== null){
      const hhmm = hourLabels[crosshairIndex] || '';
      const wVal = windData[crosshairIndex];
      const pVal = prodData[crosshairIndex];
      const tVal = tempData[crosshairIndex];
      infoEl.textContent = hhmm + ' ‚á¢ ' +
        'ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ±Ÿäÿßÿ≠: ' + wVal + ' ' + windUnitLabel +
        ' | ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ ÿßŸÑŸÖÿ™ŸàŸÇÿπ: ' + pVal + ' ŸÖŸäÿ¨ÿßŸàÿßÿ™' +
        ' | ÿØÿ±ÿ¨ÿ© ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ©: ' + tVal + '¬∞ŸÖ';
    }
  }

  function drawCharts(){
    const windCanvas = document.getElementById('windChart');
    const prodCanvas = document.getElementById('prodChart');
    const tempCanvas = document.getElementById('tempChart');
    if(!windCanvas || !prodCanvas || !tempCanvas) return;
    // Draw each chart with appropriate color and unit label
    // Wind and production values are never negative, so force minimum to 0 to avoid negative axes
    drawChart(windCanvas, hourLabels, windData, 0, null, '#60a5fa', windUnitLabel);
    drawChart(prodCanvas, hourLabels, prodData, 0, null, '#10b981', 'ŸÖŸäÿ¨ÿßŸàÿßÿ™');
    // Temperature may be below zero; allow auto-scaling
    drawChart(tempCanvas, hourLabels, tempData, null, null, '#ef4444', '¬∞ŸÖ');
  }

  function drawChart(canvas, labels, dataArr, forcedMin, forcedMax, lineColor, unitLabel) {
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    // Paddings: more space on left for y-axis labels
    const paddingLeft = 60;
    const paddingRight = 10;
    const paddingTop = 20;
    const paddingBottom = 40;
    const chartW = width - paddingLeft - paddingRight;
    const chartH = height - paddingTop - paddingBottom;
    // Filter finite values
    const finiteVals = (dataArr || []).filter(v => Number.isFinite(v));
    // Determine data min and max; consider forced values if provided
    let dataMin = finiteVals.length ? Math.min(...finiteVals) : 0;
    let dataMax = finiteVals.length ? Math.max(...finiteVals) : 1;
    // Base min/max values from data or forced arguments
    let minVal = (forcedMin !== undefined && forcedMin !== null) ? forcedMin : dataMin;
    let maxVal = (forcedMax !== undefined && forcedMax !== null) ? forcedMax : dataMax;
    if (minVal === maxVal) {
      maxVal = minVal + 1;
    }
    // If no forced bounds, apply a margin to min/max to avoid clipping.  When
    // a forcedMin is provided, do not subtract margin below that floor.
    const rawRange = maxVal - minVal;
    const padRange = (rawRange * 0.08) || 1;
    if (forcedMin === undefined || forcedMin === null) {
      minVal -= padRange;
    }
    // Always add a margin on top unless forcedMax is provided
    if (forcedMax === undefined || forcedMax === null) {
      maxVal += padRange;
    }
    // Nice number helper to choose step size
    function niceNum(x, round) {
      const expv = Math.floor(Math.log10(x));
      const f = x / Math.pow(10, expv);
      let nf;
      if (round) {
        if (f < 1.5) nf = 1;
        else if (f < 3) nf = 2;
        else if (f < 7) nf = 5;
        else nf = 10;
      } else {
        if (f <= 1) nf = 1;
        else if (f <= 2) nf = 2;
        else if (f <= 5) nf = 5;
        else nf = 10;
      }
      return nf * Math.pow(10, expv);
    }
    const maxTicks = 6;
    const niceRange = niceNum(maxVal - minVal, false);
    const tickStep = niceNum(niceRange / (maxTicks - 1), true);
    const yMin = Math.floor(minVal / tickStep) * tickStep;
    const yMax = Math.ceil(maxVal / tickStep) * tickStep;
    const ticks = [];
    for (let v = yMin; v <= yMax + 1e-9; v += tickStep) {
      ticks.push(Number(v.toFixed(2)));
    }
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    // Force numbers to render left-to-right to avoid RTL digit reversal
    ctx.direction = 'ltr';
    // Draw horizontal grid lines and labels
    ctx.strokeStyle = '#e5e7eb';
    ctx.fillStyle = '#6b7280';
    ctx.lineWidth = 1;
    ctx.font = '11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ticks.forEach(t => {
      const ratio = (t - yMin) / (yMax - yMin);
      const y = paddingTop + chartH - ratio * chartH;
      // horizontal line
      ctx.beginPath();
      ctx.moveTo(paddingLeft, y);
      ctx.lineTo(paddingLeft + chartW, y);
      ctx.stroke();
      // tick label
      const lbl = Number.isInteger(t) ? t.toString() : t.toFixed(1);
      ctx.fillText(lbl, paddingLeft - 6, y);
    });
    // Draw rotated unit label on y-axis
    if (unitLabel) {
      ctx.save();
      ctx.translate(18, paddingTop + chartH / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      ctx.fillStyle = '#374151';
      ctx.font = '11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.fillText(unitLabel, 0, 0);
      ctx.restore();
    }
    // Draw x-axis baseline
    ctx.strokeStyle = '#d1d5db';
    ctx.beginPath();
    ctx.moveTo(paddingLeft, paddingTop + chartH);
    ctx.lineTo(paddingLeft + chartW, paddingTop + chartH);
    ctx.stroke();
    // Draw vertical grid lines and x-axis labels
    ctx.font = '11px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillStyle = '#6b7280';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    const tickInterval = 1;
    for (let i = 0; i < labels.length; i += tickInterval) {
      const x = paddingLeft + chartW * (i / (labels.length - 1 || 1));
      // vertical grid line
      ctx.strokeStyle = '#e5e7eb';
      ctx.beginPath();
      ctx.moveTo(x, paddingTop);
      ctx.lineTo(x, paddingTop + chartH);
      ctx.stroke();
      // label
      const lbl = labels[i] || '';
      ctx.fillStyle = '#6b7280';
      ctx.fillText(lbl, x, paddingTop + chartH + 6);
    }
    // Draw data line
    ctx.strokeStyle = lineColor || '#1f2937';
    ctx.lineWidth = 2.4;
    ctx.beginPath();
    dataArr.forEach((v, idx) => {
      const x = paddingLeft + chartW * (idx / (dataArr.length - 1 || 1));
      let y = paddingTop + chartH;
      if (Number.isFinite(v)) {
        const ratio = (v - yMin) / (yMax - yMin);
        y = paddingTop + chartH - ratio * chartH;
      }
      if (idx === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
    // Draw crosshair and highlight point if active
    if (crosshairIndex !== null) {
      const i = crosshairIndex;
      const x = paddingLeft + chartW * (i / (dataArr.length - 1 || 1));
      // vertical crosshair line
      ctx.strokeStyle = '#9ca3af';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, paddingTop);
      ctx.lineTo(x, paddingTop + chartH);
      ctx.stroke();
      // highlight point
      const v = dataArr[i];
      if (Number.isFinite(v)) {
        const ratio = (v - yMin) / (yMax - yMin);
        const y = paddingTop + chartH - ratio * chartH;
        ctx.fillStyle = lineColor || '#1f2937';
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Event delegation for chart button press.  Use pointerdown instead of click
  // because other handlers on click may stop propagation.  Pointer events
  // capture down events earlier and are less likely to be blocked.  The
  // handler uses capture phase for reliability.
  document.addEventListener('pointerdown', function(ev){
    const target = ev.target;
    if (!target) return;
    // locate nearest element with chart-btn class
    const btn = target.closest && target.closest('.chart-btn');
    if(btn){
      const idx = Number(btn.dataset.dayindex);
      if(!isNaN(idx)){
        // Stop other handlers from interfering
        if (typeof ev.stopImmediatePropagation === 'function') ev.stopImmediatePropagation();
        if (typeof ev.stopPropagation === 'function') ev.stopPropagation();
        ev.preventDefault();
        if (typeof window.showChartsForDay === 'function') {
          window.showChartsForDay(idx);
        } else {
          const modalEl = document.getElementById('chartModal');
          if (modalEl) modalEl.style.display = 'block';
        }
      }
    }
  }, true);

  // Attach download button handler once DOM is ready
  document.addEventListener('DOMContentLoaded', function(){
    const dBtn = document.getElementById('downloadChartBtn');
    if (dBtn) {
      dBtn.addEventListener('click', function(){
        downloadChartsAsImage();
      });
    }
    // Attach PDF download button handler
    const pdfBtn = document.getElementById('downloadChartPdfBtn');
    if (pdfBtn) {
      pdfBtn.addEventListener('click', function(){
        downloadChartsAsPDF();
      });
    }
  });

  /**
   * Combine the three chart canvases into a single image and trigger a download.
   * The resulting image will stack the charts vertically with their labels.
   */
  function downloadChartsAsImage(){
    const windCanvas = document.getElementById('windChart');
    const prodCanvas = document.getElementById('prodChart');
    const tempCanvas = document.getElementById('tempChart');
    if (!windCanvas || !prodCanvas || !tempCanvas) return;
    // Determine dimensions: use the maximum width among canvases
    const canvases = [windCanvas, prodCanvas, tempCanvas];
    const widths = canvases.map(c => c.width);
    const heights = canvases.map(c => c.height);
    const totalHeight = heights.reduce((a,b) => a + b, 0) + 40; // extra spacing for labels
    const maxWidth = Math.max(...widths);
    // Create offscreen canvas
    const off = document.createElement('canvas');
    off.width = maxWidth;
    off.height = totalHeight;
    const offCtx = off.getContext('2d');
    offCtx.fillStyle = '#ffffff';
    offCtx.fillRect(0, 0, off.width, off.height);
    let yOffset = 0;
    // Helper to draw each chart with its label
    function drawChartToOff(labelId, canvas){
      // draw label text above chart using default font
      const labelEl = document.getElementById(labelId);
      let text = labelEl ? labelEl.textContent || '' : '';
      offCtx.fillStyle = '#374151';
      offCtx.font = '12px sans-serif';
      offCtx.fillText(text, 10, yOffset + 12);
      // draw chart canvas below label
      offCtx.drawImage(canvas, 0, yOffset + 16);
      yOffset += canvas.height + 20; // 20px spacing including label
    }
    drawChartToOff('windLabel', windCanvas);
    drawChartToOff('prodLabel', prodCanvas);
    drawChartToOff('tempLabel', tempCanvas);
    // Create data URL and trigger download
    const dataURL = off.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'charts.png';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  /**
   * Generate a PDF containing the three charts on the first page and
   * a detailed hourly table on the second page.  The PDF is always
   * produced in English to avoid issues with Arabic fonts.  The table
   * layout and summary replicate the daily forecast PDF available
   * outside the modal.  The first page embeds the combined chart image
   * generated on the fly.
   */
  async function downloadChartsAsPDF(){
    // Ensure charts exist
    const windCanvas = document.getElementById('windChart');
    const prodCanvas = document.getElementById('prodChart');
    const tempCanvas = document.getElementById('tempChart');
    if (!windCanvas || !prodCanvas || !tempCanvas) return;
    // Determine active day index and forecast data
    const dayIndex = window._activeChartDayIndex;
    const store = window.__lastForecast;
    const data  = store && store.data;
    if (dayIndex == null || !data || !data.daily || !data.hourly) {
      alert('No forecast data available for PDF export.');
      return;
    }
    // Build an offscreen canvas to combine the three charts with their labels.
    const canvases = [windCanvas, prodCanvas, tempCanvas];
    const heights  = canvases.map(c => c.height);
    const widths   = canvases.map(c => c.width);
    const totalHeight = heights.reduce((a,b) => a + b, 0) + 60; // extra spacing for labels
    const maxWidth    = Math.max(...widths);
    const off = document.createElement('canvas');
    off.width  = maxWidth;
    off.height = totalHeight;
    const offCtx = off.getContext('2d');
    offCtx.fillStyle = '#ffffff';
    offCtx.fillRect(0,0,off.width,off.height);
    let yOffset = 20;
    function drawToOff(labelId, canvas){
      const labelEl = document.getElementById(labelId);
      const text = labelEl ? (labelEl.textContent || '') : '';
      offCtx.fillStyle = '#374151';
      offCtx.font = '12px sans-serif';
      offCtx.textAlign = 'left';
      offCtx.fillText(text, 10, yOffset + 12);
      offCtx.drawImage(canvas, 0, yOffset + 16);
      yOffset += canvas.height + 20;
    }
    drawToOff('windLabel', windCanvas);
    drawToOff('prodLabel', prodCanvas);
    drawToOff('tempLabel', tempCanvas);
    const chartImgData = off.toDataURL('image/png');
    // Create PDF
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF || !window.jspdf.jsPDF || !window.jspdf.jsPDF.API.autoTable) {
      alert('PDF library is not available.');
      return;
    }
    const doc = new jsPDF({orientation:'portrait', unit:'pt', format:'a4'});
    const pageWidth  = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin     = 40;
    // Determine scaling for the chart image to fit within page margins
    const imgMaxWidth  = pageWidth - margin * 2;
    const imgWidth  = Math.min(imgMaxWidth, off.width);
    const imgHeight = (imgWidth / off.width) * off.height;
    // Title for chart page
    let iso = '';
    if (data.daily.time && data.daily.time[dayIndex]) {
      iso = data.daily.time[dayIndex];
    } else if (window.__extendedDates && window.__extendedDates[dayIndex]) {
      iso = window.__extendedDates[dayIndex];
    }
    const dateStr = iso ? formatDate(iso,'en-GB') : '';
    const title = 'Daily Forecast Chart ‚Äì ' + (dateStr || '');
    doc.setFont('helvetica','bold');
    doc.setFontSize(14);
    doc.text(title, margin, margin + 10);
    // Draw image below title
    const yStart = margin + 30;
    doc.addImage(chartImgData, 'PNG', margin, yStart, imgWidth, imgHeight);
    // Add second page for table
    doc.addPage();
    // Compose header information (English)
    const locEn = store && store.locationLabelEN ? store.locationLabelEN : 'Ras Ghareb Wind Energy (RGWE)';
    doc.setFont('helvetica','bold').setFontSize(16);
    doc.text('Daily Forecast ‚Äì Expected Production (MW)', margin, 50);
    doc.setFont('helvetica','normal').setFontSize(11);
    if (locEn) doc.text(`Location: ${locEn}`, margin, 75);
    if (dateStr) doc.text(`Date: ${dateStr}`, margin, 95);
    // Build hourly rows for the table
    const hIdx = typeof hoursForDay === 'function' ? hoursForDay(dayIndex, data.hourly.time).slice(0,24) : [];
    const rows = [];
    let windSum = 0, tempSum = 0, prodSum = 0;
    hIdx.forEach(k => {
      const dt   = new Date(data.hourly.time[k]);
      const hour = dt.toLocaleTimeString('en-GB', { hour:'2-digit', minute:'2-digit' });
      // Determine wind speed (m/s) using convertToMs
      let wMs = 0;
      try{
        wMs = convertToMs(getWindArray(data)[k], store.windUnit || 'ms');
      }catch(_){ wMs = 0; }
      const T    = Number(data.hourly.temperature_2m && data.hourly.temperature_2m[k] || 0);
      // Calculate production using expectedProductionMWFromSheet if available
      let prodMW = 0;
      try{
        if (typeof expectedProductionMWFromSheet === 'function') {
          prodMW = expectedProductionMWFromSheet(wMs);
        } else if (typeof expectedProd === 'function') {
          prodMW = expectedProd(wMs);
        }
      }catch(_){ prodMW = 0; }
      windSum += wMs;
      tempSum += T;
      prodSum += prodMW;
      rows.push([
        hour,
        Number.isFinite(wMs) ? wMs.toFixed(1) : '',
        Number.isFinite(T) ? T.toFixed(1) : '',
        Number.isFinite(prodMW) ? prodMW.toFixed(3) : ''
      ]);
    });
    // Render table using autoTable
    doc.autoTable({
      startY: 120,
      styles: { font: 'helvetica', fontSize: 10, cellPadding: 6, halign: 'center' },
      headStyles: { fillColor: [243,244,246], textColor: 20 },
      head: [['Hour','Wind Speed (m/s)','Temperature (¬∞C)','Expected Production (MW)']],
      body: rows
    });
    const yPos = doc.lastAutoTable && doc.lastAutoTable.finalY ? doc.lastAutoTable.finalY : 120;
    // Summary section
    const avgWind = hIdx.length ? windSum / hIdx.length : 0;
    const avgTemp = hIdx.length ? tempSum / hIdx.length : 0;
    doc.setFont('helvetica','bold');
    doc.text('Summary', margin, yPos + 30);
    doc.setFont('helvetica','normal');
    doc.text(`Average wind speed (m/s): ${avgWind.toFixed(2)}`, margin, yPos + 50);
    doc.text(`Average temperature (¬∞C): ${avgTemp.toFixed(2)}`, margin, yPos + 70);
    doc.text(`Total expected production (MW): ${prodSum.toFixed(3)}`, margin, yPos + 90);
    // Save file with date
    const fileName = iso ? `Forecast_${iso}_with_chart.pdf` : 'Forecast_chart.pdf';
    doc.save(fileName);
  }

})();
</script>
<!-- Extended PDF/Excel generation for 30-day forecast -->
<script id="rgwe-extended-export">
(function(){
  /**
   * Generate an extended PDF covering up to 30 days using daily averages and expected production.
   * This replicates the last available day's data for days beyond the available forecast range.
   * @param {object} data Forecast data (window.__lastForecast.data)
   * @param {number[]} indices Array of daily indices (length up to 30) mapping each ext day to an index in data.daily. Extra days map to last index.
   * @param {string} windUnitUI The current wind speed unit (ms, kmh, mph, kn)
   */
  function generateExtendedPDF(data, indices, windUnitUI){
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF || !window.jspdf.jsPDF || !window.jspdf.jsPDF.API.autoTable) {
      alert(document.documentElement.lang === 'en' ? 'PDF library not available' : 'ŸÖŸÉÿ™ÿ®ÿ© PDF ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©');
      return;
    }
    if (!data || !data.daily || !data.hourly) {
      alert(document.documentElement.lang === 'en' ? 'No forecast data available.' : 'ŸÑÿß ÿ™ÿ™ŸàŸÅÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ŸÜÿ®ÿ§.');
      return;
    }
    const extDates = window.__extendedDates || [];
    if (!Array.isArray(extDates) || extDates.length === 0){
      alert(document.documentElement.lang === 'en' ? 'No extended data to export.' : 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ŸàŸÇÿπ ÿßŸÑŸÖŸÖÿ™ÿØ ŸÑŸÑÿ™ÿµÿØŸäÿ±.');
      return;
    }
    // Determine original forecast length (e.g. 16 days)
    const baseLen = Array.isArray(data.daily.time) ? data.daily.time.length : 0;
    const totalDays = extDates.length;
    // Compute daily average wind speed and temperature for base days
    const avgWBase = [];
    const avgTBase = [];
    for(let i=0; i<baseLen; i++){
      const hoursIdx = (typeof hoursForDay === 'function') ? hoursForDay(i, data.hourly.time).slice(0,24) : [];
      let wSum=0, tSum=0, prodSum=0, cnt=0;
      hoursIdx.forEach(function(k){
        const windArr = (typeof getWindArray === 'function') ? getWindArray(data) : (data.hourly.wind_speed_10m || []);
        const wVal = Array.isArray(windArr) ? windArr[k] : NaN;
        const wMs  = (typeof convertToMs === 'function') ? convertToMs(wVal, windUnitUI) : NaN;
        const T    = data.hourly.temperature_2m && data.hourly.temperature_2m[k];
        if (Number.isFinite(wMs)) { wSum += wMs; }
        if (Number.isFinite(T))  { tSum += T; }
        cnt++;
      });
      const avgW = cnt ? (wSum / cnt) : 0;
      const avgT = cnt ? (tSum / cnt) : 0;
      avgWBase.push(avgW);
      avgTBase.push(avgT);
    }
    // Helper functions for mean and std
    function mean(arr){ let s=0,n=0; arr.forEach(v=>{ if(Number.isFinite(v)){ s+=v; n++; } }); return n? s/n : 0; }
    function std(arr, m){ let s=0,n=0; arr.forEach(v=>{ if(Number.isFinite(v)){ s += Math.pow(v-m,2); n++; } }); return n? Math.sqrt(s/n) : 0; }
    // Compute means and stds of metrics across base days
    const tmaxList = data.daily.temperature_2m_max || [];
    const tminList = data.daily.temperature_2m_min || [];
    const wmaxList = data.daily.wind_speed_10m_max || [];
    const gmaxList = data.daily.wind_gusts_10m_max || [];
    const meanTmax = mean(tmaxList);
    const meanTmin = mean(tminList);
    const meanWmax = mean(wmaxList);
    const meanGmax = mean(gmaxList);
    const meanAvgW = mean(avgWBase);
    const meanAvgT = mean(avgTBase);
    const stdTmax  = std(tmaxList, meanTmax);
    const stdTmin  = std(tminList, meanTmin);
    const stdWmax  = std(wmaxList, meanWmax);
    const stdGmax  = std(gmaxList, meanGmax);
    const stdAvgW  = std(avgWBase, meanAvgW);
    const stdAvgT  = std(avgTBase, meanAvgT);
    // Last available direction and weather code
    const lastDir  = (data.daily.wind_direction_10m_dominant && data.daily.wind_direction_10m_dominant[baseLen-1]) || null;
    const lastCode = (data.daily.weathercode && data.daily.weathercode[baseLen-1]) || null;
    // Prepare PDF
    const doc = new jsPDF({orientation:'portrait', unit:'pt', format:'a4'});
    const margin = 40;
    // Header (logo optional)
    try{
      var logo = typeof LOGO_DATA_URL !== 'undefined' ? LOGO_DATA_URL : (window.LOGO_DATA_URL || '');
      if (logo){
        const type = logo.indexOf('image/jpeg') > -1 ? 'JPEG' : 'PNG';
        const pageW = doc.internal.pageSize.getWidth();
        const logoW = 140, logoH = 40;
        doc.addImage(logo, type, pageW - margin - logoW, 25, logoW, logoH);
      }
    }catch(e){ console.warn('extended logo error', e); }
    // Title
    doc.setFont('helvetica','bold').setFontSize(16);
    doc.text('30‚ÄëDay Extended Forecast ‚Äì Expected Production (MW)', margin, 50);
    doc.setFont('helvetica','normal').setFontSize(11);
    // Location and period
    const locLabel = 'Ras Ghareb Wind Energy (RGWE)';
    const startISO = extDates[0];
    const endISO   = extDates[extDates.length - 1];
    const startDateObj = new Date(startISO + 'T00:00:00');
    const endDateObj   = new Date(endISO   + 'T00:00:00');
    const periodStr = `${startDateObj.toLocaleDateString('en-GB',{day:'numeric', month:'long'})} ‚Üí ${endDateObj.toLocaleDateString('en-GB',{day:'numeric', month:'long'})}`;
    doc.text('Location: ' + locLabel, margin, 75);
    doc.text('Period: ' + periodStr, margin, 95);
    // Build table rows
    const bodyRows = [];
    let totWind = 0, totTemp = 0, totProd = 0, nDays = 0;
    // Cache last actual values for trending
    const lastTmax = tmaxList[baseLen-1];
    const lastTmin = tminList[baseLen-1];
    const lastWmax = wmaxList[baseLen-1];
    const lastGmax = gmaxList[baseLen-1];
    const lastAvgW = avgWBase[baseLen-1];
    const lastAvgT = avgTBase[baseLen-1];
    // Determine amplitude fallback for extended variation
    const ampTmaxPDF = (Number.isFinite(stdTmax) && stdTmax > 0) ? stdTmax : (Number.isFinite(meanTmax) ? Math.abs(meanTmax) * 0.1 : 0);
    const ampTminPDF = (Number.isFinite(stdTmin) && stdTmin > 0) ? stdTmin : (Number.isFinite(meanTmin) ? Math.abs(meanTmin) * 0.1 : 0);
    const ampWmaxPDF = (Number.isFinite(stdWmax) && stdWmax > 0) ? stdWmax : (Number.isFinite(meanWmax) ? Math.abs(meanWmax) * 0.1 : 0);
    const ampGmaxPDF = (Number.isFinite(stdGmax) && stdGmax > 0) ? stdGmax : (Number.isFinite(meanGmax) ? Math.abs(meanGmax) * 0.1 : 0);
    const ampAvgWPDF = (Number.isFinite(stdAvgW) && stdAvgW > 0) ? stdAvgW : (Number.isFinite(meanAvgW) ? Math.abs(meanAvgW) * 0.1 : 0);
    const ampAvgTPDF = (Number.isFinite(stdAvgT) && stdAvgT > 0) ? stdAvgT : (Number.isFinite(meanAvgT) ? Math.abs(meanAvgT) * 0.1 : 0);
    for (let i=0; i<totalDays; i++){
      const dateISO = extDates[i];
      if (i < baseLen){
        // Actual day: compute using hourly data
        const hoursIdx = (typeof hoursForDay === 'function') ? hoursForDay(i, data.hourly.time).slice(0,24) : [];
        let wSum=0, tSum=0, prodSum=0, cnt=0;
        hoursIdx.forEach(function(k){
          const windArr = (typeof getWindArray === 'function') ? getWindArray(data) : (data.hourly.wind_speed_10m || []);
          const wVal = Array.isArray(windArr) ? windArr[k] : NaN;
          const wMs  = (typeof convertToMs === 'function') ? convertToMs(wVal, windUnitUI) : NaN;
          const T    = data.hourly.temperature_2m && data.hourly.temperature_2m[k];
          const prod = (typeof expectedProductionMWFromSheet === 'function') ? expectedProductionMWFromSheet(wMs) : 0;
          if (Number.isFinite(wMs)) { wSum += wMs; }
          if (Number.isFinite(T))  { tSum += T; }
          if (Number.isFinite(prod)) { prodSum += prod; }
          cnt++;
        });
        const avgW = cnt ? (wSum/cnt) : 0;
        const avgT = cnt ? (tSum/cnt) : 0;
        const prodMW = prodSum;
        const tMax = (data.daily.temperature_2m_max && data.daily.temperature_2m_max[i]) || '';
        const tMin = (data.daily.temperature_2m_min && data.daily.temperature_2m_min[i]) || '';
        const maxWind = (data.daily.wind_speed_10m_max && data.daily.wind_speed_10m_max[i]) || '';
        const maxGust= (data.daily.wind_gusts_10m_max && data.daily.wind_gusts_10m_max[i]) || '';
        const dirDeg = (data.daily.wind_direction_10m_dominant && data.daily.wind_direction_10m_dominant[i]);
        const dirStr = (typeof window.degToDirection === 'function') ? window.degToDirection(dirDeg, 'en') : '';
        bodyRows.push([
          dateISO,
          Number.isFinite(tMax) ? Number(tMax).toFixed(2) : '',
          Number.isFinite(tMin) ? Number(tMin).toFixed(2) : '',
          avgT.toFixed(2),
          Number.isFinite(maxWind) ? Number(maxWind).toFixed(2) : '',
          Number.isFinite(maxGust) ? Number(maxGust).toFixed(2) : '',
          avgW.toFixed(2),
          dirStr,
          prodMW.toFixed(3)
        ]);
        totWind += avgW;
        totTemp += avgT;
        totProd += prodMW;
        nDays++;
      } else {
        // Estimated day: trend from last actual toward mean with sinusoidal variation
        const j = i - baseLen;
        const span = totalDays - baseLen;
        const r = (span > 1) ? (j / (span - 1)) : 0;
        const sinFactor = Math.sin(r * Math.PI);
        // Compute each metric with trending
        let estTmax = null;
        if (Number.isFinite(meanTmax) && Number.isFinite(lastTmax)){
          const delta = lastTmax - meanTmax;
          estTmax = meanTmax + delta * (1 - r) + sinFactor * ampTmaxPDF;
        } else if (Number.isFinite(meanTmax)) {
          estTmax = meanTmax + sinFactor * ampTmaxPDF;
        } else if (Number.isFinite(lastTmax)) {
          estTmax = lastTmax;
        }
        let estTmin = null;
        if (Number.isFinite(meanTmin) && Number.isFinite(lastTmin)){
          const delta = lastTmin - meanTmin;
          estTmin = meanTmin + delta * (1 - r) + sinFactor * ampTminPDF;
        } else if (Number.isFinite(meanTmin)) {
          estTmin = meanTmin + sinFactor * ampTminPDF;
        } else if (Number.isFinite(lastTmin)) {
          estTmin = lastTmin;
        }
        let estWmax = null;
        if (Number.isFinite(meanWmax) && Number.isFinite(lastWmax)){
          const delta = lastWmax - meanWmax;
          estWmax = meanWmax + delta * (1 - r) + sinFactor * ampWmaxPDF;
        } else if (Number.isFinite(meanWmax)) {
          estWmax = meanWmax + sinFactor * ampWmaxPDF;
        } else if (Number.isFinite(lastWmax)) {
          estWmax = lastWmax;
        }
        let estGmax = null;
        if (Number.isFinite(meanGmax) && Number.isFinite(lastGmax)){
          const delta = lastGmax - meanGmax;
          estGmax = meanGmax + delta * (1 - r) + sinFactor * ampGmaxPDF;
        } else if (Number.isFinite(meanGmax)) {
          estGmax = meanGmax + sinFactor * ampGmaxPDF;
        } else if (Number.isFinite(lastGmax)) {
          estGmax = lastGmax;
        }
        // Average temp and wind trending with fallbacks
        let estAvgT = null;
        if (Number.isFinite(meanAvgT) && Number.isFinite(lastAvgT)){
          const delta = lastAvgT - meanAvgT;
          estAvgT = meanAvgT + delta * (1 - r) + sinFactor * ampAvgTPDF;
        } else if (Number.isFinite(meanAvgT)) {
          estAvgT = meanAvgT + sinFactor * ampAvgTPDF;
        } else if (Number.isFinite(lastAvgT)) {
          estAvgT = lastAvgT;
        }
        let estAvgW = null;
        if (Number.isFinite(meanAvgW) && Number.isFinite(lastAvgW)){
          const delta = lastAvgW - meanAvgW;
          estAvgW = meanAvgW + delta * (1 - r) + sinFactor * ampAvgWPDF;
        } else if (Number.isFinite(meanAvgW)) {
          estAvgW = meanAvgW + sinFactor * ampAvgWPDF;
        } else if (Number.isFinite(lastAvgW)) {
          estAvgW = lastAvgW;
        }
        // Compute expected production using per-hour production times 24 hours
        const prodPerHour = (typeof expectedProductionMWFromSheet === 'function') ? expectedProductionMWFromSheet(estAvgW) : 0;
        const estProd = prodPerHour * 24;
        const dirStr = (typeof window.degToDirection === 'function') ? window.degToDirection(lastDir, 'en') : '';
        bodyRows.push([
          dateISO,
          Number.isFinite(estTmax) ? estTmax.toFixed(2) : '',
          Number.isFinite(estTmin) ? estTmin.toFixed(2) : '',
          Number.isFinite(estAvgT) ? estAvgT.toFixed(2) : '',
          Number.isFinite(estWmax) ? estWmax.toFixed(2) : '',
          Number.isFinite(estGmax) ? estGmax.toFixed(2) : '',
          Number.isFinite(estAvgW) ? estAvgW.toFixed(2) : '',
          dirStr,
          Number.isFinite(estProd) ? estProd.toFixed(3) : ''
        ]);
        if (Number.isFinite(estAvgW)) totWind += estAvgW;
        if (Number.isFinite(estAvgT)) totTemp += estAvgT;
        if (Number.isFinite(estProd)) totProd += estProd;
        nDays++;
      }
    }
    // Build table using autoTable
    doc.autoTable({
      startY: 120,
      styles: { font:'helvetica', fontSize: 10, cellPadding: 5, halign:'center' },
      headStyles: { fillColor: [243,244,246], textColor: 20 },
      head: [[ 'Date','Tmax (¬∞C)','Tmin (¬∞C)','Avg Temp (¬∞C)','Max Wind (m/s)','Max Gust (m/s)','Avg Wind (m/s)','Dominant Dir','Expected Prod (MW)' ]],
      body: bodyRows
    });
    // Summary section
    const summaryStartY = doc.autoTable.previous.finalY + 20;
    doc.setFont('helvetica','bold').setFontSize(12);
    doc.text('Summary', margin, summaryStartY);
    doc.setFont('helvetica','normal').setFontSize(10);
    if (nDays){
      const avgWindOverall = (totWind / nDays).toFixed(2);
      const avgTempOverall = (totTemp / nDays).toFixed(2);
      const totalProd      = totProd.toFixed(3);
      const lines = [
        `Average wind speed (m/s): ${avgWindOverall}`,
        `Average temperature (¬∞C): ${avgTempOverall}`,
        `Total expected production (MW): ${totalProd}`
      ];
      let y = summaryStartY + 15;
      lines.forEach(function(l){ doc.text(l, margin, y); y += 15; });
    }
    const fName = `Extended_30day_${startISO}_to_${endISO}.pdf`;
    doc.save(fName);
  }

  /**
   * Export the extended forecast as an Excel file with one sheet.
   * Columns: Date, Average wind speed (m/s), Average temperature (¬∞C), Expected production (MW)
   * @param {object} data Forecast data
   * @param {number[]} indices Extended indices mapping to data.daily (last index replicated)
   * @param {string} windUnitUI Wind speed unit (ms, kmh, mph, kn)
   */
  function exportExtendedExcel(data, indices, windUnitUI){
    if (!window.XLSX || !XLSX.utils || !XLSX.writeFile){
      alert(document.documentElement.lang === 'en' ? 'Excel library not available' : 'ŸÖŸÉÿ™ÿ®ÿ© Excel ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©');
      return;
    }
    const extDates = window.__extendedDates || [];
    if (!data || !data.daily || !data.hourly || !Array.isArray(extDates) || extDates.length === 0){
      alert(document.documentElement.lang === 'en' ? 'No extended data to export.' : 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ŸàŸÇÿπ ÿßŸÑŸÖŸÖÿ™ÿØ ŸÑŸÑÿ™ÿµÿØŸäÿ±.');
      return;
    }
    const baseLen = Array.isArray(data.daily.time) ? data.daily.time.length : 0;
    const totalDays = extDates.length;
    // Compute daily average wind speed and temperature for base days
    const avgWBase = [];
    const avgTBase = [];
    for(let i=0; i<baseLen; i++){
      const hoursIdx = (typeof hoursForDay === 'function') ? hoursForDay(i, data.hourly.time).slice(0,24) : [];
      let wSum=0, tSum=0, cnt=0;
      hoursIdx.forEach(function(k){
        const windArr = (typeof getWindArray === 'function') ? getWindArray(data) : (data.hourly.wind_speed_10m || []);
        const wVal = Array.isArray(windArr) ? windArr[k] : NaN;
        const wMs  = (typeof convertToMs === 'function') ? convertToMs(wVal, windUnitUI) : NaN;
        const T    = data.hourly.temperature_2m && data.hourly.temperature_2m[k];
        if (Number.isFinite(wMs)) { wSum += wMs; }
        if (Number.isFinite(T))  { tSum += T; }
        cnt++;
      });
      const avgW = cnt ? (wSum / cnt) : 0;
      const avgT = cnt ? (tSum / cnt) : 0;
      avgWBase.push(avgW);
      avgTBase.push(avgT);
    }
    // Helper functions
    function mean(arr){ let s=0,n=0; arr.forEach(v=>{ if(Number.isFinite(v)){ s+=v; n++; } }); return n? s/n : 0; }
    function std(arr, m){ let s=0,n=0; arr.forEach(v=>{ if(Number.isFinite(v)){ s += Math.pow(v-m,2); n++; } }); return n? Math.sqrt(s/n) : 0; }
    // Compute means and stds
    const tmaxList = data.daily.temperature_2m_max || [];
    const tminList = data.daily.temperature_2m_min || [];
    const wmaxList = data.daily.wind_speed_10m_max || [];
    const gmaxList = data.daily.wind_gusts_10m_max || [];
    const meanTmax = mean(tmaxList);
    const meanTmin = mean(tminList);
    const meanWmax = mean(wmaxList);
    const meanGmax = mean(gmaxList);
    const meanAvgW = mean(avgWBase);
    const meanAvgT = mean(avgTBase);
    const stdTmax  = std(tmaxList, meanTmax);
    const stdTmin  = std(tminList, meanTmin);
    const stdWmax  = std(wmaxList, meanWmax);
    const stdGmax  = std(gmaxList, meanGmax);
    const stdAvgW  = std(avgWBase, meanAvgW);
    const stdAvgT  = std(avgTBase, meanAvgT);
    // Last direction for extended days (not used in Excel since we don't output direction)
    // Build rows
    const rows = [];
    const year = (new Date(extDates[0] + 'T00:00:00')).getFullYear();
    rows.push([`Forecasted Output Of The Facility, RGWE ${year}`, '', '', '']);
    rows.push(['Date','Average wind speed, m/s','Average temperature, ¬∞C','Expected production, MW']);
    // Cache last actual average wind and temperature for trending
    const lastAvgWExcel = avgWBase[baseLen-1];
    const lastAvgTExcel = avgTBase[baseLen-1];
    // Determine amplitude fallback for averages
    const ampAvgWExcel = (Number.isFinite(stdAvgW) && stdAvgW > 0) ? stdAvgW : (Number.isFinite(meanAvgW) ? Math.abs(meanAvgW) * 0.1 : 0);
    const ampAvgTExcel = (Number.isFinite(stdAvgT) && stdAvgT > 0) ? stdAvgT : (Number.isFinite(meanAvgT) ? Math.abs(meanAvgT) * 0.1 : 0);
    for(let i=0; i<totalDays; i++){
      const dateISO = extDates[i];
      if (i < baseLen){
        const hoursIdx = (typeof hoursForDay === 'function') ? hoursForDay(i, data.hourly.time).slice(0,24) : [];
        let wSum=0, tSum=0, prodSum=0, cnt=0;
        hoursIdx.forEach(function(k){
          const windArr = (typeof getWindArray === 'function') ? getWindArray(data) : (data.hourly.wind_speed_10m || []);
          const wVal = Array.isArray(windArr) ? windArr[k] : NaN;
          const wMs  = (typeof convertToMs === 'function') ? convertToMs(wVal, windUnitUI) : NaN;
          const T    = data.hourly.temperature_2m && data.hourly.temperature_2m[k];
          const prod = (typeof expectedProductionMWFromSheet === 'function') ? expectedProductionMWFromSheet(wMs) : 0;
          if (Number.isFinite(wMs)) { wSum += wMs; }
          if (Number.isFinite(T))  { tSum += T; }
          if (Number.isFinite(prod)) { prodSum += prod; }
          cnt++;
        });
        const avgW = cnt ? (wSum / cnt) : 0;
        const avgT = cnt ? (tSum / cnt) : 0;
        const prodTot = prodSum;
        rows.push([
          dateISO,
          +(avgW.toFixed(2)),
          +(avgT.toFixed(2)),
          +(prodTot.toFixed(3))
        ]);
      } else {
        const j = i - baseLen;
        const span = totalDays - baseLen;
        const r = (span > 1) ? (j / (span - 1)) : 0;
        const sinFactor = Math.sin(r * Math.PI);
        // Trend avg wind and temperature from last values toward mean with sinusoidal variation
        // Trending with fallbacks
        let estAvgW = null;
        if (Number.isFinite(meanAvgW) && Number.isFinite(lastAvgWExcel)){
          const delta = lastAvgWExcel - meanAvgW;
          estAvgW = meanAvgW + delta * (1 - r) + sinFactor * ampAvgWExcel;
        } else if (Number.isFinite(meanAvgW)) {
          estAvgW = meanAvgW + sinFactor * ampAvgWExcel;
        } else if (Number.isFinite(lastAvgWExcel)) {
          estAvgW = lastAvgWExcel;
        }
        let estAvgT = null;
        if (Number.isFinite(meanAvgT) && Number.isFinite(lastAvgTExcel)){
          const delta = lastAvgTExcel - meanAvgT;
          estAvgT = meanAvgT + delta * (1 - r) + sinFactor * ampAvgTExcel;
        } else if (Number.isFinite(meanAvgT)) {
          estAvgT = meanAvgT + sinFactor * ampAvgTExcel;
        } else if (Number.isFinite(lastAvgTExcel)) {
          estAvgT = lastAvgTExcel;
        }
        const prodPerHour = (typeof expectedProductionMWFromSheet === 'function') ? expectedProductionMWFromSheet(estAvgW) : 0;
        const estProd = prodPerHour * 24;
        rows.push([
          dateISO,
          +(Number.isFinite(estAvgW) ? estAvgW.toFixed(2) : ''),
          +(Number.isFinite(estAvgT) ? estAvgT.toFixed(2) : ''),
          +(Number.isFinite(estProd) ? estProd.toFixed(3) : '')
        ]);
      }
    }
    // Create workbook and sheet
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    // Merge title row
    if (!ws['!merges']) ws['!merges'] = [];
    ws['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 3 } });
    // Style: thick borders and alignment
    const thick = { style:'thick', color:{ rgb:'000000' } };
    const nRows = rows.length;
    const nCols = 4;
    for (let r = 0; r < nRows; r++){
      for (let c = 0; c < nCols; c++){
        const addr = XLSX.utils.encode_cell({ r, c });
        if (!ws[addr]) ws[addr] = { v:'' };
        ws[addr].s = ws[addr].s || {};
        ws[addr].s.border = { top: thick, bottom: thick, left: thick, right: thick };
        const val = ws[addr].v;
        const isNumeric = (typeof val === 'number') || (typeof val === 'string' && val.trim() !== '' && !isNaN(Number(val)));
        const isDate = (typeof val === 'string') && /^\d{4}-\d{2}-\d{2}$/.test(val.trim());
        if (isNumeric || isDate){
          ws[addr].s.alignment = Object.assign({}, ws[addr].s.alignment || {}, { horizontal:'center', vertical:'center' });
        }
        if (r === 0){
          ws[addr].s.font = Object.assign({}, ws[addr].s.font || {}, { bold:true, sz:14 });
          ws[addr].s.alignment = { horizontal:'center', vertical:'center' };
        }
        if (r === 1){
          ws[addr].s.font = Object.assign({}, ws[addr].s.font || {}, { bold:true });
        }
      }
    }
    XLSX.utils.book_append_sheet(wb, ws, 'Extended');
    const fname = `Extended_30day_${extDates[0]}_to_${extDates[extDates.length - 1]}.xlsx`;
    XLSX.writeFile(wb, fname);
  }
  // Attach functions to window
  window.generateExtendedPDF  = generateExtendedPDF;
  window.exportExtendedExcel  = exportExtendedExcel;
  // Attach click listeners after DOM ready
  document.addEventListener('DOMContentLoaded', function(){
    const epdfBtn = document.getElementById('extendedPdfBtn');
    if (epdfBtn){
      epdfBtn.addEventListener('click', function(){
        const data = window.__lastForecast && window.__lastForecast.data;
        const indices = window.__extendedIndices;
        const windUnitUI = window.__lastForecast && window.__lastForecast.windUnit;
        if (!data || !indices || !Array.isArray(indices)) {
          alert(document.documentElement.lang === 'en' ? 'No data to export yet.' : 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ÿµÿØŸäÿ± ÿ®ÿπÿØ.');
          return;
        }
        if (typeof window.generateExtendedPDF === 'function') {
          window.generateExtendedPDF(data, indices, windUnitUI);
        } else {
          alert(document.documentElement.lang === 'en' ? 'Extended PDF generator not available.' : 'ÿØÿßŸÑÿ© ÿ™ŸàŸÑŸäÿØ PDF ŸÑŸÑÿ™ŸàŸÇÿπ ÿßŸÑŸÖŸÖÿ™ÿØ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©.');
        }
      });
    }
    const exlsBtn = document.getElementById('extendedXlsBtn');
    if (exlsBtn){
      exlsBtn.addEventListener('click', function(){
        const data = window.__lastForecast && window.__lastForecast.data;
        const indices = window.__extendedIndices;
        const windUnitUI = window.__lastForecast && window.__lastForecast.windUnit;
        if (!data || !indices || !Array.isArray(indices)) {
          alert(document.documentElement.lang === 'en' ? 'No data to export yet.' : 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ÿµÿØŸäÿ± ÿ®ÿπÿØ.');
          return;
        }
        if (typeof window.exportExtendedExcel === 'function') {
          window.exportExtendedExcel(data, indices, windUnitUI);
        } else {
          alert(document.documentElement.lang === 'en' ? 'Extended Excel exporter not available.' : 'ÿØÿßŸÑÿ© ÿ™ÿµÿØŸäÿ± Excel ŸÑŸÑÿ™ŸàŸÇÿπ ÿßŸÑŸÖŸÖÿ™ÿØ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©.');
        }
      });
    }
  });
})();
</script>

<!-- Extended forecast (30-day) handling -->
<script id="rgwe-extended-forecast">
(function(){
  // Immediately invoked function to encapsulate extended forecast logic
  document.addEventListener('DOMContentLoaded', function(){
    const extendedSection = document.getElementById('extendedSection');
    const extendedBody    = document.getElementById('extendedBody');
    const extendedRangeEl = document.getElementById('extendedRange');
    const extendedNoteEl  = document.getElementById('extendedNote');
    const tabExtendedBtn  = document.getElementById('tabExtendedBtn');
    // Even if extendedSection or its elements are missing (extended UI removed), we still define
    // fetchExtendedForecast and helper functions. Do not return early here.

    // Weather code descriptions copied from monthly script for independence
    const descAr = {"0":"ÿµÿ≠Ÿà","1":"ÿµÿ≠Ÿà ÿ∫ÿßŸÑÿ®Ÿãÿß","2":"ÿ∫ÿßÿ¶ŸÖ ÿ¨ÿ≤ÿ¶ŸäŸãÿß","3":"ÿ∫ÿßÿ¶ŸÖ","45":"ÿ∂ÿ®ÿßÿ®","48":"ÿ∂ÿ®ÿßÿ® ŸÖÿ¨ŸÖÿØ","51":"ÿ±ÿ∞ÿßÿ∞ ÿÆŸÅŸäŸÅ","53":"ÿ±ÿ∞ÿßÿ∞ ŸÖÿ™Ÿàÿ≥ÿ∑","55":"ÿ±ÿ∞ÿßÿ∞ ŸÉÿ´ŸäŸÅ","56":"ÿ±ÿ∞ÿßÿ∞ ŸÖÿ¨ŸÖÿØ ÿÆŸÅŸäŸÅ","57":"ÿ±ÿ∞ÿßÿ∞ ŸÖÿ¨ŸÖÿØ ŸÉÿ´ŸäŸÅ","61":"ÿ£ŸÖÿ∑ÿßÿ± ÿÆŸÅŸäŸÅÿ©","63":"ÿ£ŸÖÿ∑ÿßÿ± ŸÖÿπÿ™ÿØŸÑÿ©","65":"ÿ£ŸÖÿ∑ÿßÿ± ÿ∫ÿ≤Ÿäÿ±ÿ©","66":"ÿ£ŸÖÿ∑ÿßÿ± ŸÖÿ™ÿ¨ŸÖÿØÿ© ÿÆŸÅŸäŸÅÿ©","67":"ÿ£ŸÖÿ∑ÿßÿ± ŸÖÿ™ÿ¨ŸÖÿØÿ© ÿ∫ÿ≤Ÿäÿ±ÿ©","71":"ÿ´ŸÑŸàÿ¨ ÿÆŸÅŸäŸÅÿ©","73":"ÿ´ŸÑŸàÿ¨ ŸÖÿπÿ™ÿØŸÑÿ©","75":"ÿ´ŸÑŸàÿ¨ ŸÉÿ´ŸäŸÅÿ©","77":"ÿ≠ÿ®Ÿäÿ®ÿßÿ™ ÿ´ŸÑÿ¨","80":"ÿ≤ÿÆÿßÿ™ ÿ£ŸÖÿ∑ÿßÿ± ÿÆŸÅŸäŸÅÿ©","81":"ÿ≤ÿÆÿßÿ™ ÿ£ŸÖÿ∑ÿßÿ± ŸÖÿ™Ÿàÿ≥ÿ∑ÿ©","82":"ÿ≤ÿÆÿßÿ™ ÿ£ŸÖÿ∑ÿßÿ± ÿ∫ÿ≤Ÿäÿ±ÿ©","85":"ÿ≤ÿÆÿßÿ™ ÿ´ŸÑŸàÿ¨ ÿÆŸÅŸäŸÅÿ©","86":"ÿ≤ÿÆÿßÿ™ ÿ´ŸÑŸàÿ¨ ÿ∫ÿ≤Ÿäÿ±ÿ©","95":"ÿπŸàÿßÿµŸÅ ÿ±ÿπÿØŸäÿ©","96":"ÿπŸàÿßÿµŸÅ ÿ±ÿπÿØŸäÿ© ŸÖÿπ ÿ®ÿ±ÿØ","99":"ÿπŸàÿßÿµŸÅ ÿ±ÿπÿØŸäÿ© ŸÇŸàŸäÿ© ŸÖÿπ ÿ®ÿ±ÿØ"};
    const descEn = {"0":"Clear","1":"Mainly clear","2":"Partly cloudy","3":"Overcast","45":"Fog","48":"Rime fog","51":"Light drizzle","53":"Moderate drizzle","55":"Dense drizzle","56":"Light freezing drizzle","57":"Dense freezing drizzle","61":"Slight rain","63":"Moderate rain","65":"Heavy rain","66":"Light freezing rain","67":"Heavy freezing rain","71":"Slight snow","73":"Moderate snow","75":"Heavy snow","77":"Snow grains","80":"Slight rain showers","81":"Moderate rain showers","82":"Violent rain showers","85":"Slight snow showers","86":"Heavy snow showers","95":"Thunderstorm","96":"Thunderstorm with slight hail","99":"Thunderstorm with heavy hail"};
    function weatherDesc(code, lang){
      const m = lang === 'en' ? descEn : descAr;
      return m[String(code)] || '';
    }
    // Convert degrees to cardinal direction (copy of monthly degToDirection) but using global if available
    function degToDir(deg, lang){
      if (!Number.isFinite(deg)) return '';
      const dirsEn = ['N','NE','E','SE','S','SW','W','NW'];
      const dirsAr = ['ÿ¥ŸÖÿßŸÑ','ÿ¥ŸÖÿßŸÑ ÿ¥ÿ±ŸÇŸä','ÿ¥ÿ±ŸÇ','ÿ¨ŸÜŸàÿ® ÿ¥ÿ±ŸÇŸä','ÿ¨ŸÜŸàÿ®','ÿ¨ŸÜŸàÿ® ÿ∫ÿ±ÿ®Ÿä','ÿ∫ÿ±ÿ®','ÿ¥ŸÖÿßŸÑ ÿ∫ÿ±ÿ®Ÿä'];
      const dirs = lang === 'en' ? dirsEn : dirsAr;
      const idx  = Math.round((((deg % 360) + 360) / 45)) % 8;
      return dirs[idx];
    }
    // Fetch 16-day forecast then extend to 30 days by repeating last day's data
    async function fetchExtendedForecast(lat, lon, count){
      try{
        const base = await window.fetchMonthlyForecast(lat, lon, 16);
        // If base or daily data is missing, return as-is
        if (!base || !base.daily) return base;
        const d = base.daily;
        // Helper to compute mean of numeric array
        function mean(arr){
          let s = 0, n = 0;
          if(Array.isArray(arr)){
            arr.forEach(v => { if(Number.isFinite(v)){ s += v; n++; } });
          }
          return n ? s / n : null;
        }
        // Compute means across available 16-day data
        const meanTmax = mean(d.temperature_2m_max);
        const meanTmin = mean(d.temperature_2m_min);
        const meanWmax = mean(d.wind_speed_10m_max);
        const meanGmax = mean(d.wind_gusts_10m_max);
        // Compute standard deviations for variation when estimating extended values
        function std(arr, m){
          let s = 0, n = 0;
          if(Array.isArray(arr)){
            arr.forEach(v => { if(Number.isFinite(v)){ s += Math.pow(v - m, 2); n++; } });
          }
          return n ? Math.sqrt(s / n) : 0;
        }
        const stdTmax = std(d.temperature_2m_max, meanTmax);
        const stdTmin = std(d.temperature_2m_min, meanTmin);
        const stdWmax = std(d.wind_speed_10m_max, meanWmax);
        const stdGmax = std(d.wind_gusts_10m_max, meanGmax);
        // Use last available direction and weather code as proxies for extended period
        const lastDir  = (d.wind_direction_10m_dominant || []).length ? d.wind_direction_10m_dominant[d.wind_direction_10m_dominant.length-1] : null;
        const lastCode = (d.weathercode || []).length ? d.weathercode[d.weathercode.length-1] : null;
        // Prepare extended daily arrays by cloning existing arrays
        const ext = {
          time: (d.time || []).slice(),
          temperature_2m_max: (d.temperature_2m_max || []).slice(),
          temperature_2m_min: (d.temperature_2m_min || []).slice(),
          wind_speed_10m_max: (d.wind_speed_10m_max || []).slice(),
          wind_gusts_10m_max: (d.wind_gusts_10m_max || []).slice(),
          wind_direction_10m_dominant: (d.wind_direction_10m_dominant || []).slice(),
          weathercode: (d.weathercode || []).slice()
        };
        const origLen = ext.time.length;
        if (!origLen) return { daily: ext, hourly: base.hourly };
        // Determine the last actual index where the maximum temperature is finite and strictly positive.
        // Open‚ÄëMeteo occasionally returns 0 or negative values for missing days; treat those as missing so they are estimated.
        let lastIdx = origLen - 1;
        for (let k = origLen - 1; k >= 0; k--) {
          const tv = ext.temperature_2m_max[k];
          // Use strict > 0 to ignore zeros and negative values when searching for the last valid day
          if (Number.isFinite(tv) && tv > 0) {
            lastIdx = k;
            break;
          }
        }
        // Extend up to requested count days
        // Determine number of additional days beyond original forecast
        const extraCount = count - origLen;
        // Capture last actual values for trending
        const lastTmax = ext.temperature_2m_max[lastIdx];
        const lastTmin = ext.temperature_2m_min[lastIdx];
        const lastWmax = ext.wind_speed_10m_max[lastIdx];
        const lastGmax = ext.wind_gusts_10m_max[lastIdx];
        // Determine amplitude fallback: if std is zero or NaN, use 10% of mean (absolute)
        const ampTmax = (Number.isFinite(stdTmax) && stdTmax > 0) ? stdTmax : (Number.isFinite(meanTmax) ? Math.abs(meanTmax) * 0.1 : 0);
        const ampTmin = (Number.isFinite(stdTmin) && stdTmin > 0) ? stdTmin : (Number.isFinite(meanTmin) ? Math.abs(meanTmin) * 0.1 : 0);
        const ampWmax = (Number.isFinite(stdWmax) && stdWmax > 0) ? stdWmax : (Number.isFinite(meanWmax) ? Math.abs(meanWmax) * 0.1 : 0);
        const ampGmax = (Number.isFinite(stdGmax) && stdGmax > 0) ? stdGmax : (Number.isFinite(meanGmax) ? Math.abs(meanGmax) * 0.1 : 0);
        for (let i = origLen; i < count; i++){
          const j = i - origLen; // index within extended portion
          // Create new date by adding days to the last actual date
          const lastDate = new Date(ext.time[lastIdx] + 'T00:00:00');
          lastDate.setDate(lastDate.getDate() + (i - lastIdx));
          const iso = lastDate.toISOString().slice(0,10);
          ext.time.push(iso);
          // ratio 0..1 across extended portion; avoid divide by zero when one day
          const r = (extraCount > 1) ? (j / (extraCount - 1)) : 0;
          // sinusoidal factor peaking at mid interval
          const sinFactor = Math.sin(r * Math.PI);
          // For each variable compute trend from last actual toward mean and add sinusoidal variation
          let valTmax = null, valTmin = null, valWmax = null, valGmax = null;
          // Compute each value with trend; fallback to mean or last if one is non-finite
          if (Number.isFinite(meanTmax) && Number.isFinite(lastTmax)){
            const delta = lastTmax - meanTmax;
            valTmax = meanTmax + delta * (1 - r) + sinFactor * ampTmax;
          } else if (Number.isFinite(meanTmax)) {
            valTmax = meanTmax + sinFactor * ampTmax;
          } else if (Number.isFinite(lastTmax)) {
            valTmax = lastTmax;
          }
          if (Number.isFinite(meanTmin) && Number.isFinite(lastTmin)){
            const delta = lastTmin - meanTmin;
            valTmin = meanTmin + delta * (1 - r) + sinFactor * ampTmin;
          } else if (Number.isFinite(meanTmin)) {
            valTmin = meanTmin + sinFactor * ampTmin;
          } else if (Number.isFinite(lastTmin)) {
            valTmin = lastTmin;
          }
          if (Number.isFinite(meanWmax) && Number.isFinite(lastWmax)){
            const delta = lastWmax - meanWmax;
            valWmax = meanWmax + delta * (1 - r) + sinFactor * ampWmax;
          } else if (Number.isFinite(meanWmax)) {
            valWmax = meanWmax + sinFactor * ampWmax;
          } else if (Number.isFinite(lastWmax)) {
            valWmax = lastWmax;
          }
          if (Number.isFinite(meanGmax) && Number.isFinite(lastGmax)){
            const delta = lastGmax - meanGmax;
            valGmax = meanGmax + delta * (1 - r) + sinFactor * ampGmax;
          } else if (Number.isFinite(meanGmax)) {
            valGmax = meanGmax + sinFactor * ampGmax;
          } else if (Number.isFinite(lastGmax)) {
            valGmax = lastGmax;
          }
          ext.temperature_2m_max.push(valTmax);
          ext.temperature_2m_min.push(valTmin);
          ext.wind_speed_10m_max.push(valWmax);
          ext.wind_gusts_10m_max.push(valGmax);
          // Copy last direction and weather code for extended days
          ext.wind_direction_10m_dominant.push(lastDir);
          ext.weathercode.push(lastCode);
        }
        // Fill any existing days after the last actual index (those with missing/zero values) using the same trend
        // This ensures days within the original 16-day range that have zero values are estimated instead of showing 0.0
        const totalSpan = count - lastIdx; // number of days including extended from last actual
        for (let k = lastIdx + 1; k < origLen; k++){
          const j2 = k - lastIdx;
          const r2 = (totalSpan > 1) ? (j2 / (totalSpan - 1)) : 0;
          const sinF = Math.sin(r2 * Math.PI);
          // Estimate values with the same formula used for extended days
          let eTmax = null, eTmin = null, eWmax = null, eGmax = null;
          if (Number.isFinite(meanTmax) && Number.isFinite(lastTmax)){
            const delta = lastTmax - meanTmax;
            eTmax = meanTmax + delta * (1 - r2) + sinF * ampTmax;
          } else if (Number.isFinite(meanTmax)) {
            eTmax = meanTmax + sinF * ampTmax;
          } else if (Number.isFinite(lastTmax)) {
            eTmax = lastTmax;
          }
          if (Number.isFinite(meanTmin) && Number.isFinite(lastTmin)){
            const delta = lastTmin - meanTmin;
            eTmin = meanTmin + delta * (1 - r2) + sinF * ampTmin;
          } else if (Number.isFinite(meanTmin)) {
            eTmin = meanTmin + sinF * ampTmin;
          } else if (Number.isFinite(lastTmin)) {
            eTmin = lastTmin;
          }
          if (Number.isFinite(meanWmax) && Number.isFinite(lastWmax)){
            const delta = lastWmax - meanWmax;
            eWmax = meanWmax + delta * (1 - r2) + sinF * ampWmax;
          } else if (Number.isFinite(meanWmax)) {
            eWmax = meanWmax + sinF * ampWmax;
          } else if (Number.isFinite(lastWmax)) {
            eWmax = lastWmax;
          }
          if (Number.isFinite(meanGmax) && Number.isFinite(lastGmax)){
            const delta = lastGmax - meanGmax;
            eGmax = meanGmax + delta * (1 - r2) + sinF * ampGmax;
          } else if (Number.isFinite(meanGmax)) {
            eGmax = meanGmax + sinF * ampGmax;
          } else if (Number.isFinite(lastGmax)) {
            eGmax = lastGmax;
          }
          ext.temperature_2m_max[k] = eTmax;
          ext.temperature_2m_min[k] = eTmin;
          ext.wind_speed_10m_max[k] = eWmax;
          ext.wind_gusts_10m_max[k] = eGmax;
          // direction and weather code remain unchanged for base days
        }
        return { daily: ext, hourly: base.hourly };
      }catch(err){ console.error(err); throw err; }
    }
    // Render the extended forecast table
    function renderExtendedTable(forecast){
      const isEN = document.documentElement.lang === 'en';
      extendedBody.innerHTML = '';
      if (!forecast || !forecast.daily || !Array.isArray(forecast.daily.time)){
        extendedBody.innerHTML = `<tr><td colspan="7" class="py-2 px-3 text-red-600">${isEN ? 'No data available.' : 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™'}</td></tr>`;
        extendedRangeEl.textContent = '';
        return;
      }
      const times  = forecast.daily.time;
      const tmax   = forecast.daily.temperature_2m_max || [];
      const tmin   = forecast.daily.temperature_2m_min || [];
      const wmax   = forecast.daily.wind_speed_10m_max || [];
      const gusts  = forecast.daily.wind_gusts_10m_max || [];
      const dirs   = forecast.daily.wind_direction_10m_dominant || [];
      const codes  = forecast.daily.weathercode || [];
      // Determine where original forecast ends (first 16 days) so we can mark extended rows
      const baseLen = (window.__lastForecast && window.__lastForecast.data && window.__lastForecast.data.daily && Array.isArray(window.__lastForecast.data.daily.time)) ? window.__lastForecast.data.daily.time.length : 0;
      for(let i=0; i<times.length; i++){
        const tr = document.createElement('tr');
        tr.className = i % 2 ? 'bg-gray-50 dark:bg-gray-900' : '';
        if(i >= baseLen){
          // Mark estimated rows with italic style and subtle color
          tr.style.fontStyle = 'italic';
          tr.style.color = '#555';
        }
        const dateISO = times[i];
        const dateObj = new Date(dateISO + 'T00:00:00');
        const locale = isEN ? 'en-GB' : 'ar-EG';
        const row = [
          dateObj.toLocaleDateString(locale,{day:'numeric', month:'numeric', year:'numeric'}),
          Number.isFinite(tmax[i]) ? Number(tmax[i]).toFixed(2) : '',
          Number.isFinite(tmin[i]) ? Number(tmin[i]).toFixed(2) : '',
          Number.isFinite(wmax[i]) ? Number(wmax[i]).toFixed(2) : '',
          Number.isFinite(gusts[i]) ? Number(gusts[i]).toFixed(2) : '',
          Number.isFinite(dirs[i]) ? degToDir(dirs[i], isEN ? 'en' : 'ar') : '',
          (codes[i] !== undefined ? weatherDesc(codes[i], isEN ? 'en' : 'ar') : '')
        ];
        row.forEach(cellText => {
          const td = document.createElement('td');
          td.className = 'py-2 px-3 text-right';
          td.textContent = cellText;
          tr.appendChild(td);
        });
        extendedBody.appendChild(tr);
      }
      // Range display
      if (times.length){
        const startDate = new Date(times[0] + 'T00:00:00');
        const endDate   = new Date(times[times.length - 1] + 'T00:00:00');
        const locale    = isEN ? 'en-GB' : 'ar-EG';
        const prefix    = isEN ? 'Next period:' : 'ÿßŸÑŸÅÿ™ÿ±ÿ© ÿßŸÑŸÇÿßÿØŸÖÿ©:';
        extendedRangeEl.textContent = `${prefix} ${startDate.toLocaleDateString(locale,{day:'numeric', month:'long'})} ‚Üí ${endDate.toLocaleDateString(locale,{day:'numeric', month:'long'})}`;
      } else {
        extendedRangeEl.textContent = '';
      }
      // Hide any note; we do not display 16-day limit message
      extendedNoteEl.textContent = '';
    }
    // Handle click on extended tab
    async function handleExtended(){
      const latInput = document.getElementById('lat');
      const lonInput = document.getElementById('lon');
      let lat = latInput && !isNaN(parseFloat(latInput.value)) ? parseFloat(latInput.value) : 0;
      let lon = lonInput && !isNaN(parseFloat(lonInput.value)) ? parseFloat(lonInput.value) : 0;
      const latStr = Number.isFinite(lat) ? lat.toFixed(4) : '0';
      const lonStr = Number.isFinite(lon) ? lon.toFixed(4) : '0';
      // Show loading row
      extendedBody.innerHTML = `<tr><td colspan="7" class="py-2 px-3 text-center text-gray-500">${document.documentElement.lang === 'en' ? 'Loading‚Ä¶' : 'ÿ¨ÿßÿ±Ÿä ÿ¨ŸÑÿ® ÿßŸÑÿ™ŸàŸÇÿπ...'}</td></tr>`;
      try{
        const forecast = await fetchExtendedForecast(latStr, lonStr, 30);
        renderExtendedTable(forecast);
        // Compute indices for export: for days within available daily data (first 16), map actual index; for extra days, use last index
        const extDates = forecast && forecast.daily && Array.isArray(forecast.daily.time) ? forecast.daily.time : [];
        const dataDaily = (window.__lastForecast && window.__lastForecast.data && window.__lastForecast.data.daily && Array.isArray(window.__lastForecast.data.daily.time)) ? window.__lastForecast.data.daily.time : [];
        const indices = extDates.map((d, i) => {
          if (i < dataDaily.length) return dataDaily.indexOf(d);
          else return dataDaily.length - 1;
        });
        window.__extendedDates   = extDates;
        window.__extendedIndices = indices;
        // Enable or disable export buttons based on indices
        const epdf = document.getElementById('extendedPdfBtn');
        const exls = document.getElementById('extendedXlsBtn');
        const invalid = indices.some(i => i < 0 || !Number.isInteger(i));
        if (epdf) epdf.disabled = invalid;
        if (exls) exls.disabled = invalid;
        // Set note: estimated days after the original forecast
        const hasEst = extDates.length > dataDaily.length;
        if (hasEst) {
          const isEN = document.documentElement.lang === 'en';
          extendedNoteEl.textContent = isEN ? 'Dates beyond day 16 are estimated based on the mean of previous days.' : 'ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ÿ®ÿπÿØ ÿßŸÑŸäŸàŸÖ 16 ŸáŸä ÿ™ŸÇÿØŸäÿ±ÿßÿ™ ÿ™ŸÇÿ±Ÿäÿ®Ÿäÿ© ÿ™ÿπÿ™ŸÖÿØ ÿπŸÑŸâ ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ£ŸäÿßŸÖ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©.';
        } else {
          extendedNoteEl.textContent = '';
        }
      }catch(err){
        extendedBody.innerHTML = `<tr><td colspan="7" class="py-2 px-3 text-red-600">${document.documentElement.lang === 'en' ? 'Error fetching forecast.' : 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑÿ™ŸàŸÇÿπ.'}</td></tr>`;
        extendedRangeEl.textContent = '';
        const epdf = document.getElementById('extendedPdfBtn');
        const exls = document.getElementById('extendedXlsBtn');
        if (epdf) epdf.disabled = true;
        if (exls) exls.disabled = true;
      }
    }
    // Attach handler to button
    // Removed: no separate extended tab button to attach
    // Expose functions globally for translation and export
    window.handleExtended       = handleExtended;
    window.renderExtendedTable  = renderExtendedTable;
    window.fetchExtendedForecast= fetchExtendedForecast;
    window.degToDir             = degToDir;
    window.weatherDescExt       = weatherDesc;
  });
})();
</script>
<!-- Monthly PDF/Excel generators -->
<script>
(function(){
  /**
   * Generate a monthly PDF summarising daily averages and expected production.
   * @param {object} data The forecast data object from Open‚ÄëMeteo (window.__lastForecast.data)
   * @param {number[]} indices Array of daily index positions corresponding to the monthly view
   * @param {string} windUnitUI The current wind speed unit (ms, kmh, mph, kn)
   */
  function generateMonthlyPDF(data, indices, windUnitUI){
    const { jsPDF } = window.jspdf || {};
    if (!jsPDF || !window.jspdf.jsPDF || !window.jspdf.jsPDF.API.autoTable) {
      alert(document.documentElement.lang === 'en' ? 'PDF library not available' : 'ŸÖŸÉÿ™ÿ®ÿ© PDF ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©');
      return;
    }
    if (!data || !data.daily || !data.hourly) {
      alert(document.documentElement.lang === 'en' ? 'No forecast data available.' : 'ŸÑÿß ÿ™ÿ™ŸàŸÅÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ŸÜÿ®ÿ§.');
      return;
    }
    const doc = new jsPDF({orientation:'portrait', unit:'pt', format:'a4'});
    const margin = 40;
    // Header: logo
    try {
      var logo = typeof LOGO_DATA_URL !== 'undefined' ? LOGO_DATA_URL : (window.LOGO_DATA_URL || '');
      if (logo) {
        const type = logo.indexOf('image/jpeg') > -1 ? 'JPEG' : 'PNG';
        const pageW = doc.internal.pageSize.getWidth();
        const logoW = 140, logoH = 40;
        doc.addImage(logo, type, pageW - margin - logoW, 25, logoW, logoH);
      }
    } catch(e) { console.warn('monthly logo error', e); }
    // Title (force English to ensure proper font rendering)
    doc.setFont('helvetica','bold').setFontSize(16);
    doc.text('Monthly Forecast ‚Äì Expected Production (MW)', margin, 50);
    doc.setFont('helvetica','normal').setFontSize(11);
    // Location and period (always English)
    const locLabel = 'Ras Ghareb Wind Energy (RGWE)';
    const startISO = data.daily.time[indices[0]];
    const endISO   = data.daily.time[indices[indices.length - 1]];
    const startDateObj = new Date(startISO + 'T00:00:00');
    const endDateObj   = new Date(endISO   + 'T00:00:00');
    const periodStr = `${startDateObj.toLocaleDateString('en-GB',{day:'numeric', month:'long'})} ‚Üí ${endDateObj.toLocaleDateString('en-GB',{day:'numeric', month:'long'})}`;
    doc.text('Location: ' + locLabel, margin, 75);
    doc.text('Period: ' + periodStr, margin, 95);
    // Build rows: each day aggregated
    const rows = [];
    let totWind = 0, totTemp = 0, totProd = 0;
    indices.forEach(function(dayIdx){
      if (dayIdx < 0) return;
      const dateISO = data.daily.time[dayIdx];
      const hIdx = (typeof hoursForDay === 'function') ? hoursForDay(dayIdx, data.hourly.time).slice(0,24) : [];
      let wSum=0, tSum=0, pSum=0, count=0;
      hIdx.forEach(function(k){
        const wVal = Array.isArray(getWindArray(data)) ? getWindArray(data)[k] : NaN;
        const wMs  = (typeof convertToMs === 'function') ? convertToMs(wVal, windUnitUI) : NaN;
        const T    = data.hourly.temperature_2m && data.hourly.temperature_2m[k];
        const prod = (typeof expectedProductionMWFromSheet === 'function') ? expectedProductionMWFromSheet(wMs) : 0;
        if (Number.isFinite(wMs)) { wSum += wMs; }
        if (Number.isFinite(T)) { tSum += T; }
        if (Number.isFinite(prod)) { pSum += prod; }
        count++;
      });
      const avgW = count ? wSum / count : 0;
      const avgT = count ? tSum / count : 0;
      // Round values for table display
      const avgWStr = Number.isFinite(avgW) ? avgW.toFixed(2) : '‚Äî';
      const avgTStr = Number.isFinite(avgT) ? avgT.toFixed(2) : '‚Äî';
      const prodStr = Number.isFinite(pSum) ? pSum.toFixed(3) : '‚Äî';
      rows.push([dateISO, avgWStr, avgTStr, prodStr]);
      totWind += Number(avgWStr) || 0;
      totTemp += Number(avgTStr) || 0;
      totProd += Number(prodStr) || 0;
    });
    // Table
    const head = [
      [
        'Date',
        'Avg wind (m/s)',
        'Avg temp (¬∞C)',
        'Expected production (MW)'
      ]
    ];
    doc.autoTable({
      startY: 120,
      styles: { font:'helvetica', fontSize: 10, cellPadding: 6, halign:'center' },
      headStyles: { fillColor: [243,244,246], textColor: 20 },
      head: head,
      body: rows
    });
    const yAfter = doc.lastAutoTable.finalY || 120;
    // Summary values
    const dayCount = rows.length;
    const avgWindAll = dayCount ? (totWind / dayCount) : 0;
    const avgTempAll = dayCount ? (totTemp / dayCount) : 0;
    doc.setFont('helvetica','bold');
    doc.text('Summary', margin, yAfter + 30);
    doc.setFont('helvetica','normal');
    doc.text('Average wind speed (m/s): ' + avgWindAll.toFixed(2), margin, yAfter + 50);
    doc.text('Average temperature (¬∞C): ' + avgTempAll.toFixed(2), margin, yAfter + 70);
    doc.text('Total expected production (MW): ' + totProd.toFixed(3), margin, yAfter + 90);
    // Save
    const filename = `MonthlyForecast_${startISO}_to_${endISO}.pdf`;
    doc.save(filename);
  }

  /**
   * Export a monthly Excel summarising daily averages and expected production.
   * @param {object} data Forecast data from Open‚ÄëMeteo
   * @param {number[]} indices Array of daily index positions
   * @param {string} windUnitUI Selected wind unit
   */
  function exportMonthlyExcel(data, indices, windUnitUI){
    function buildMonthlyRows(){
      const rows = [];
      if (!data || !data.daily || !data.hourly) return rows;
      // Determine year from first date
      const firstISO = data.daily.time[indices[0]];
      const firstDate = new Date(firstISO + 'T00:00:00');
      const year = firstDate.getFullYear();
      // Title row merged across 4 columns
      rows.push([`Forecasted Output Of The Facility, RGWE ${year}`, '', '', '']);
      // Header row
      rows.push(['Date','Average wind speed, m/s','Average temperature, ¬∞C','Expected production, MW']);
      // Data rows
      indices.forEach(function(dayIdx){
        if (dayIdx < 0) return;
        const dateISO = data.daily.time[dayIdx];
        const hIdx = (typeof hoursForDay === 'function') ? hoursForDay(dayIdx, data.hourly.time).slice(0,24) : [];
        let wSum=0, tSum=0, pSum=0, cnt=0;
        hIdx.forEach(function(k){
          const wVal = Array.isArray(getWindArray(data)) ? getWindArray(data)[k] : NaN;
          const wMs  = (typeof convertToMs === 'function') ? convertToMs(wVal, windUnitUI) : NaN;
          const T    = data.hourly.temperature_2m && data.hourly.temperature_2m[k];
          const prod = (typeof expectedProductionMWFromSheet === 'function') ? expectedProductionMWFromSheet(wMs) : 0;
          if (Number.isFinite(wMs)) { wSum += wMs; }
          if (Number.isFinite(T)) { tSum += T; }
          if (Number.isFinite(prod)) { pSum += prod; }
          cnt++;
        });
        const avgW = cnt ? +(wSum / cnt).toFixed(2) : '';
        const avgT = cnt ? +(tSum / cnt).toFixed(2) : '';
        const totP = +(pSum.toFixed(3));
        rows.push([dateISO, avgW, avgT, totP]);
      });
      return rows;
    }
    function buildWorkbook(rows){
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(rows);
      // Merge title row across 4 columns
      if (!ws['!merges']) ws['!merges'] = [];
      ws['!merges'].push({ s:{r:0,c:0}, e:{r:0,c:3} });
      // Styling: thick borders and alignment
      const thick = { style:'thick', color:{ rgb:'000000' } };
      const nRows = rows.length;
      const nCols = 4;
      for (let r = 0; r < nRows; r++){
        for (let c = 0; c < nCols; c++){
          const addr = XLSX.utils.encode_cell({r, c});
          if (!ws[addr]) ws[addr] = { v:'' };
          ws[addr].s = ws[addr].s || {};
          ws[addr].s.border = { top: thick, bottom: thick, left: thick, right: thick };
          const val = ws[addr].v;
          const isNumeric = (typeof val === 'number') || (typeof val === 'string' && val.trim() !== '' && !isNaN(Number(val)));
          // Align numeric and date strings to center
          const isDate = (typeof val === 'string') && /^\d{4}-\d{2}-\d{2}$/.test(val.trim());
          if (isNumeric || isDate){
            ws[addr].s.alignment = Object.assign({}, ws[addr].s.alignment || {}, { horizontal:'center', vertical:'center' });
          }
          // Title row styling
          if (r === 0){
            ws[addr].s.font = Object.assign({}, ws[addr].s.font || {}, { bold:true, sz:14 });
            ws[addr].s.alignment = { horizontal:'center', vertical:'center' };
          }
          // Header row styling
          if (r === 1){
            ws[addr].s.font = Object.assign({}, ws[addr].s.font || {}, { bold:true });
          }
        }
      }
      XLSX.utils.book_append_sheet(wb, ws, 'Monthly');
      return wb;
    }
    // Use the already loaded XLSX library (xlsx-js-style is included in the page).
    // If the library is unavailable, alert the user.
    try {
      if (!window.XLSX || !XLSX.utils || !(XLSX.writeFile || XLSX.write)) {
        alert(document.documentElement.lang === 'en' ? 'Excel library not available.' : 'ŸÖŸÉÿ™ÿ®ÿ© Excel ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©.');
        return;
      }
      const rows = buildMonthlyRows();
      const wb   = buildWorkbook(rows);
      const startISO = data.daily.time[indices[0]];
      const endISO   = data.daily.time[indices[indices.length - 1]];
      const fname = `MonthlyForecast_${startISO}_to_${endISO}.xlsx`;
      // Prefer the helper saveWorkbook if available
      if (typeof saveWorkbook === 'function') {
        saveWorkbook(wb, fname);
      } else if (XLSX.writeFile) {
        XLSX.writeFile(wb, fname);
      } else {
        // Fallback: create blob and download manually
        const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const url  = URL.createObjectURL(blob);
        const a    = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 2000);
      }
    } catch(e) {
      console.error(e);
      alert(document.documentElement.lang === 'en' ? 'Error exporting Excel.' : 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿµÿØŸäÿ± Excel.');
    }
  }
  // Expose
  window.generateMonthlyPDF = generateMonthlyPDF;
  window.exportMonthlyExcel = exportMonthlyExcel;
})();
</script>
<!-- ÿ≥ŸÉÿ±ÿ®ÿ™ ÿßŸÑÿ™ŸàŸÇÿπ ÿßŸÑÿ¥Ÿáÿ±Ÿä ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Open‚ÄëMeteo (16 ŸäŸàŸÖ) -->
<script id="rgwe-openmeteo-monthly">
(function(){
  // Defer initialization until the DOM is fully loaded to ensure monthlySection and related elements exist.
  document.addEventListener('DOMContentLoaded', function(){
    const monthlySection = document.getElementById('monthlySection');
    const monthlyBody    = document.getElementById('monthlyBody');
    const monthlyRangeEl = document.getElementById('monthlyRange');
    const monthlyNoteEl  = document.getElementById('monthlyNote');
    const tabMonthlyBtn  = document.getElementById('tabMonthlyBtn');
    if (!monthlySection || !monthlyBody || !monthlyRangeEl || !monthlyNoteEl || !tabMonthlyBtn) return;
    // Weather code descriptions in Arabic and English based on WMO codes
    const descAr = {
    "0": "ŸÖÿ¥ŸÖÿ≥",
    "1": "ÿµÿßŸÅŸç ÿ∫ÿßŸÑÿ®Ÿãÿß",
    "2": "ÿ∫ÿßÿ¶ŸÖ ÿ¨ÿ≤ÿ¶ŸäŸãÿß",
    "3": "ÿ∫ÿßÿ¶ŸÖ",
    "45": "ÿ∂ÿ®ÿßÿ®",
    "48": "ÿ∂ÿ®ÿßÿ® ŸÖÿπ ÿµŸÇŸäÿπ",
    "51": "ÿ±ÿ∞ÿßÿ∞ ÿÆŸÅŸäŸÅ",
    "53": "ÿ±ÿ∞ÿßÿ∞ ŸÖÿ™Ÿàÿ≥ÿ∑",
    "55": "ÿ±ÿ∞ÿßÿ∞ ŸÉÿ´ŸäŸÅ",
    "56": "ÿ±ÿ∞ÿßÿ∞ ŸÖÿ™ÿ¨ŸÖÿØ ÿÆŸÅŸäŸÅ",
    "57": "ÿ±ÿ∞ÿßÿ∞ ŸÖÿ™ÿ¨ŸÖÿØ ŸÉÿ´ŸäŸÅ",
    "61": "ŸÖÿ∑ÿ± ÿÆŸÅŸäŸÅ",
    "63": "ŸÖÿ∑ÿ± ŸÖÿ™Ÿàÿ≥ÿ∑",
    "65": "ŸÖÿ∑ÿ± ÿ∫ÿ≤Ÿäÿ±",
    "66": "ÿ£ŸÖÿ∑ÿßÿ± ŸÖÿ™ÿ¨ŸÖÿØÿ© ÿÆŸÅŸäŸÅÿ©",
    "67": "ÿ£ŸÖÿ∑ÿßÿ± ŸÖÿ™ÿ¨ŸÖÿØÿ© ÿ∫ÿ≤Ÿäÿ±ÿ©",
    "71": "ÿ´ŸÑŸàÿ¨ ÿÆŸÅŸäŸÅÿ©",
    "73": "ÿ´ŸÑŸàÿ¨ ŸÖÿ™Ÿàÿ≥ÿ∑ÿ©",
    "75": "ÿ´ŸÑŸàÿ¨ ŸÉÿ´ŸäŸÅÿ©",
    "77": "ÿ≠ÿ®Ÿäÿ®ÿßÿ™ ÿ´ŸÑÿ¨",
    "80": "ÿ≤ÿÆÿßÿ™ ŸÖÿ∑ÿ± ÿÆŸÅŸäŸÅÿ©",
    "81": "ÿ≤ÿÆÿßÿ™ ŸÖÿ∑ÿ±",
    "82": "ÿ≤ÿÆÿßÿ™ ŸÖÿ∑ÿ± ÿ∫ÿ≤Ÿäÿ±ÿ©",
    "85": "ÿ≤ÿÆÿßÿ™ ÿ´ŸÑŸàÿ¨ ÿÆŸÅŸäŸÅÿ©",
    "86": "ÿ≤ÿÆÿßÿ™ ÿ´ŸÑŸàÿ¨ ÿ∫ÿ≤Ÿäÿ±ÿ©",
    "95": "ÿπŸàÿßÿµŸÅ ÿ±ÿπÿØŸäÿ©",
    "96": "ÿπŸàÿßÿµŸÅ ÿ±ÿπÿØŸäÿ© ŸÖÿπ ÿ®ÿ±ÿØ",
    "99": "ÿπŸàÿßÿµŸÅ ÿ±ÿπÿØŸäÿ© ŸÇŸàŸäÿ© ŸÖÿπ ÿ®ÿ±ÿØ"
    };
    const descEn = {
    "0": "Clear",
    "1": "Mainly clear",
    "2": "Partly cloudy",
    "3": "Overcast",
    "45": "Fog",
    "48": "Rime fog",
    "51": "Light drizzle",
    "53": "Moderate drizzle",
    "55": "Dense drizzle",
    "56": "Light freezing drizzle",
    "57": "Dense freezing drizzle",
    "61": "Slight rain",
    "63": "Moderate rain",
    "65": "Heavy rain",
    "66": "Light freezing rain",
    "67": "Heavy freezing rain",
    "71": "Slight snow",
    "73": "Moderate snow",
    "75": "Heavy snow",
    "77": "Snow grains",
    "80": "Slight rain showers",
    "81": "Moderate rain showers",
    "82": "Violent rain showers",
    "85": "Slight snow showers",
    "86": "Heavy snow showers",
    "95": "Thunderstorm",
    "96": "Thunderstorm with slight hail",
    "99": "Thunderstorm with heavy hail"
    };
    function weatherDesc(code, lang){
      const m = lang === 'en' ? descEn : descAr;
      return m[String(code)] || '';
    }

    // Convert degrees to a cardinal direction (Arabic or English)
    function degToDirection(deg, lang){
      if (!Number.isFinite(deg)) return '';
      const dirsEn = ['N','NE','E','SE','S','SW','W','NW'];
      const dirsAr = ['ÿ¥ŸÖÿßŸÑ','ÿ¥ŸÖÿßŸÑ ÿ¥ÿ±ŸÇŸä','ÿ¥ÿ±ŸÇ','ÿ¨ŸÜŸàÿ® ÿ¥ÿ±ŸÇŸä','ÿ¨ŸÜŸàÿ®','ÿ¨ŸÜŸàÿ® ÿ∫ÿ±ÿ®Ÿä','ÿ∫ÿ±ÿ®','ÿ¥ŸÖÿßŸÑ ÿ∫ÿ±ÿ®Ÿä'];
      const dirs = lang === 'en' ? dirsEn : dirsAr;
      const idx  = Math.round((((deg % 360) + 360) / 45)) % 8;
      return dirs[idx];
    }
    async function fetchMonthlyForecast(lat, lon, days){
      // Include additional daily variables for wind metrics and force wind speeds in m/s
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}`+
                  `&daily=temperature_2m_max,temperature_2m_min,wind_speed_10m_max,wind_gusts_10m_max,wind_direction_10m_dominant,weathercode`+
                  `&forecast_days=${days}&timezone=auto&wind_speed_unit=ms`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('HTTP '+res.status);
      return res.json();
    }
    function renderMonthlyTable(forecast){
      const daily = forecast.daily || {};
      const times = daily.time || [];
      const tmax  = daily.temperature_2m_max || [];
      const tmin  = daily.temperature_2m_min || [];
      const wmax  = daily.wind_speed_10m_max || [];
      const gmax  = daily.wind_gusts_10m_max || [];
      const dirs  = daily.wind_direction_10m_dominant || [];
      const codes = daily.weathercode || [];
      const isEN  = document.documentElement.lang === 'en';
      // Clear table
      monthlyBody.innerHTML = '';
      // Build rows
      for(let i=0; i<times.length; i++){
        const tr = document.createElement('tr');
        const date = times[i];
        const max  = Number(tmax[i]);
        const min  = Number(tmin[i]);
        const wM   = Number(wmax[i]);
        const gM   = Number(gmax[i]);
        const dir  = Number(dirs[i]);
        const code = codes[i];
        const langKey = isEN ? 'en' : 'ar';
        tr.innerHTML = `
          <td class="py-1.5 px-3 text-right">${date}</td>
          <td class="py-1.5 px-3 text-right">${Number.isFinite(max)?('¬∞'+max.toFixed(1)):'‚Äî'}</td>
          <td class="py-1.5 px-3 text-right">${Number.isFinite(min)?('¬∞'+min.toFixed(1)):'‚Äî'}</td>
          <td class="py-1.5 px-3 text-right">${Number.isFinite(wM)?wM.toFixed(1):'‚Äî'}</td>
          <td class="py-1.5 px-3 text-right">${Number.isFinite(gM)?gM.toFixed(1):'‚Äî'}</td>
          <td class="py-1.5 px-3 text-right">${degToDirection(dir, langKey)}</td>
          <td class="py-1.5 px-3 text-right">${weatherDesc(code, langKey)}</td>
        `;
        monthlyBody.appendChild(tr);
      }
      // Set range description
      if (times.length){
        const first = times[0];
        const last  = times[times.length-1];
        const locale = isEN ? 'en-GB' : 'ar-EG';
        const startDate = new Date(first+'T00:00:00');
        const endDate   = new Date(last+'T00:00:00');
        const prefix = isEN ? 'Next period:' : 'ÿßŸÑÿ¥Ÿáÿ± ÿßŸÑŸÇÿßÿØŸÖ:';
        monthlyRangeEl.textContent = `${prefix} ${startDate.toLocaleDateString(locale,{day:'numeric', month:'long'})} ‚Üí ${endDate.toLocaleDateString(locale,{day:'numeric', month:'long'})}`;
      } else {
        monthlyRangeEl.textContent = '';
      }
      // Clear any existing note. Do not display the open-meteo forecast limit message in the UI.
      monthlyNoteEl.textContent = '';
    }
    async function handleMonthly(){
      const latInput = document.getElementById('lat');
      const lonInput = document.getElementById('lon');
      let lat = latInput && !isNaN(parseFloat(latInput.value)) ? parseFloat(latInput.value) : 0;
      let lon = lonInput && !isNaN(parseFloat(lonInput.value)) ? parseFloat(lonInput.value) : 0;
      // Truncate coordinates to 4 decimal places to avoid API errors
      const latStr = Number.isFinite(lat) ? lat.toFixed(4) : '0';
      const lonStr = Number.isFinite(lon) ? lon.toFixed(4) : '0';
      // Show loading across all columns
      monthlyBody.innerHTML = `<tr><td colspan="7" class="py-2 px-3 text-center text-gray-500">${document.documentElement.lang === 'en' ? 'Loading‚Ä¶' : 'ÿ¨ÿßÿ±Ÿä ÿ¨ŸÑÿ® ÿßŸÑÿ™ŸàŸÇÿπ...'}</td></tr>`;
      try{
        // Fetch 30-day extended forecast: first 16 days actual + estimated days 17-30
        const forecast = await fetchExtendedForecast(latStr, lonStr, 30);
        // Render table with 30 days of data
        renderMonthlyTable(forecast);
        // Build date list and index mapping: for days beyond the original forecast length, use last index
        const monthlyDates = (forecast && forecast.daily && Array.isArray(forecast.daily.time)) ? forecast.daily.time : [];
        const dataDaily = (window.__lastForecast && window.__lastForecast.data && window.__lastForecast.data.daily && Array.isArray(window.__lastForecast.data.daily.time)) ? window.__lastForecast.data.daily.time : [];
        const indices = monthlyDates.map((d,i) => {
          if (i < dataDaily.length) {
            return dataDaily.indexOf(d);
          }
          // Extended day: map to last available index
          return dataDaily.length > 0 ? (dataDaily.length - 1) : -1;
        });
        window.__monthlyDates = monthlyDates;
        window.__monthlyIndices = indices;
        // Mirror extended indices/dates for export using extended functions
        window.__extendedDates = monthlyDates;
        window.__extendedIndices = indices;
        // Enable or disable export buttons based on validity of indices
        const mpdf = document.getElementById('monthlyPdfBtn');
        const mxls = document.getElementById('monthlyXlsBtn');
        const invalid = indices.some(i => i < 0 || !Number.isInteger(i));
        if (mpdf) mpdf.disabled = invalid;
        if (mxls) mxls.disabled = invalid;
        // Display note if days beyond the original forecast exist
        const hasEst = monthlyDates.length > dataDaily.length;
        if (hasEst) {
          const isEN = document.documentElement.lang === 'en';
          monthlyNoteEl.textContent = isEN ? 'Dates beyond day 16 are estimated based on the mean of previous days.' : 'ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ÿ®ÿπÿØ ÿßŸÑŸäŸàŸÖ 16 ŸáŸä ÿ™ŸÇÿØŸäÿ±ÿßÿ™ ÿ™ŸÇÿ±Ÿäÿ®Ÿäÿ© ÿ™ÿπÿ™ŸÖÿØ ÿπŸÑŸâ ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ£ŸäÿßŸÖ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©.';
        } else {
          monthlyNoteEl.textContent = '';
        }
      }catch(e){
        const isEN = document.documentElement.lang === 'en';
        monthlyBody.innerHTML = `<tr><td colspan="7" class="py-2 px-3 text-red-600">${isEN ? 'Error fetching forecast.' : 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑÿ™ŸàŸÇÿπ.'}</td></tr>`;
        monthlyRangeEl.textContent = '';
        // Disable export buttons when error
        const mpdf = document.getElementById('monthlyPdfBtn');
        const mxls = document.getElementById('monthlyXlsBtn');
        if (mpdf) mpdf.disabled = true;
        if (mxls) mxls.disabled = true;
      }
    }
    // Trigger fetch when clicking the monthly tab
    tabMonthlyBtn.addEventListener('click', handleMonthly);

    // Expose key monthly helpers on the global window so other scripts (e.g. language
    // switcher) can invoke them. Without this, functions defined in this closure
    // are not reachable outside of the IIFE and the monthly panel cannot be
    // refreshed when switching languages. Assigning these functions on
    // `window` makes them available globally.
    window.handleMonthly = handleMonthly;
    window.renderMonthlyTable = renderMonthlyTable;
    window.degToDirection = degToDirection;
    window.fetchMonthlyForecast = fetchMonthlyForecast;

    // Attach export handlers to monthly buttons after DOM loads
    const mpdfBtn = document.getElementById('monthlyPdfBtn');
    if (mpdfBtn) {
      mpdfBtn.addEventListener('click', function(){
        const data = window.__lastForecast && window.__lastForecast.data;
        const indices = window.__monthlyIndices;
        const windUnitUI = window.__lastForecast && window.__lastForecast.windUnit;
        if (!data || !indices || !Array.isArray(indices)) { alert(document.documentElement.lang === 'en' ? 'No data to export yet.' : 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ÿµÿØŸäÿ± ÿ®ÿπÿØ.'); return; }
        // Use extended PDF generator if available to support estimated days beyond 16
        if (typeof window.generateExtendedPDF === 'function') {
          window.generateExtendedPDF(data, indices, windUnitUI);
        } else if (typeof window.generateMonthlyPDF === 'function') {
          window.generateMonthlyPDF(data, indices, windUnitUI);
        } else {
          alert(document.documentElement.lang === 'en' ? 'PDF generator not loaded.' : 'ÿØÿßŸÑÿ© ÿ™ŸàŸÑŸäÿØ PDF ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©.');
        }
      });
    }
    const mxlsBtn = document.getElementById('monthlyXlsBtn');
    if (mxlsBtn) {
      mxlsBtn.addEventListener('click', function(){
        const data = window.__lastForecast && window.__lastForecast.data;
        const indices = window.__monthlyIndices;
        const windUnitUI = window.__lastForecast && window.__lastForecast.windUnit;
        if (!data || !indices || !Array.isArray(indices)) { alert(document.documentElement.lang === 'en' ? 'No data to export yet.' : 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ÿµÿØŸäÿ± ÿ®ÿπÿØ.'); return; }
        // Use extended Excel exporter if available to support estimated days beyond 16
        if (typeof window.exportExtendedExcel === 'function') {
          window.exportExtendedExcel(data, indices, windUnitUI);
        } else if (typeof window.exportMonthlyExcel === 'function') {
          window.exportMonthlyExcel(data, indices, windUnitUI);
        } else {
          alert(document.documentElement.lang === 'en' ? 'Excel exporter not loaded.' : 'ÿØÿßŸÑÿ© ÿ™ÿµÿØŸäÿ± Excel ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©.');
        }
      });
    }
  });
})();
</script>

<style id="rgwe-dark-theme">
  /* ŸÜÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿØÿπŸÖ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑŸÑÿ£Ÿàÿ∂ÿßÿπ */
  :root { color-scheme: light; }
  html.dark { color-scheme: dark; }
  /* ŸÑŸàŸÜ ÿßŸÑÿπŸÑÿßŸÖÿ© ÿßŸÑÿ™ÿ¨ÿßÿ±Ÿäÿ© ŸÅŸä ÿßŸÑÿ∏ŸÑÿßŸÖ */
  html.dark :root { --rgwe-brand: #38bdf8; }
  html.dark #title-ar, html.dark #title-en { color: var(--rgwe-brand) !important; }

  /* ÿßŸÑÿ£ÿ≥ÿ∑ÿ≠ ŸàÿßŸÑÿÆŸÑŸÅŸäÿßÿ™ */
  html.dark body { background:#0b1220; color:#e5e7eb; }
  html.dark header.bg-white { background:#0f172a !important; }
  html.dark .bg-white   { background:#0f172a !important; }
  html.dark .bg-gray-50 { background:#111827 !important; }
  html.dark .bg-gray-100{ background:#0b1220 !important; }
  html.dark .shadow { box-shadow: 0 10px 15px -3px rgba(0,0,0,.6), 0 4px 6px -4px rgba(0,0,0,.6) !important; }

  /* ÿßŸÑŸÜÿµŸàÿµ ÿßŸÑÿ¥ÿßÿ¶ÿπÿ© */
  html.dark .text-gray-900 { color:#f1f5f9 !important; }
  html.dark .text-gray-700 { color:#e5e7eb !important; }
  html.dark .text-gray-600 { color:#cbd5e1 !important; }
  html.dark .text-gray-500 { color:#94a3b8 !important; }

  /* ÿßŸÑÿ≠ŸàÿßŸÅ */
  html.dark .border-gray-200 { border-color:#1f2937 !important; }

  /* ÿßŸÑÿ≠ŸÇŸàŸÑ ŸàÿßŸÑŸÇŸàÿßÿ¶ŸÖ */
  html.dark input, html.dark select, html.dark textarea {
    background:#0b1220; color:#e5e7eb; border-color:#334155;
  }

  /* ÿ¥ÿ±ÿßÿ¶ÿ∑/ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑÿ£ŸÑŸàÿßŸÜ ÿßŸÑŸÅÿßÿ™ÿ≠ÿ© */
  html.dark .bg-blue-50    { background:rgba(59,130,246,.08) !important; }
  html.dark .bg-emerald-50 { background:rgba(16,185,129,.08) !important; }
  html.dark .bg-red-50     { background:rgba(239,68,68,.10) !important; }
  html.dark .bg-yellow-50  { background:rgba(234,179,8,.08) !important; }

  html.dark .text-blue-900    { color:#93c5fd !important; }
  html.dark .text-emerald-900 { color:#6ee7b7 !important; }
  html.dark .text-red-800     { color:#fecaca !important; }
  html.dark .text-yellow-900  { color:#fde68a !important; }

  html.dark .border-blue-200    { border-color:rgba(59,130,246,.3) !important; }
  html.dark .border-emerald-200 { border-color:rgba(16,185,129,.3) !important; }
  html.dark .border-red-200     { border-color:rgba(239,68,68,.3) !important; }
  html.dark .border-yellow-200  { border-color:rgba(234,179,8,.3) !important; }
</style>

<style id="rgwe-title-placement-fix">
  /* ÿ∂ÿπ ÿßŸÑÿπŸÜŸàÿßŸÜ ÿ®ÿ¨Ÿàÿßÿ± ÿßŸÑŸÑŸàÿ¨Ÿà ÿ®ÿØŸÑ ÿßŸÑÿ™ŸÖŸàÿ∂ÿπ ÿßŸÑŸÖÿ∑ŸÑŸÇ */
  #title-ar, #title-en{
    position: static !important;
    left: auto !important;
    transform: none !important;
    text-align: start !important;
    margin-inline-start: .5rem !important; /* ŸÖÿ≥ÿßŸÅÿ© ÿµÿ∫Ÿäÿ±ÿ© ÿ®ÿπÿØ ÿßŸÑŸÑŸàÿ¨Ÿà */
    white-space: nowrap !important;
    display: inline-block !important;
  }
  /* ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑÿ™ÿ≤ÿßÿ≠ŸÖ ŸÅŸä ÿµŸÅ ÿßŸÑÿ™ÿ±ŸàŸäÿ≥ÿ© ÿßŸÑÿ£Ÿäÿ≥ÿ± */
  header .max-w-6xl > .flex.items-center.gap-3:first-child { gap: .5rem !important; }
</style>

<style id="rgwe-signature-style">
  .rgwe-signature{
    display:inline-flex; align-items:center; gap:.625rem;
    font-size: .95rem; line-height:1.5;
    color:#64748b; /* slate-500 */
    letter-spacing:.2px;
    user-select:text;
   direction:ltr; gap:.625rem; }
  .rgwe-signature .badge{
    width:28px; height:28px; border-radius:9999px;
    display:grid; place-items:center;
    font-weight:700; font-size:.8rem;
    background:linear-gradient(135deg, #0ea5e9, #22d3ee);
    color:white;
    box-shadow:0 4px 12px rgba(14,165,233,.35);
  }
  .rgwe-signature .label{ text-transform:uppercase; letter-spacing:.12em; font-weight:600; opacity:.7;  font-variant: all-small-caps; opacity:.85; }
  .rgwe-signature .name{ text-decoration:underline; text-underline-offset:3px;  font-weight:700; color: var(--rgwe-brand, #0ea5e9); letter-spacing:.3px;}
  .rgwe-signature .sep{ display:none !important; }
  /* Dark mode finesse */
  html.dark .rgwe-signature{ color:#94a3b8;  direction:ltr; gap:.625rem; } /* slate-400 */
  html.dark .rgwe-signature .badge{ box-shadow:0 4px 12px rgba(56,189,248,.25); }
</style>

<style id="rgwe-signature-no-underline">
  .rgwe-signature .name{ text-decoration: none !important; }
</style>


<style id="rgwe-lock-to-cc-style">
  .rgwe-locked-field[readonly] {
    background: rgba(0,0,0,0.03) !important;
    cursor: not-allowed !important;
    filter: saturate(0.6);
  }
  .rgwe-lock-btn {
    display: inline-flex; align-items: center; gap: 6px;
    margin-top: 6px; padding: 6px 10px; border-radius: 9999px;
    font-size: .85rem; border: 1px solid #e5e7eb; background: #fff; cursor: pointer;
  }
  .dark .rgwe-lock-btn { background: #0b1220; border-color: #334155; color: #e5e7eb; }
  .rgwe-lock-btn:hover { box-shadow: 0 1px 3px rgba(0,0,0,.08); }
  #rgwe-unlock-overlay { position: fixed; inset: 0; z-index: 99999; display: none; place-items: center; backdrop-filter: blur(6px); background: rgba(0,0,0,.35); }
  #rgwe-unlock-card {
    background: white; border-radius: 16px; padding: 20px; width: min(92%, 380px);
    box-shadow: 0 10px 25px rgba(0,0,0,.25); direction: rtl;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "Helvetica Neue", Arial;
  }
  .dark #rgwe-unlock-card { background:#0f172a; color:#e5e7eb; }
  #rgwe-unlock-card h3 { margin: 0 0 8px; font-size: 1.05rem; }
  #rgwe-unlock-card input[type=password] { width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid #e5e7eb; margin: 6px 0 10px; }
  .dark #rgwe-unlock-card input[type=password]{ background:#0b1220; color:#e5e7eb; border-color:#334155; }
  #rgwe-unlock-card .row { display: flex; gap: 8px; }
  #rgwe-unlock-card button { flex: 1; padding: 10px 12px; border-radius: 12px; border: none; cursor: pointer; }
  #rgwe-unlock-ok { background: #059669; color: white; font-weight: 600; }
  #rgwe-unlock-cancel { background: #e5e7eb; }
  .dark #rgwe-unlock-cancel { background: #1f2937; color: #e5e7eb; }
  #rgwe-unlock-err { color: #b91c1c; font-size: .85rem; min-height: 1.2em; margin-top: 6px; }
</style>
</head>
<body class="bg-gray-50 min-h-screen">
<!-- BEGIN: Site-level password gate (soft lock) -->
<style id="rgwe-password-gate-style">
  #rgwe-pw-overlay {position: fixed; inset: 0; z-index: 99999; display: grid; place-items: center; backdrop-filter: blur(6px); background: rgba(0,0,0,.35);}
  #rgwe-pw-card {background: white; border-radius: 16px; padding: 20px; width: min(92%, 380px);
    box-shadow: 0 10px 25px rgba(0,0,0,.25); direction: rtl;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans", "Helvetica Neue", Arial;}
  #rgwe-pw-card h2 {margin: 0 0 8px; font-size: 1.1rem;}
  #rgwe-pw-card p  {margin: 0 0 12px; font-size: .9rem; color: #4b5563;}
  #rgwe-pw-card input[type=password]{width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid #e5e7eb; margin: 6px 0 10px;}
  #rgwe-pw-card button{width: 100%; padding: 10px 12px; border-radius: 9999px; border: none; cursor: pointer; background: #059669; color: white; font-weight: 600;}
  #rgwe-pw-err { color: #b91c1c; font-size: .85rem; min-height: 1.2em; margin-top: 6px; }
  .dark #rgwe-pw-card{ background:#0f172a; color:#e5e7eb; }
  .dark #rgwe-pw-card p{ color:#94a3b8; }
  .dark #rgwe-pw-card input[type=password]{ background:#0b1220; color:#e5e7eb; border-color:#334155; }
</style>
<div id="rgwe-pw-overlay" role="dialog" aria-modal="true">
  <div id="rgwe-pw-card">
    <h2>ÿ≠ŸÖÿßŸäÿ© ÿ®ŸÉŸÑŸÖÿ© ŸÖÿ±Ÿàÿ±</h2>
    <p>ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ ÿ£ÿØÿÆŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑŸÑŸÖÿ™ÿßÿ®ÿπÿ©.</p>
    <form id="rgwe-pw-form">
      <input id="rgwe-pw-input" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="current-password" />
      <button type="submit">ÿØÿÆŸàŸÑ</button>
      <div id="rgwe-pw-err" aria-live="polite"></div>
    </form>
  </div>
</div>
<script id="rgwe-password-gate-script">
(function(){
  const HASH_HEX = "94edf28c6d6da38fd35d7ad53e485307f89fbeaf120485c8d17a43f323deee71"; // sha256("666666")
  const REMEMBER_KEY = "rgwe_pw_ok";
  const overlay = document.getElementById("rgwe-pw-overlay");
  const form    = document.getElementById("rgwe-pw-form");
  const input   = document.getElementById("rgwe-pw-input");
  const errEl   = document.getElementById("rgwe-pw-err");

  if (!overlay || !form || !input) return;

  try{ if (sessionStorage.getItem(REMEMBER_KEY) === "1"){ overlay.remove(); return; } }catch(_){}

  async function sha256Hex(s){
    const enc = new TextEncoder();
    const buf = await crypto.subtle.digest("SHA-256", enc.encode(s));
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  form.addEventListener("submit", async (e)=>{
    e.preventDefault();
    const val = (input.value || "").trim();
    try {
      const got = await sha256Hex(val);
      if (got === HASH_HEX){
        try{ sessionStorage.setItem(REMEMBER_KEY, "1"); }catch(_){}
        overlay.remove();
      }else{
        errEl.textContent = "ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©";
      }
    }catch(err){
      errEl.textContent = "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ";
      console.error(err);
    }
  }, {passive:false});
})();
</script>
<!-- END: Site-level password gate -->

<header class="bg-white shadow-sm sticky top-0 z-10">
<div class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between gap-3">
<div class="flex items-center gap-3">
<img alt="RGWE Logo" src="data:image/png;base64,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" style="height:36px"/>
<h1 class="text-xl font-bold text-center" id="title-ar">RGWE Forecast</h1>

</div>
<div class="text-sm text-gray-600 flex gap-2 items-center">
<select id="modelSelect" class="lang-select" title="ÿßÿÆÿ™ÿ± ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨">
  <option value="default">Forecast (ŸÖÿ™ÿπÿØÿØ ÿßŸÑŸÜŸÖÿßÿ∞ÿ¨)</option>
  <option value="ecmwf">ECMWF (10m/100m)</option>
</select>
<select class="lang-select" id="langSelect">
<option selected="" value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
<option value="en">English</option>
</select>
<button class="px-3 py-1.5 rounded-2xl bg-blue-600 text-white hover:bg-blue-700" id="locBtn">ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸàŸÇÿπŸä</button>
</div>
</div>
</header>
<main class="max-w-6xl mx-auto p-4">
<section class="mb-4 bg-yellow-50 border border-yellow-200 text-yellow-900 p-3 rounded-xl text-sm" id="steps">
      ÿßŸÑÿÆÿ∑Ÿàÿßÿ™: 1) ÿßÿÆÿ™Ÿéÿ± ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸàŸÇÿπŸÉÿå 2) ÿßÿ∂ÿ∫ÿ∑ "ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§"ÿå 3) ÿßÿÆÿ™Ÿéÿ± ÿßŸÑŸäŸàŸÖ ÿ´ŸÖ ÿ≠ŸÖŸëŸÑ <b>PDF</b> ÿ£Ÿà <b>Excel</b>.
    </section>
<section class="mb-6 grid gap-3 md:grid-cols-4">
<div class="bg-white rounded-2xl p-4 shadow">
<label class="block text-sm text-gray-700 mb-1" for="lat" id="latLbl">ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂ (Latitude)</label>
<input class="w-full border rounded-xl px-3 py-2" id="lat" step="0.0001" type="number"/>
</div>
<div class="bg-white rounded-2xl p-4 shadow">
<label class="block text-sm text-gray-700 mb-1" for="lon" id="lonLbl">ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ (Longitude)</label>
<input class="w-full border rounded-xl px-3 py-2" id="lon" step="0.0001" type="number"/>
</div>
<div class="bg-white rounded-2xl p-4 shadow">
<label class="block text-sm text-gray-700 mb-1" for="windUnit" id="unitLbl">Ÿàÿ≠ÿØÿ© ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ±Ÿäÿßÿ≠</label>
<select class="w-full border rounded-xl px-3 py-2" id="windUnit">
<option value="ms">ŸÖÿ™ÿ±/ÿ´ÿßŸÜŸäÿ© (m/s)</option>
<option value="kmh">ŸÉŸÖ/ÿ≥ÿßÿπÿ© (km/h)</option>
<option value="mph">ŸÖŸäŸÑ/ÿ≥ÿßÿπÿ© (mph)</option>
<option value="kn">ÿπŸÇÿØÿ© (kn)</option>
</select>
<label class="block text-sm text-gray-600 mt-2">ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿ±Ÿäÿßÿ≠</label>
<select class="w-full border rounded-xl px-3 py-2" id="windHeightSel">
<option value="10" selected="selected">10 m</option>
<option selected="" value="80">80 m</option>
<option value="120">120 m</option>
<option value="180">180 m</option>
</select>
</div>
<div class="bg-white rounded-2xl p-4 shadow flex flex-col justify-end">
<div aria-live="polite" class="text-xs text-gray-500 mb-2 select-none" id="lastFetch">ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿ¨ŸÑÿ® ÿ®ÿπÿØ</div>
<div class="text-xs mb-2 select-none" id="lastDelta"></div>
<button class="w-full bg-emerald-600 hover:bg-emerald-700 text-white py-2.5 rounded-2xl font-medium" id="fetchBtn">ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§</button>
</div>
</section>
<section class="mb-6 grid gap-3 md:grid-cols-3">
<div class="bg-white rounded-2xl p-4 shadow">
<label class="block text-sm text-gray-700 mb-1" for="emailTo">ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ŸÑŸâ (To)</label>
<input class="w-full border rounded-xl px-3 py-2" id="emailTo" placeholder="name@domain.com; name2@domain.com" type="text" value="tarikeng@yahoo.com; roody_rfr2020@yahoo.com; Rasha_boot@yahoo.com; NECC &lt;necc.2@hotmail.com&gt;; hgadsuez@yahoo.com; hamidaelsanea@gmail.com; Eng.elharirya@gmail.com; eman_eetc@yahoo.com; control.system.necc@gmail.com; ashraflotfih@gmail.com; eng_abdelfatah73@yahoo.com"/>
<p class="text-xs text-gray-500 mt-1">ŸäŸÖŸÉŸÜ ŸÉÿ™ÿßÿ®ÿ© ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ®ÿ±ŸäÿØ ŸÖŸÅÿµŸàŸÑ ÿ®ŸÄ ; ÿ£Ÿà , Ÿàÿ≥Ÿäÿ™ŸÖ ÿ≠ŸÅÿ∏Ÿá ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.</p>
</div>
<div class="bg-white rounded-2xl p-4 shadow">
<label class="block text-sm text-gray-700 mb-1" for="emailCc">ŸÜÿ≥ÿÆÿ© ÿ•ŸÑŸâ (CC)</label>
<input class="w-full border rounded-xl px-3 py-2" id="emailCc" placeholder="cc1@domain.com; cc2@domain.com" type="text" value="MANSOUR Mohamed (Ras Ghareb Wind Energy S.A.E.) &lt;mohamed.mansour@rasgharebwind.com&gt;; FENYAR Amged (Ras Ghareb Wind Energy S.A.E.) &lt;amged.fenyar@rasgharebwind.com&gt;; ELMEHALAWY Wael (Ras Ghareb Wind Energy S.A.E.) &lt;wael.elmehalawy@rasgharebwind.com&gt;; AYMAN Nour (Ras Ghareb Wind Energy S.A.E.) &lt;nour.ayman@rasgharebwind.com&gt;; DANIAL Abanoub (Ras Ghareb Wind Energy S.A.E.) &lt;abanoub.danial@rasgharebwind.com&gt;; EL HOSENY Raafat (Ras Ghareb Wind Energy S.A.E.) &lt;raafat.elhoseny@rasgharebwind.com&gt;; ISMAIL Mahmoud (Ras Ghareb Wind Energy S.A.E.) &lt;mahmoud.ismail@rasgharebwind.com&gt;; LASHEEN Mohamed (Ras Ghareb Wind Energy S.A.E.) &lt;mohamed.lasheen@rasgharebwind.com&gt;; SALAMA Ramy (Ras Ghareb Wind Energy S.A.E.) &lt;ramy.salama@rasgharebwind.com&gt;; FOUAD Ahmed (Ras Ghareb Wind Energy S.A.E.) &lt;ahmed.fouad@rasgharebwind.com&gt;; ABDELMAKSOUD Mohamed (Ras Ghareb Wind Energy S.A.E.) &lt;mohamed.abdelmaksoud@rasgharebwind.com&gt;; MOHAMED Ali (Ras Ghareb Wind Energy S.A.E.) &lt;ali.mohamed@rasgharebwind.com&gt;; ibrahim.emad@rasgharebwind.com"/>
<p class="text-xs text-gray-500 mt-1">ŸäŸÖŸÉŸÜ ŸÉÿ™ÿßÿ®ÿ© ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ®ÿ±ŸäÿØ ŸÖŸÅÿµŸàŸÑ ÿ®ŸÄ ; ÿ£Ÿà , Ÿàÿ≥Ÿäÿ™ŸÖ ÿ≠ŸÅÿ∏Ÿá ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.</p>
</div>
<div class="bg-white rounded-2xl p-4 shadow">
<label class="block text-sm text-gray-700 mb-1" for="turbines" id="turbLbl">ÿπÿØÿØ ÿßŸÑÿ™Ÿàÿ±ÿ®ŸäŸÜÿßÿ™</label>
<input class="w-full border rounded-xl px-3 py-2" id="turbines" min="1" readonly="" step="1" type="number" value="125"/>
</div>
<div class="bg-white rounded-2xl p-4 shadow">
<label class="block text-sm text-gray-700 mb-1" for="avail" id="availLbl">ÿßŸÑÿ™ŸàÿßŸÅÿ± (Availability) %</label>
<input class="w-full border rounded-xl px-3 py-2" id="avail" max="100" min="0" readonly="" step="0.1" type="number" value="98"/>
</div>
<div class="bg-white rounded-2xl p-4 shadow">
<label class="block text-sm text-gray-700 mb-1" for="losses" id="lossLbl">ÿßŸÑÿÆÿ≥ÿßÿ¶ÿ± (Losses) %</label>
<input class="w-full border rounded-xl px-3 py-2" id="losses" max="100" min="0" readonly="" step="0.1" type="number" value="0"/>
</div>
</section>
<section aria-live="polite" class="hidden mb-4 p-3 rounded-xl" id="status" role="status"></section><!-- ÿ™ÿ®ŸàŸäÿ®ÿßÿ™: ÿßŸÑÿ£ŸäÿßŸÖ ÿßŸÑŸÇÿßÿØŸÖÿ© / ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿßŸÑŸÇÿßÿØŸÖ -->
<section aria-label="View mode" class="mb-3 flex items-center gap-2" id="rgwe-tabs" role="tablist">
<button aria-pressed="true" class="px-3 py-1.5 rounded-2xl border border-emerald-600 text-emerald-700 bg-emerald-50" id="tabDailyBtn">ÿßŸÑÿ£ŸäÿßŸÖ ÿßŸÑŸÇÿßÿØŸÖÿ©</button>
<button aria-pressed="false" class="px-3 py-1.5 rounded-2xl border border-gray-200 text-gray-700 hover:bg-gray-100" id="tabWeeklyBtn">ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿßŸÑŸÇÿßÿØŸÖ (ÿßŸÑÿ£ÿ≠ÿØ ‚Üí ÿßŸÑÿ≥ÿ®ÿ™)</button>
<button aria-pressed="false" class="px-3 py-1.5 rounded-2xl border border-gray-200 text-gray-700 hover:bg-gray-100" id="tabMonthlyBtn">ÿßŸÑÿ¥Ÿáÿ± ÿßŸÑŸÇÿßÿØŸÖ</button>
    <!-- ÿ≤ÿ± ÿßŸÑÿ™ŸàŸÇÿπ ÿßŸÑŸÖŸÖÿ™ÿØ (Ÿ£Ÿ† ŸäŸàŸÖ) -->
    <!-- removed extended tab button -->
</section>
<section class="grid gap-4 md:grid-cols-2" id="cards"></section>
<!-- ŸÑŸàÿ≠ÿ© ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿßŸÑŸÇÿßÿØŸÖ -->
<section class="hidden" id="weeklySection">
<div class="bg-white rounded-2xl p-4 shadow">
<div class="text-sm text-gray-600" id="weeklyRange"></div>
<div class="mt-3 flex flex-wrap gap-2">
<button class="bg-blue-600 hover:bg-blue-700 text-white text-sm px-4 py-2 rounded-2xl" id="weeklyPdfBtn">ÿ™ŸàŸÑŸäÿØ PDF ŸÑŸÑÿ£ÿ≥ÿ®Ÿàÿπ</button>
<button class="bg-gray-800 hover:bg-black text-white text-sm px-4 py-2 rounded-2xl" id="weeklyXlsBtn">ÿ™ÿ≠ŸÖŸäŸÑ Excel ŸÑŸÑÿ£ÿ≥ÿ®Ÿàÿπ (ÿ¥Ÿäÿ™ Ÿàÿßÿ≠ÿØ)</button>
<button class="bg-emerald-600 hover:bg-emerald-700 text-white text-sm px-4 py-2 rounded-2xl" id="weeklyEmailBtn" type="button">ÿ™ÿµÿØŸäÿ± ŸÉÿ•ŸäŸÖŸäŸÑ ŸÑŸÑÿ£ÿ≥ÿ®Ÿàÿπ</button>
</div>
<p class="text-xs text-gray-500 mt-3">PDF: ÿµŸÅÿ≠ÿ© ŸÑŸÉŸÑ ŸäŸàŸÖ. Excel: ŸÉŸÑ ÿßŸÑÿ£ŸäÿßŸÖ ŸÖÿ™ÿ™ÿßŸÑŸäÿ© ŸÅŸä ÿ¥Ÿäÿ™ Ÿàÿßÿ≠ÿØ.</p>
</div>
</section>
<!-- ŸÑŸàÿ≠ÿ© ÿßŸÑÿ¥Ÿáÿ± ÿßŸÑŸÇÿßÿØŸÖ (16 ŸäŸàŸÖ) -->
<section class="hidden" id="monthlySection">
  <div class="bg-white rounded-2xl p-4 shadow">
    <!-- Range and export buttons -->
    <div class="text-sm text-gray-600" id="monthlyRange"></div>
    <div class="mt-3 flex flex-wrap gap-2">
      <button class="bg-blue-600 hover:bg-blue-700 text-white text-sm px-4 py-2 rounded-2xl" id="monthlyPdfBtn">ÿ™ŸàŸÑŸäÿØ PDF ŸÑŸÑÿ¥Ÿáÿ±</button>
      <button class="bg-gray-800 hover:bg-black text-white text-sm px-4 py-2 rounded-2xl" id="monthlyXlsBtn">ÿ™ÿ≠ŸÖŸäŸÑ Excel ŸÑŸÑÿ¥Ÿáÿ± (ÿ¥Ÿäÿ™ Ÿàÿßÿ≠ÿØ)</button>
    </div>
    <!-- Data table -->
    <div class="overflow-auto mt-3">
      <table class="min-w-full text-sm border-collapse">
        <thead>
          <tr class="bg-gray-100 dark:bg-gray-800">
            <th class="py-2 px-3 text-right">ÿßŸÑÿ™ÿßÿ±ŸäÿÆ</th>
            <th class="py-2 px-3 text-right">ÿßŸÑÿπÿ∏ŸÖŸâ (¬∞)</th>
            <th class="py-2 px-3 text-right">ÿßŸÑÿµÿ∫ÿ±Ÿâ (¬∞)</th>
            <th class="py-2 px-3 text-right">ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ±Ÿäÿßÿ≠ ÿßŸÑŸÇÿµŸàŸâ (ŸÖ/ÿ´)</th>
            <th class="py-2 px-3 text-right">ŸáŸéÿ®Ÿëÿßÿ™ ÿßŸÑÿ±Ÿäÿßÿ≠ ÿßŸÑŸÇÿµŸàŸâ (ŸÖ/ÿ´)</th>
            <th class="py-2 px-3 text-right">ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿßŸÑÿ≥ÿßÿ¶ÿØ</th>
            <th class="py-2 px-3 text-right">ÿßŸÑŸàÿµŸÅ</th>
          </tr>
        </thead>
        <tbody id="monthlyBody"></tbody>
      </table>
    </div>
    <p class="text-xs text-gray-500 mt-3" id="monthlyNote"></p>
  </div>
</section>
<!-- removed extended forecast section -->
  <!-- Modal for daily charts -->
  <div id="chartModal">
    <div id="chartContainer">
      <div class="close-btn" onclick="hideCharts()">√ó</div>
      <div id="crosshairInfo"></div>
      <h3 id="chartTitle">ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä ŸÑŸÑŸäŸàŸÖ</h3>
      <!-- Labels and canvases for each metric -->
      <p class="chart-label" id="windLabel">ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ±Ÿäÿßÿ≠</p>
      <canvas id="windChart"></canvas>
      <p class="chart-label" id="prodLabel">ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ ÿßŸÑŸÖÿ™ŸàŸÇÿπ</p>
      <canvas id="prodChart"></canvas>
      <p class="chart-label" id="tempLabel">ÿØÿ±ÿ¨ÿ© ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ©</p>
      <canvas id="tempChart"></canvas>
      <!-- Download buttons: save charts as PNG or PDF -->
      <button id="downloadChartBtn">ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©</button>
      <button id="downloadChartPdfBtn">ÿ™ÿ≠ŸÖŸäŸÑ PDF</button>
    </div>
  </div>
</main>
<footer class="max-w-6xl mx-auto p-6 text-center text-xs text-gray-500">
<div id="rgweSignature" class="rgwe-signature"><span class="badge" aria-hidden="true">ML</span><span class="label">DESIGNED BY</span><span class="sep" aria-hidden="true"></span><strong class="name">Mohamed Lasheen</strong></div>
</footer>
<script>
    const statusEl = document.getElementById('status');
    const cardsEl  = document.getElementById('cards');
    const latEl    = document.getElementById('lat');
    const lonEl    = document.getElementById('lon');
    const fetchBtn = document.getElementById('fetchBtn');
    const lastFetchEl = document.getElementById('lastFetch');
    const lastDeltaEl = document.getElementById('lastDelta');
    const locBtn   = document.getElementById('locBtn');
    const windUnitEl = document.getElementById('windUnit');
    const langSelect = document.getElementById('langSelect');

    const DEFAULT_LOCATION = { lat: 28.35831, lon: 33.07829, name: 'ÿ±ÿ£ÿ≥ ÿ∫ÿßÿ±ÿ®' };

    const EP_WS = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21];
    const EP_MW = [0.000,0.000,2.646,11.9805,28.65275,52.5035,86.13,131.01375,186.494,231.24325,254.9225,256.9315,257.25,257.25,257.25,257.25,257.25,257.25,257.25,257.25,257.25];
    function expectedProductionMWFromSheet(w_ms) {
      if (!Number.isFinite(w_ms) || w_ms < EP_WS[0]) return 0;
      let ws = Math.round(w_ms);
      if (ws > EP_WS[EP_WS.length - 1]) ws = EP_WS[EP_WS.length - 1];
      if (ws < EP_WS[0]) return 0;
      return EP_MW[ws - 1];
    }

    // Lightweight hash of forecast content (FNV-1a over selected fields)
function hashForecast(obj){
  try{
    const pick = {
      hourly: obj && obj.hourly ? {
        time: obj.hourly.time,
        wind_speed_10m: obj.hourly.wind_speed_10m,
        wind_speed_80m: obj.hourly.wind_speed_80m,
        wind_speed_120m: obj.hourly.wind_speed_120m,
        wind_speed_180m: obj.hourly.wind_speed_180m,
        temperature_2m: obj.hourly.temperature_2m
      } : null,
      daily: obj && obj.daily ? obj.daily : null
    };
    const str = JSON.stringify(pick);
    let h = 2166136261 >>> 0; // FNV-1a
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = (h * 16777619) >>> 0;
    }
    return h.toString(16);
  }catch(e){ return String(Math.random()).slice(2); }
}

function renderLastDelta(status){
  if(!lastDeltaEl) return;
  const lang = (document.documentElement.lang === 'en') ? 'en' : 'ar';
  if(!status){
    try{ status = localStorage.getItem('rgwe_last_delta_status') || ''; }catch(e){ status = ''; }
  }
  let text = '';
  let baseCls = 'text-xs mb-2 select-none ';
  if(status === 'changed'){
    text = (lang==='en') ? 'Forecast data updated' : 'ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ŸÜÿ®ÿ§';
    lastDeltaEl.className = baseCls + 'text-green-600';
  }else if(status === 'nochange'){
    text = (lang==='en') ? 'No changes since last fetch' : 'ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ÿπŸÜ ÿ¢ÿÆÿ± ÿ¨ŸÑÿ®';
    lastDeltaEl.className = baseCls + 'text-gray-500';
  }else if(status === 'first'){
    text = (lang==='en') ? 'First fetch' : 'ÿ£ŸàŸÑ ÿ¨ŸÑÿ® ŸÑŸÑÿ®ŸäÿßŸÜÿßÿ™';
    lastDeltaEl.className = baseCls + 'text-blue-600';
  }else{
    // Unknown / not set
    text = '';
    lastDeltaEl.className = baseCls + 'text-gray-500';
  }
  lastDeltaEl.textContent = text;
}

    function renderLastFetch(){
  if (!lastFetchEl) return;
  const lang = (document.documentElement.lang === 'en') ? 'en' : 'ar';
  const ts = window.__lastFetchAt || Number((()=>{ try{ return localStorage.getItem('rgwe_last_fetch') }catch(e){ return 0 } })() || 0);
  if (!ts) {
    lastFetchEl.textContent = (lang==='en') ? 'Not fetched yet' : 'ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿ¨ŸÑÿ® ÿ®ÿπÿØ';
    return;
  }
  const d = new Date(ts);
  const fmt = { year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' };
  const s  = d.toLocaleString(lang==='en' ? 'en-GB' : 'ar-EG', fmt);
  lastFetchEl.textContent = (lang==='en') ? ('Last fetch: ' + s) : ('ÿ¢ÿÆÿ± ÿ¨ŸÑÿ®: ' + s);
}

    function setStatus(msg, type='info'){
      statusEl.classList.remove('hidden');
      const base='mb-4 p-3 rounded-xl text-sm';
      const styles = type==='error' ? 'bg-red-50 border border-red-200 text-red-800'
                   : type==='ok'   ? 'bg-emerald-50 border border-emerald-200 text-emerald-900'
                                    : 'bg-blue-50 border border-blue-200 text-blue-900';
      statusEl.className = `${base} ${styles} fade-in`;
      statusEl.textContent = msg;
    }

    function convertToMs(v,u){
      switch(u){
        case 'kmh': return v/3.6;
        case 'mph': return v*0.44704;
        case 'kn':  return v*0.514444;
        default:    return v;
      }
    }

    function formatDate(iso, locale='ar-EG'){
      const d = new Date(iso+'T00:00:00');
      return d.toLocaleDateString(locale,{weekday:'long',year:'numeric',month:'long',day:'numeric'});
    }

    function hoursForDay(index, hourlyTimes){
      const allDays = hourlyTimes.map(t => t.slice(0,10));
      const uniqueDays = [...new Set(allDays)];
      const targetDay  = uniqueDays[index];
      const idx = [];
      allDays.forEach((d,i)=>{ if(d===targetDay) idx.push(i); });
      return idx;
    }

    // === Build card with DOM API to avoid ${} literal issues ===
    function makeCardCommon(dayISO, locationText, tmax, tmin, wmax, wmin, unitLabel, isEN){
      const card = document.createElement('div');
      card.className = 'bg-white rounded-2xl shadow p-4 fade-in';

      const top = document.createElement('div');
      top.className = 'flex items-start justify-between gap-2';

      const left = document.createElement('div');
      const locDiv = document.createElement('div');
      locDiv.className = 'text-sm text-gray-500';
      locDiv.textContent = locationText;
      const title = document.createElement('h3');
      title.className = 'text-lg font-bold';
      title.textContent = formatDate(dayISO, isEN ? 'en-GB' : 'ar-EG');
      left.appendChild(locDiv);
      left.appendChild(title);

      const badge = document.createElement('span');
      badge.className = 'text-xs bg-gray-100 text-gray-700 px-2 py-1 rounded-full';
      badge.textContent = isEN ? '' : ''; // will be filled by caller

      top.appendChild(left);
      top.appendChild(badge);

      const grid = document.createElement('div');
      grid.className = 'mt-3 grid grid-cols-2 gap-3 text-sm';

      const tempBox = document.createElement('div');
      tempBox.className = 'bg-gray-50 rounded-xl p-3';
      const tempLbl = document.createElement('div');
      tempLbl.className = 'text-gray-500';
      tempLbl.textContent = isEN ? 'Temperature' : 'ÿØÿ±ÿ¨ÿ© ÿßŸÑÿ≠ÿ±ÿßÿ±ÿ©';
      const tempVal = document.createElement('div');
      tempVal.className = 'font-medium';
      tempVal.textContent = isEN
        ? `Max ${tmax.toFixed(1)}¬∞C / Min ${tmin.toFixed(1)}¬∞C`
        : `ÿßŸÑÿπÿ∏ŸÖŸâ ${tmax.toFixed(1)}¬∞C / ÿßŸÑÿµÿ∫ÿ±Ÿâ ${tmin.toFixed(1)}¬∞C`;
      tempBox.appendChild(tempLbl); tempBox.appendChild(tempVal);

      const windBox = document.createElement('div');
      windBox.className = 'bg-gray-50 rounded-xl p-3';
      const windLbl = document.createElement('div');
      windLbl.className = 'text-gray-500';
      windLbl.textContent = isEN ? ('Wind Speed ('+ (window.__windHeight||80) +' m)') : ('ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ±Ÿäÿßÿ≠ ('+ (window.__windHeight||80) +' ŸÖ)');
      const windVal = document.createElement('div');
      windVal.className = 'font-medium';
      windVal.textContent = isEN
        ? `Max ${wmax.toFixed(1)} ${unitLabel} / Min ${wmin.toFixed(1)} ${unitLabel}`
        : `ÿßŸÑÿπÿ∏ŸÖŸâ ${wmax.toFixed(1)} ${unitLabel} / ÿßŸÑÿµÿ∫ÿ±Ÿâ ${wmin.toFixed(1)} ${unitLabel}`;
      windBox.appendChild(windLbl); windBox.appendChild(windVal);

      grid.appendChild(tempBox); grid.appendChild(windBox);

      const btns = document.createElement('div');
      btns.className = 'mt-4 flex flex-wrap gap-2';
      const pdfBtn = document.createElement('button');
      // Set explicit type to avoid submitting any surrounding form
      pdfBtn.type = 'button';
      pdfBtn.className = 'gen-btn bg-blue-600 hover:bg-blue-700 text-white text-sm px-4 py-2 rounded-2xl';
      pdfBtn.textContent = isEN ? 'Generate PDF' : 'ÿ™ŸàŸÑŸäÿØ PDF';
      const xlsBtn = document.createElement('button');
      xlsBtn.type = 'button';
      xlsBtn.className = 'xls-btn bg-gray-800 hover:bg-black text-white text-sm px-4 py-2 rounded-2xl';
      xlsBtn.textContent = isEN ? 'Download Excel' : 'ÿ™ÿ≠ŸÖŸäŸÑ Excel';
      const emailBtn = document.createElement('button');
      emailBtn.type = 'button';
      emailBtn.className = 'email-btn bg-emerald-600 hover:bg-emerald-700 text-white text-sm px-4 py-2 rounded-2xl';
      emailBtn.textContent = isEN ? 'Export as Email' : 'ÿ™ÿµÿØŸäÿ± ŸÉÿ•ŸäŸÖŸäŸÑ';

      // Chart button for displaying daily line graphs
      const chartBtn = document.createElement('button');
      chartBtn.type = 'button';
      chartBtn.className = 'chart-btn bg-purple-600 hover:bg-purple-700 text-white text-sm px-4 py-2 rounded-2xl';
      chartBtn.textContent = isEN ? 'Graph' : 'ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä';
      // When clicked, open the charts modal for this day index.  This handler
      // looks up the day index from the data attribute on the button.  It
      // delegates to showChartsForDay defined in the charts module.  Using
      // an explicit handler here ensures the charts open even if event
      // delegation elsewhere fails.
      chartBtn.addEventListener('click', function(ev){
        // Prevent the default button behaviour
        ev.preventDefault();
        // If the charts drawing function exists, call it with the day index
        const idx = Number(this.dataset.dayindex);
        const modalEl = document.getElementById('chartModal');
        if (modalEl) modalEl.style.display = 'block';
        if (!isNaN(idx) && typeof window.showChartsForDay === 'function') {
          window.showChartsForDay(idx);
        }
      });
      // Append all buttons
      btns.appendChild(pdfBtn);
      btns.appendChild(xlsBtn);
      btns.appendChild(emailBtn);
      btns.appendChild(chartBtn);
      card.appendChild(top);
      card.appendChild(grid);
      card.appendChild(btns);

      return {card, badge, pdfBtn, xlsBtn, emailBtn};
    }

    function renderCardsAR(data, locationLabel, windUnit){
      cardsEl.innerHTML='';
      const d = data.daily;
      for (let i = 0; i < Math.min(7, d.time.length); i++){
        const dayISO = d.time[i];
        const tmax = d.temperature_2m_max[i];
        const tmin = d.temperature_2m_min[i];
        // Compute wmax & wmin from hourly 120m for this day
        let wmax = -Infinity;
        let wmin = Infinity;
        try {
          const idxs = hoursForDay(i, data.hourly.time);
          if (Array.isArray(idxs) && idxs.length){
            for (const k of idxs){
              const v = getWindArray(data)[k];
              if (Number.isFinite(v)) {
                if (v > wmax) wmax = v;
                if (v < wmin) wmin = v;
              }
            }
          }
        } catch(_) {}
        if (!Number.isFinite(wmax) && Number.isFinite(wmin)) wmax = wmin;
        if (!Number.isFinite(wmin) && Number.isFinite(wmax)) wmin = wmax;
        if (!Number.isFinite(wmax)) wmax = 0;
        if (!Number.isFinite(wmin)) wmin = 0;
        const unitLabel = (windUnit==='ms' ? 'ŸÖ/ÿ´' : windUnit);
        const {card, badge, pdfBtn, xlsBtn, emailBtn} = makeCardCommon(dayISO, locationLabel, tmax, tmin, wmax, wmin, unitLabel, false);
        badge.textContent = (i===0 && data.current && (function(){
  const h = (window.__windHeight||80);
  const key = 'wind_speed_'+h+'m';
  const v = data.current && data.current[key];
  const u = (windUnit==='ms' ? 'ŸÖ/ÿ´' : windUnit);
  if (typeof v === 'number') return `ÿßŸÑŸäŸàŸÖ ÿ±ŸÇŸÖ ${i+1} ‚Äî ÿßŸÑÿ¢ŸÜ ${v.toFixed(1)} ${u}`;
  return `ÿßŸÑŸäŸàŸÖ ÿ±ŸÇŸÖ ${i+1}`;
})()) || `ÿßŸÑŸäŸàŸÖ ÿ±ŸÇŸÖ ${i+1}`;
        pdfBtn.dataset.dayindex = String(i);
        xlsBtn.dataset.dayindex = String(i);
        emailBtn.dataset.dayindex = String(i);
        // Attach day index to chart button
        const chartEl = card.querySelector('.chart-btn');
        if (chartEl) chartEl.dataset.dayindex = String(i);

        // Store fallback information for this day (max/min wind and temperature).  If
        // the hourly forecast is unavailable (e.g. offline), the chart
        // drawing code will generate a synthetic series based on these
        // values.  Use an object keyed by day index on the global
        // window.__fallbackData to preserve this information.
        try {
          window.__fallbackData = window.__fallbackData || {};
          window.__fallbackData[i] = {
            wmax: Number.isFinite(wmax) ? wmax : 0,
            wmin: Number.isFinite(wmin) ? wmin : 0,
            tmax: Number.isFinite(tmax) ? tmax : 0,
            tmin: Number.isFinite(tmin) ? tmin : 0
          };
        } catch(_){ /* ignore assignment errors */ }
        cardsEl.appendChild(card);
      }
      bindButtons();
    }

    function renderCardsEN(data, locationLabelEN, windUnit){
      cardsEl.innerHTML='';
      const d = data.daily;
      for (let i = 0; i < Math.min(7, d.time.length); i++){
        const dayISO = d.time[i];
        const tmax = d.temperature_2m_max[i];
        const tmin = d.temperature_2m_min[i];
        // Compute wmax & wmin from hourly 120m for this day
        let wmax = -Infinity;
        let wmin = Infinity;
        try {
          const idxs = hoursForDay(i, data.hourly.time);
          if (Array.isArray(idxs) && idxs.length){
            for (const k of idxs){
              const v = getWindArray(data)[k];
              if (Number.isFinite(v)) {
                if (v > wmax) wmax = v;
                if (v < wmin) wmin = v;
              }
            }
          }
        } catch(_) {}
        if (!Number.isFinite(wmax) && Number.isFinite(wmin)) wmax = wmin;
        if (!Number.isFinite(wmin) && Number.isFinite(wmax)) wmin = wmax;
        if (!Number.isFinite(wmax)) wmax = 0;
        if (!Number.isFinite(wmin)) wmin = 0;
        const unitLabel = (windUnit==='ms' ? 'm/s' : windUnit);
        const {card, badge, pdfBtn, xlsBtn, emailBtn} = makeCardCommon(dayISO, locationLabelEN, tmax, tmin, wmax, wmin, unitLabel, true);
        badge.textContent = `Day ${i+1}`;
        pdfBtn.dataset.dayindex = String(i);
        xlsBtn.dataset.dayindex = String(i);
        emailBtn.dataset.dayindex = String(i);
        // Attach day index to chart button
        const chartEl = card.querySelector('.chart-btn');
        if (chartEl) chartEl.dataset.dayindex = String(i);

        // Store fallback information for this day for use when hourly data
        // isn't available (for example, when the forecast hasn't been fetched yet).
        try {
          window.__fallbackData = window.__fallbackData || {};
          window.__fallbackData[i] = {
            wmax: Number.isFinite(wmax) ? wmax : 0,
            wmin: Number.isFinite(wmin) ? wmin : 0,
            tmax: Number.isFinite(tmax) ? tmax : 0,
            tmin: Number.isFinite(tmin) ? tmin : 0
          };
        } catch(_){ /* ignore assignment errors */ }
        cardsEl.appendChild(card);
      }
      bindButtons();
    }

    

// --- Inline email export helper (placed before bindButtons to ensure availability) ---
(function(){
  if (!window.exportEmailEML){
    function toMs(v,u){
      try{ if(window.convertToMs) return window.convertToMs(v,u); }catch(e){}
      if (!Number.isFinite(v)) return NaN;
      return u==='kn'||u==='knots'? v*0.514444 : (u==='kmh'? v/3.6 : (u==='mph'? v*0.44704 : v));
    }
    function hoursForDaySafe(dayIdx, hourlyTimes){
      try{ if(window.hoursForDay) return window.hoursForDay(dayIdx, hourlyTimes).slice(0,24); }catch(e){}
      const dateISO = window.__lastForecast?.data?.daily?.time?.[dayIdx];
      const idxs = [];
      for (let k=0; k<hourlyTimes.length; k++){
        if (hourlyTimes[k].startsWith(dateISO)){ idxs.push(k); if (idxs.length===24) break; }
      }
      return idxs;
    }
    function escHtml(s){ return String(s).replace(/[&<>"]/g, m=>({ '&':'&amp;', '<':'&lt;', '>':'&gt;'}[m])); }
    function buildDayEmailHTML(index, data, windUnitUI){
      const dayISO = data.daily.time[index];
      const dt0 = new Date(dayISO + 'T00:00:00');
      const niceDate = dt0.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');
      const hIdx = hoursForDaySafe(index, data.hourly.time);
      const times = [];
      for (let c=0;c<24;c++){
        const k = hIdx[c];
        times.push(typeof k==='number' ? new Date(data.hourly.time[k]).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'}) : '');
      }
      let windSum = 0, windCnt = 0;
      const windRow = [];
      for (let i=0;i<24;i++){
        const k = hIdx[i]; const w = toMs(getWindArray(data)[k], windUnitUI);
        const cell = Number.isFinite(w) ? Math.round(w) : '';
        windRow.push(cell);
        if (Number.isFinite(w)){ windSum += w; windCnt++; }
      }
      const windAvg = windCnt ? (windSum/windCnt).toFixed(2) : '';
      const availRow = Array.from({length:24}, ()=>98);
      let pSum = 0;
      const prodRow = [];
      for (let i=0;i<24;i++){
        const k = hIdx[i]; const w = toMs(getWindArray(data)[k], windUnitUI);
        const prodMW = (typeof window.expectedProductionMWFromSheet==='function') ? window.expectedProductionMWFromSheet(w) : 0;
        const v = Number.isFinite(prodMW) ? (+prodMW).toFixed(3) : '';
        prodRow.push(v);
        if (Number.isFinite(prodMW)) pSum += prodMW;
      }
      const prodTotal = pSum.toFixed(3);
      const cell = 'style="border:1px solid #000;padding:8px;text-align:center;font:14px Arial,Helvetica,sans-serif"';
      const cellL= 'style="border:1px solid #000;padding:8px;text-align:left;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
      const head = 'style="border:1px solid #000;padding:8px;text-align:center;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
      const title = 'style="text-align:center; text-align:center; padding:10px 6px;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
      const wrap = 'style="border-collapse:collapse;width:100%;max-width:1300px"';
      const tHeader = `
        <tr>
          <td ${cellL}>${escHtml(niceDate)}</td>
          ${times.map(t=>`<td ${head}>${escHtml(t)}</td>`).join('')}
          <td ${head}>Avg / Total</td>
        </tr>`;
      return `
        <div style="font:13px Arial,Helvetica,sans-serif;color:#000"><p style="margin:0 0 12px 0; white-space:pre-line">Dear all,\n\nAttached below is the RGWE forecasted output of the facility for your appreciated interest.</p>
          <div ${title}>Forecasted Output Of The Facility, RGWE 2025</div>
          <table ${wrap}>
            ${tHeader}
            <tr><td ${cellL}>Expected Wind Speed, m/s</td>${windRow.map(v=>`<td ${cell}>${escHtml(v)}</td>`).join('')}<td ${cell}>${escHtml(windAvg)}</td></tr>
            <tr><td ${cellL}>Availability %</td>${availRow.map(v=>`<td ${cell}>${v}</td>`).join('')}<td ${cell}>98</td></tr>
            <tr><td ${cellL}>Expected Production, MW</td>${prodRow.map(v=>`<td ${cell}>${escHtml(v)}</td>`).join('')}<td ${cell}>${escHtml(prodTotal)}</td></tr>
          </table>
        </div>`;
    }
    function b64(s){ return btoa(unescape(encodeURIComponent(s))); }
    function saveAsEml({subject, html, to='', cc=''}){
      const eml =
        'X-Unsent: 1\r\n' +
        (to ? ('To: '+to+'\r\n') : '') +
        (cc ? ('Cc: '+cc+'\r\n') : '') +
'Subject: '+subject+'\r\n' +
        'MIME-Version: 1.0\r\n' +
        'Content-Type: text/html; charset=UTF-8\r\n' +
        'Content-Transfer-Encoding: base64\r\n\r\n' +
        b64(html);
      const blob = new Blob([eml], {type:'message/rfc822'});
      const url  = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = subject.replace(/[^a-z0-9_\-]+/gi,'_') + '.eml';
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 2000);
    }
    window.exportEmailEML = function(index, data, windUnitUI){
      if(!data || !data.daily || !data.hourly){ alert('ÿ±ÿ¨ÿßÿ°Ÿã ÿ≠ÿØŸëŸêÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§ ÿ£ŸàŸÑŸãÿß.'); return; }
      const langEN = document.documentElement.lang === 'en';
      const dayISO = data.daily.time[index];
      const dt0 = new Date(dayISO + 'T00:00:00');
      const niceDate = dt0.toLocaleDateString(langEN?'en-GB':'ar-EG',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');
      const subject = 'Forecasted Output Of The Facility - RGWE';
      const inpTo = document.getElementById('emailTo');
      const toList = (inpTo && inpTo.value) ? inpTo.value.split(/[;,]/).map(s=>s.trim()).filter(Boolean) : (typeof window.__rgwe_getToList==='function' ? window.__rgwe_getToList() : []);
      const toHeader = (toList && toList.length) ? toList.join(', ') : '';
    const ccList = (typeof window.__rgwe_getCcList==='function') ? window.__rgwe_getCcList() : [];
    const ccHeader = (ccList && ccList.length) ? ccList.join(', ') : '';

    const html = buildDayEmailHTML(index, data, windUnitUI);
    saveAsEml({subject, html, to: toHeader, cc: ccHeader});
    };
  }})();

function bindButtons(){
      document.querySelectorAll('.gen-btn').forEach(btn=>{
        btn.onclick = ()=>{
          const i = Number(btn.dataset.dayindex);
          generatePDF(i, window.__lastForecast.data, (document.documentElement.lang==='en'? window.__lastForecast.locationLabelEN : window.__lastForecast.locationLabelAR), window.__lastForecast.windUnit);
        };
      });
      document.querySelectorAll('.xls-btn').forEach(btn=>{
        btn.onclick = ()=>{
          const i = Number(btn.dataset.dayindex);
          exportExcel(i, window.__lastForecast.data, (document.documentElement.lang==='en'? window.__lastForecast.locationLabelEN : window.__lastForecast.locationLabelAR), window.__lastForecast.windUnit);
        };
      });
    
      document.querySelectorAll('.email-btn').forEach(btn=>{
        btn.onclick = ()=>{
          const i = Number(btn.dataset.dayindex);
          if (window.exportEmailEML) {
            exportEmailEML(i, window.__lastForecast.data, window.__lastForecast.windUnit);
          } else {
            alert('Email export helper not loaded.');
          }
        };
      });
    }// PDF/Excel (unchanged)
    const LOGO_DATA_URL = "data:image/png;base64,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";
    function generatePDF(index, data, locationLabel, windUnitUI){
      const { jsPDF } = window.jspdf;
      const dayISO = data.daily.time[index];
      const doc = new jsPDF({orientation:'portrait',unit:'pt',format:'a4'});

      document.querySelectorAll('.email-btn').forEach(btn=>{
        btn.onclick = ()=>{
          const i = Number(btn.dataset.dayindex);
          exportEmailEML(i, window.__lastForecast.data, window.__lastForecast.windUnit);
        };
      });


      const margin = 40;
      const pageW = doc.internal.pageSize.getWidth();
      const logoW = 140, logoH = 40;
      doc.addImage(LOGO_DATA_URL, 'PNG', pageW - margin - logoW, 25, logoW, logoH);

      doc.setFont('helvetica','bold').setFontSize(16);
      doc.text('Daily Forecast ‚Äì Expected Production (MW)', margin, 50);
      doc.setFont('helvetica','normal').setFontSize(11);
      const locEn = 'Ras Ghareb Wind Energy (RGWE)';
      const dateEn = formatDate(dayISO, 'en-GB');
      doc.text(`Location: ${locEn}`, margin, 75);
      doc.text(`Date: ${dateEn}`, margin, 95);

      const hIdx = hoursForDay(index, data.hourly.time);
      const rows = [];
      let windSum=0, tempSum=0, totalProdMW=0;
      hIdx.forEach(k=>{
        const dt   = new Date(data.hourly.time[k]);
        const hour = dt.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'});
        const wMs  = convertToMs(getWindArray(data)[k], windUnitUI);
        const T    = data.hourly.temperature_2m[k];
        const prod = expectedProductionMWFromSheet(wMs);
        windSum += wMs;
        tempSum += T;
        totalProdMW += prod;
        rows.push([hour, wMs.toFixed(1), T.toFixed(1), prod.toFixed(3)]);
      });
      doc.autoTable({
        startY:120,
        styles:{font:'helvetica',fontSize:10,cellPadding:6,halign:'center'},
        headStyles:{fillColor:[243,244,246],textColor:20},
        head:[['Hour','Wind Speed (m/s)','Temperature (¬∞C)','Expected Production (MW)']],
        body:rows
      });
      const y = doc.lastAutoTable.finalY || 120;
      const avgW = hIdx.length? windSum/hIdx.length : 0;
      const avgT = hIdx.length? tempSum/hIdx.length : 0;
      doc.setFont('helvetica','bold'); doc.text('Summary',margin,y+30);
      doc.setFont('helvetica','normal');
      doc.text(`Average wind speed (m/s): ${avgW.toFixed(2)}`, margin, y+50);
      doc.text(`Average temperature (¬∞C): ${avgT.toFixed(2)}`, margin, y+70);
      doc.text(`Total expected production (MW): ${totalProdMW.toFixed(3)}`, margin, y+90);
      doc.save(`Forecast_${dayISO}.pdf`);
    }

    function exportExcel(index, data, locationLabel, windUnitUI){
      const hoursIdx = hoursForDay(index, data.hourly.time);
      const dayISO   = data.daily.time[index];
      const dateObj  = new Date(dayISO + 'T00:00:00');
      const year     = dateObj.getFullYear();
      const titleRow = new Array(26).fill(''); titleRow[0] = `Forecasted Output Of The Facility, RGWE ${year}`;
      const r1 = new Array(26).fill('');
      const niceDate = dateObj.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');
      r1[0] = niceDate;
      for(let c=1;c<=24;c++){ const k  = hoursIdx[c-1]; const dt = new Date(data.hourly.time[k]); r1[c] = dt.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'}); }
      const windRow = new Array(26).fill(''); windRow[0] = 'Expected Wind Speed, m/s';
      let windSum=0; hoursIdx.forEach((k,i)=>{ const wMs = convertToMs(getWindArray(data)[k], windUnitUI); windRow[i+1] = Number.isFinite(wMs) ? Math.round(wMs) : ''; windSum += wMs; });
      windRow[25] = hoursIdx.length? +(windSum/hoursIdx.length).toFixed(2) : '';
      
      const availRow = new Array(26).fill(''); 
      availRow[0] = 'Availability %'; 
      // Force 98 for all hours
      for (let i = 0; i < 24; i++) { availRow[i+1] = 98; }
      // Summary column = 98 as a number
      availRow[25] = 98;

      const powerRow = new Array(26).fill(''); powerRow[0] = 'Expected Production, MW';
      let powerSum=0; hoursIdx.forEach((k,i)=>{ const wMs = convertToMs(getWindArray(data)[k], windUnitUI); const prodMW = expectedProductionMWFromSheet(wMs); powerRow[i+1] = Number.isFinite(prodMW) ? +prodMW.toFixed(3) : ''; powerSum += prodMW; });
      powerRow[25] = +powerSum.toFixed(3);
      const wsData = [titleRow, r1, windRow, availRow, powerRow];
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, 'Forecast');
      // Force Availability % value to 98 (number) in Excel sheet
      const availHeader = "Availability %";
      let availColIndex = -1;
      const headerRow = wsData[0] || [];
      for (let ci = 0; ci < headerRow.length; ci++) {
        if (String(headerRow[ci]).trim().toLowerCase() === availHeader.toLowerCase()) {
          availColIndex = ci;
          break;
        }
      }
      if (availColIndex >= 0) {
        for (let r = 1; r < wsData.length; r++) { // skip header row
          const cellAddr = XLSX.utils.encode_cell({ r: r, c: availColIndex });
          ws[cellAddr] = { v: 98, t: 'n' }; // numeric 98
        }
      }
    
      // Merge A1:Z1 and set centered bold title
      if(!ws['!merges']) ws['!merges'] = [];
      ws['!merges'].push({ s: { r:0, c:0 }, e: { r:0, c:25 } }); // merge first row columns 0-25
      ws['A1'] = { v: "Forecasted Output Of The Facility, RGWE 2025", s: { 
        font: { bold: true, sz: 14 }, 
        alignment: { horizontal: "center", vertical: "center" } 
      }};
    
      
      
      
      // Apply thick borders to all cells (5 rows x 26 cols)
      const thick = { style: "thick", color: { rgb: "000000" } };
      const rows = wsData.length;   // 5
      const cols = 26;              // A..Z
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const addr = XLSX.utils.encode_cell({ r, c });
          if (!ws[addr]) ws[addr] = { v: "" };
          ws[addr].s = ws[addr].s || {};
          // Borders on all cells
          ws[addr].s.border = { top: thick, bottom: thick, left: thick, right: thick };
          // Determine alignment:
          const cellVal = (ws[addr] && typeof ws[addr].v !== "undefined") ? ws[addr].v : null;
          const isNumeric = (typeof cellVal === 'number') || (typeof cellVal === 'string' && cellVal.trim() !== '' && !isNaN(Number(cellVal)));
          const isTimeLike = (typeof cellVal === 'string') && /^\d{2}:\d{2}$/.test(cellVal.trim());
          if (isNumeric || isTimeLike) {
            // Center numeric and HH:MM time strings
            ws[addr].s.alignment = Object.assign({}, ws[addr].s.alignment || {}, { horizontal: "center", vertical: "center" });
          } // else: leave text default (left)
        }
      }


XLSX.writeFile(wb, `Forecast_${dayISO}.xlsx`);
    }

    async function getForecast(lat, lon, windUnit){
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.searchParams.set('latitude', lat);
  url.searchParams.set('longitude', lon);
  url.searchParams.set('timezone', 'auto');

  // Variables used by the UI
  url.searchParams.set('daily','temperature_2m_max,temperature_2m_min');
  url.searchParams.set('hourly','temperature_2m,wind_speed_10m,wind_speed_80m,wind_speed_120m,wind_speed_180m');
  url.searchParams.set('windspeed_unit', windUnit);

  // Also fetch CURRENT conditions so the "today" card updates instantly
  // current param removed to avoid CORS/preflight issues; use hourly[0] as 'now' approximation

  // Request explicit window: today -> +13 days
  const pad = n => String(n).padStart(2,'0');
  const now = new Date();
  const startISO = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}`;
  const endDate  = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 13);
  const endISO   = `${endDate.getFullYear()}-${pad(endDate.getMonth()+1)}-${pad(endDate.getDate())}`;
  url.searchParams.set('start_date', startISO);
  url.searchParams.set('end_date',   endISO);

  // Cache bust
  url.searchParams.set('_', Date.now());

  const res = await fetch(url.toString(), {
    cache: 'no-store',
    
  });
  if(!res.ok) throw new Error('ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ Open-Meteo');
  return res.json();
}

    async function handleFetch(){
      const lat = Number(latEl.value || DEFAULT_LOCATION.lat);
      const lon = Number(lonEl.value || DEFAULT_LOCATION.lon);
      const windUnit = windUnitEl.value;
      const isEN = document.documentElement.lang === 'en';
      setStatus(isEN ? 'Fetching forecast...' : 'ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§...', 'info');
      try{
        const json = await getForecast(lat, lon, windUnit);
        // Save last fetch time
        window.__lastFetchAt = Date.now();
        try{ localStorage.setItem('rgwe_last_fetch', String(window.__lastFetchAt)); }catch(e){}
        renderLastFetch();
        
// Compare with previous forecast snapshot
let prevHash = null;
try{ prevHash = localStorage.getItem('rgwe_last_hash'); }catch(e){}
const newHash = hashForecast(json);
let status = 'changed';
if(prevHash === null || prevHash === '' || typeof prevHash === 'undefined'){
  status = 'first';
}else if(prevHash === newHash){
  status = 'nochange';
}else{
  status = 'changed';
}
try{
  localStorage.setItem('rgwe_last_hash', newHash);
  localStorage.setItem('rgwe_last_delta_status', status);
}catch(e){}
renderLastDelta(status);
const locLabelAR = `${DEFAULT_LOCATION.name} (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
        const locLabelEN = `Ras Ghareb (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
        window.__lastForecast = { data: json, locationLabelAR: locLabelAR, locationLabelEN: locLabelEN, windUnit };
        if (isEN) {
          renderCardsEN(json, locLabelEN, windUnit);
          setStatus('Updated ‚úÖ Choose a day to export.', 'ok');
        } else {
          renderCardsAR(json, locLabelAR, windUnit);
          setStatus('ÿ™ŸÖ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úÖ ÿßÿÆÿ™ÿ± ŸäŸàŸÖŸãÿß ŸÑŸÑÿ™ÿµÿØŸäÿ±.', 'ok');
        }
      }catch(e){
        console.error(e);
        // --- Auto-retry once with alternate param name and minimal request
        try{
          const alt = await (async function(lat, lon, windUnit){
            const url = new URL('https://api.open-meteo.com/v1/forecast');
            url.searchParams.set('latitude', lat);
            url.searchParams.set('longitude', lon);
            url.searchParams.set('timezone', 'auto');
            url.searchParams.set('daily','temperature_2m_max,temperature_2m_min');
            url.searchParams.set('hourly','temperature_2m,wind_speed_10m');
            url.searchParams.set('wind_speed_unit', windUnit);
            const pad=n=>String(n).padStart(2,'0');
            const now=new Date();
            const startISO=`${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}`;
            const endDate=new Date(now.getFullYear(), now.getMonth(), now.getDate()+7);
            const endISO=`${endDate.getFullYear()}-${pad(endDate.getMonth()+1)}-${pad(endDate.getDate())}`;
            url.searchParams.set('start_date', startISO);
            url.searchParams.set('end_date', endISO);
            url.searchParams.set('_', Date.now());
            const res=await fetch(url.toString(), {cache:'no-store'});
            if(!res.ok) throw new Error('HTTP '+res.status);
            return res.json();
          })(lat, lon, windUnit);
          window.__lastFetchAt = Date.now();
          try{ localStorage.setItem('rgwe_last_fetch', String(window.__lastFetchAt)); }catch(e){}
          renderLastFetch();
          const locLabelAR = `${DEFAULT_LOCATION.name} (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
          const locLabelEN = `Ras Ghareb (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
          window.__lastForecast = { data: alt, locationLabelAR: locLabelAR, locationLabelEN: locLabelEN, windUnit };
          if (isEN) { renderCardsEN(alt, locLabelEN, windUnit); setStatus('Updated ‚úÖ Choose a day to export.', 'ok'); }
          else      { renderCardsAR(alt, locLabelAR, windUnit); setStatus('ÿ™ŸÖ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ ÿ®ŸÜÿ¨ÿßÿ≠ ‚úÖ ÿßÿÆÿ™ÿ± ŸäŸàŸÖŸãÿß ŸÑŸÑÿ™ÿµÿØŸäÿ±.', 'ok'); }
          return;
        }catch(_retryErr){ console.error('Retry also failed', _retryErr); }

        setStatus(isEN ? 'Failed to fetch data. Check coordinates and retry.' : 'ÿ™ÿπÿ∞Ÿëÿ± ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™. ÿ™ÿ£ŸÉŸëÿØ ŸÖŸÜ ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ÿ´ŸÖ ÿ£ÿπÿØ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ©.', 'error');
      }
    }

    fetchBtn.addEventListener('click', handleFetch);

    // PIN gate
    document.getElementById('locBtn').addEventListener('click', ()=>{
      const isEN = document.documentElement.lang === 'en';
      const pin = prompt(isEN ? 'Enter PIN code:' : 'ÿ£ÿØÿÆŸÑ ÿ±ŸÖÿ≤ PIN:');
      if (pin !== '0000') { 
        setStatus(isEN ? '‚ùå Incorrect PIN. Access denied.' : '‚ùå ÿ±ŸÖÿ≤ PIN ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠. ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿßŸÑŸàÿµŸàŸÑ.', 'error'); 
        return; 
      }
      if(!navigator.geolocation){
        setStatus(isEN ? 'Geolocation not supported. Using default location.' : 'ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑÿß ŸäÿØÿπŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ. ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä.', 'error');
        latEl.value = DEFAULT_LOCATION.lat; 
        lonEl.value = DEFAULT_LOCATION.lon; 
        handleFetch(); 
        return;
      }
      setStatus(isEN ? 'Verifying PIN & locating...' : 'ÿ¨ÿßÿ±Ÿç ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÄPIN Ÿàÿ™ÿ≠ÿØŸäÿØ ŸÖŸàŸÇÿπŸÉ...', 'info');
      navigator.geolocation.getCurrentPosition((pos)=>{
        latEl.value = (+pos.coords.latitude).toFixed(4);
        lonEl.value = (+pos.coords.longitude).toFixed(4);
        handleFetch();
      },()=>{
        setStatus(isEN ? 'Couldn‚Äôt get location. Using default location.' : 'ÿ™ÿπÿ∞Ÿëÿ± ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ. ÿ™ŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä.', 'error');
        latEl.value = DEFAULT_LOCATION.lat; 
        lonEl.value = DEFAULT_LOCATION.lon;
        handleFetch();
      });
    });;

    // Language selector: Arabic -> reload (keep original), English -> overlay & re-render
    langSelect.addEventListener('change', (e)=>{
      const val = e.target.value;
      if (val === 'ar') {
        localStorage.setItem('locale','ar');
        // Arabic UI tweaks
        document.documentElement.lang = 'ar';
        document.documentElement.dir  = 'rtl';
        const fetchBtn = document.getElementById('fetchBtn');
    const lastFetchEl = document.getElementById('lastFetch');
    const lastDeltaEl = document.getElementById('lastDelta');
        if (fetchBtn) fetchBtn.textContent = 'ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§';
        const stepsEl = document.getElementById('steps');
        if (stepsEl) stepsEl.innerHTML = 'ÿßŸÑÿÆÿ∑Ÿàÿßÿ™: Ÿ°) ÿ£ÿØÿÆŸÑ ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ÿ£Ÿà ÿßÿ∂ÿ∫ÿ∑ "ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÖŸàŸÇÿπŸä"ÿå Ÿ¢) ÿßÿ∂ÿ∫ÿ∑ <b>ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§</b>ÿå Ÿ£) ÿßÿÆÿ™ÿ± ÿßŸÑŸäŸàŸÖ ÿ´ŸÖ ÿµÿØŸëÿ± <b>PDF</b> ÿ£Ÿà <b>Excel</b>.';
        location.reload();
      } else {
        localStorage.setItem('locale','en');
        document.documentElement.lang = 'en';
        document.documentElement.dir  = 'ltr';
        const titleAr = document.getElementById('title-ar');
        const titleEn = document.getElementById('title-en');
        if (titleAr) titleAr.classList.add('hidden');
        if (titleEn) titleEn.classList.remove('hidden');
        const locBtn = document.getElementById('locBtn');
        if (locBtn) locBtn.textContent = 'Use my location';
        const stepsEl = document.getElementById('steps');
        if (stepsEl) stepsEl.innerHTML = 'Steps: 1) Enter coordinates or click "Use my location", 2) Click <b>Update Forecast</b>, 3) Pick a day then export <b>PDF</b> or <b>Excel</b>.';
        const latLbl = document.getElementById('latLbl');
        const lonLbl = document.getElementById('lonLbl');
        const unitLbl = document.getElementById('unitLbl');
        const fetchBtn = document.getElementById('fetchBtn');
    const lastFetchEl = document.getElementById('lastFetch');
    const lastDeltaEl = document.getElementById('lastDelta');
        const turbLbl = document.getElementById('turbLbl');
        const availLbl = document.getElementById('availLbl');
        const lossLbl = document.getElementById('lossLbl');
        if (latLbl) latLbl.textContent = 'Latitude';
        if (lonLbl) lonLbl.textContent = 'Longitude';
        if (unitLbl) unitLbl.textContent = 'Wind speed unit';
        if (fetchBtn) fetchBtn.textContent = 'Update Forecast';
        if (turbLbl) turbLbl.textContent = 'Number of turbines';
        if (availLbl) availLbl.textContent = 'Availability %';
        if (lossLbl) lossLbl.textContent = 'Losses %';
        const unitSel = document.getElementById('windUnit');
        if (unitSel){
          const opt = (v,t)=>{ const o = unitSel.querySelector(`option[value="${v}"]`); if (o) o.textContent = t; };
          opt('ms','m/s'); opt('kmh','km/h'); opt('mph','mph'); opt('kn','kn');
        }
        // Update tabs & weekly section labels in English
        const tabDailyBtn  = document.getElementById('tabDailyBtn');
        const tabWeeklyBtn = document.getElementById('tabWeeklyBtn');
        const tabMonthlyBtn = document.getElementById('tabMonthlyBtn');
        const weeklyPdfBtn = document.getElementById('weeklyPdfBtn');
        const weeklyXlsBtn = document.getElementById('weeklyXlsBtn');
        const weeklyNote   = document.querySelector('#weeklySection p.text-xs');
        if (tabDailyBtn)  tabDailyBtn.textContent  = 'Upcoming days';
        if (tabWeeklyBtn) tabWeeklyBtn.textContent = 'Next week (Sun ‚Üí Sat)';
        // Update monthly tab label to indicate 30‚Äëday coverage
        if (tabMonthlyBtn) tabMonthlyBtn.textContent = 'Monthly (30‚Äëday)';
        if (weeklyPdfBtn) weeklyPdfBtn.textContent = 'Generate weekly PDF';
        if (weeklyXlsBtn) weeklyXlsBtn.textContent = 'Download weekly Excel (one sheet)';
        if (weeklyNote)   weeklyNote.textContent   = 'PDF: one page per day. Excel: all days in a single sheet.';
        // Update monthly buttons and note text in English
        const monthlyPdfBtn = document.getElementById('monthlyPdfBtn');
        const monthlyXlsBtn = document.getElementById('monthlyXlsBtn');
        const monthlyNoteEl = document.getElementById('monthlyNote');
        if (monthlyPdfBtn) monthlyPdfBtn.textContent = 'Generate monthly PDF';
        if (monthlyXlsBtn) monthlyXlsBtn.textContent = 'Download monthly Excel (one sheet)';
        if (monthlyNoteEl) monthlyNoteEl.textContent = 'PDF: one row per day. Excel: all days aggregated in a single sheet.';

        // When switching to English, update the monthly table header labels to English
        // and refresh the monthly panel if it is currently visible. The monthly table
        // header cells are static in the HTML (Arabic by default), so we need to
        // translate them manually here. Additionally, if the monthly tab is active
        // and forecast data has already been fetched, call the exposed handleMonthly
        // function to redraw the table with English labels and direction names.
        const monthlySectionEl = document.getElementById('monthlySection');
        if (monthlySectionEl) {
          const ths = monthlySectionEl.querySelectorAll('thead th');
          if (ths && ths.length >= 7) {
            ths[0].textContent = 'Date';
            ths[1].textContent = 'Max (¬∞)';
            ths[2].textContent = 'Min (¬∞)';
            ths[3].textContent = 'Max wind speed (m/s)';
            ths[4].textContent = 'Max gusts (m/s)';
            ths[5].textContent = 'Dominant direction';
            ths[6].textContent = 'Description';
          }
          // If the monthly panel is currently visible and we have forecast data,
          // refresh it to apply English labels and descriptions. This uses the
          // globally exposed handleMonthly function (assigned in the monthly
          // script) to re-fetch and re-render the monthly forecast. Without
          // re-rendering, the direction labels and weather descriptions remain
          // in the previous language.
          try {
            if (!monthlySectionEl.classList.contains('hidden') &&
                typeof window.handleMonthly === 'function' &&
                window.__lastForecast) {
              window.handleMonthly();
            }
          } catch(err) { console.error(err); }
        }
        // Re-render cards + weekly panel in English if data already loaded
        if (window.__lastForecast) {
          try {
            renderCardsEN(window.__lastForecast.data, window.__lastForecast.locationLabelEN, window.__lastForecast.windUnit);
            renderWeeklyPanel(window.__lastForecast.data);
          } catch(e){ console.error(e); }
        }
      }
    });

    
    
    
    
    // === PIN guard for Latitude/Longitude manual edits (user-initiated, no-loop) ===
    (function(){
      let lastLat = (latEl.value && !isNaN(+latEl.value)) ? (+latEl.value).toFixed(4) : (""+DEFAULT_LOCATION.lat);
      let lastLon = (lonEl.value && !isNaN(+lonEl.value)) ? (+lonEl.value).toFixed(4) : (""+DEFAULT_LOCATION.lon);

      let pinUnlocked = false;
      let unlockTimer = null;
      const UNLOCK_MS = 120000; // 2 minutes

      function startUnlockSession(){
        pinUnlocked = true;
        if (unlockTimer) clearTimeout(unlockTimer);
        unlockTimer = setTimeout(()=>{ pinUnlocked = false; }, UNLOCK_MS);
      }

      function ensurePin(){
        if (pinUnlocked) return true;
        const isEN = document.documentElement.lang === 'en';
        const pin = prompt(isEN ? 'Enter PIN code:' : 'ÿ£ÿØÿÆŸÑ ÿ±ŸÖÿ≤ PIN:');
        if (pin === '0000') {
          startUnlockSession();
          setStatus(isEN ? 'PIN accepted. You can edit latitude/longitude for 2 minutes.' : 'ÿ™ŸÖ ŸÇÿ®ŸàŸÑ ÿßŸÑŸÄPIN. ŸäŸÖŸÉŸÜŸÉ ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ŸÑŸÖÿØÿ© ÿØŸÇŸäŸÇÿ™ŸäŸÜ.', 'ok');
          return true;
        }
        if (pin === null) {
          setStatus(isEN ? 'Cancelled.' : 'ÿ™ŸÖ ÿßŸÑÿ•ŸÑÿ∫ÿßÿ°.', 'error');
        } else {
          setStatus(isEN ? '‚ùå Incorrect PIN. Access denied.' : '‚ùå Incorrect PIN. Access denied.', 'error');
        }
        return false;
      }

      function attachPinGuard(el, getLast, setLast){
        let userInitiated = false;     // becomes true on real user interaction
        let promptedThisFocus = false; // ensure single prompt per focus

        function askOnce(){
          promptedThisFocus = true;
          const ok = ensurePin();
          if (!ok){
            el.value = getLast();
            // blur without re-triggering prompt
            setTimeout(()=> { el.blur(); }, 0);
          }
        }

        // Mark that next focus is user-initiated (click/touch or keyboard Tab/Enter)
        el.addEventListener('pointerdown', ()=>{ userInitiated = true; promptedThisFocus = false; }, {capture:true});
        el.addEventListener('keydown', (e)=>{
          if (e.key === 'Tab' || e.key === 'Enter' || e.key === ' ') {
            userInitiated = true;
            promptedThisFocus = false;
          }
        }, true);

        el.addEventListener('focus', ()=>{
          if (pinUnlocked) return;
          if (!userInitiated) return; // programmatic focus - don't prompt
          if (!promptedThisFocus) askOnce();
        });

        el.addEventListener('blur', ()=>{
          // reset flags so next real interaction can prompt again
          userInitiated = false;
          promptedThisFocus = false;
        });

        // Block editing while locked
        el.addEventListener('beforeinput', (e)=>{ if (!pinUnlocked) e.preventDefault(); });
        el.addEventListener('input', ()=>{ if (!pinUnlocked) el.value = getLast(); });

        el.addEventListener('change', ()=>{
          if (pinUnlocked){
            const v = el.value;
            if (!isNaN(+v) && v !== ''){
              setLast((+v).toFixed(4));
              startUnlockSession(); // refresh session on valid change
            } else {
              el.value = getLast();
            }
          } else {
            el.value = getLast();
          }
        });
      }

      attachPinGuard(latEl, ()=>lastLat, (v)=>{ lastLat = v; });
      attachPinGuard(lonEl, ()=>lastLon, (v)=>{ lastLon = v; });
    })();


    window.addEventListener('DOMContentLoaded', ()=>{
      renderLastFetch();
      renderLastDelta();
      const saved = localStorage.getItem('locale') || 'ar';
      document.getElementById('langSelect').value = saved;
      if (saved === 'en') {
        const ev = new Event('change');
        document.getElementById('langSelect').dispatchEvent(ev);
      } else {
        document.documentElement.lang = 'ar';
        document.documentElement.dir  = 'rtl';
      }
      latEl.value = DEFAULT_LOCATION.lat;
      lonEl.value = DEFAULT_LOCATION.lon;
      handleFetch();
    });
  </script>
<script>
(function(){
  const weeklySection  = document.getElementById('weeklySection');
  const monthlySection = document.getElementById('monthlySection');
  // Include extended forecast section
  const extendedSection= document.getElementById('extendedSection');
  const cardsSection   = document.getElementById('cards');
  const tabDailyBtn    = document.getElementById('tabDailyBtn');
  const tabWeeklyBtn   = document.getElementById('tabWeeklyBtn');
  const tabMonthlyBtn  = document.getElementById('tabMonthlyBtn');
  // Weekly range and export elements
  const weeklyRangeEl  = document.getElementById('weeklyRange');
  const weeklyPdfBtn   = document.getElementById('weeklyPdfBtn');
  const weeklyXlsBtn   = document.getElementById('weeklyXlsBtn');

  // Abort initialization if required elements are missing (extended tab removed)
  if (!weeklySection || !monthlySection || !cardsSection || !tabDailyBtn || !tabWeeklyBtn || !tabMonthlyBtn) return;

  function setTab(active){
    // Hide all forecast sections first
    weeklySection.classList.add('hidden');
    monthlySection.classList.add('hidden');
    cardsSection.classList.add('hidden');
    // Reset all tab classes
    tabDailyBtn.className    = 'px-3 py-1.5 rounded-2xl border border-gray-200 text-gray-700 hover:bg-gray-100';
    tabWeeklyBtn.className   = 'px-3 py-1.5 rounded-2xl border border-gray-200 text-gray-700 hover:bg-gray-100';
    tabMonthlyBtn.className  = 'px-3 py-1.5 rounded-2xl border border-gray-200 text-gray-700 hover:bg-gray-100';
    if (active === 'weekly'){
      weeklySection.classList.remove('hidden');
      tabWeeklyBtn.className   = 'px-3 py-1.5 rounded-2xl border border-emerald-600 text-emerald-700 bg-emerald-50';
    } else if (active === 'monthly'){
      monthlySection.classList.remove('hidden');
      tabMonthlyBtn.className  = 'px-3 py-1.5 rounded-2xl border border-emerald-600 text-emerald-700 bg-emerald-50';
    } else {
      // default to daily
      cardsSection.classList.remove('hidden');
      tabDailyBtn.className    = 'px-3 py-1.5 rounded-2xl border border-emerald-600 text-emerald-700 bg-emerald-50';
    }
  }
  tabDailyBtn.addEventListener('click', ()=> setTab('daily'));
  tabWeeklyBtn.addEventListener('click', ()=> setTab('weekly'));
  tabMonthlyBtn.addEventListener('click', ()=> setTab('monthly'));
  // Extended tab removed

  // Helpers
  function ymdLocal(d){ const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; }
  function nextSunday(from = new Date()){ const day=from.getDay(); const delta=((7-day)%7)||7; const d=new Date(from); d.setHours(0,0,0,0); d.setDate(d.getDate()+delta); return d; }
  function getNextWeekDates(){ const start=nextSunday(new Date()); const days=[]; for(let i=0;i<7;i++){ const di=new Date(start); di.setDate(start.getDate()+i); days.push(ymdLocal(di)); } return days; }
  function indicesForDates(dates, dailyTimes){ return dates.map(d => dailyTimes.indexOf(d)); }

  function convertToMs(v,u){
    try{ if(window.convertToMs) return window.convertToMs(v,u); }catch(e){}
    if(!Number.isFinite(v)) return NaN;
    switch(u){ case 'kmh': return v/3.6; case 'mph': return v*0.44704; case 'kn': return v*0.514444; default: return v; }
  }
  function hoursForDay(dayIdx, hourlyTimes){
    try{ if(window.hoursForDay) return window.hoursForDay(dayIdx, hourlyTimes); }catch(e){}
    const dateISO = window.__lastForecast?.data?.daily?.time?.[dayIdx];
    const idxs = [];
    for(let k=0;k<hourlyTimes.length;k++){ if (hourlyTimes[k].startsWith(dateISO)) idxs.push(k); if (idxs.length===24) break; }
    return idxs;
  }
  function formatDate(iso, locale){
    try{ if(window.formatDate) return window.formatDate(iso, locale||document.documentElement.lang); }catch(e){}
    const d = new Date(iso+'T00:00:00'); return d.toLocaleDateString(locale||'ar-EG',{weekday:'long', day:'numeric', month:'long', year:'numeric'});
  }
  function expectedProductionMWFromSheet(w_ms){
    try{ if(window.expectedProductionMWFromSheet) return window.expectedProductionMWFromSheet(w_ms); }catch(e){}
    const cut=3, rated=12, cap=100;
    if(!Number.isFinite(w_ms) || w_ms<=cut) return 0;
    if(w_ms>=rated) return cap;
    const n=(w_ms-cut)/(rated-cut); return Math.pow(n,3)*cap;
  }

  function renderWeeklyPanel(forecast){
    if (!forecast || !forecast.daily || !forecast.daily.time) return;
    const weekDates = getNextWeekDates();
    const idxList = indicesForDates(weekDates, forecast.daily.time);

    const startNice = new Date(weekDates[0] + 'T00:00:00');
    const endNice   = new Date(weekDates[6] + 'T00:00:00');
    const isEN = document.documentElement.lang === 'en';
    const loc = isEN ? 'en-GB' : 'ar-EG';
    const prefix = isEN ? 'Next week:' : 'ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿßŸÑŸÇÿßÿØŸÖ:';
    weeklyRangeEl.textContent = `${prefix} ${startNice.toLocaleDateString(loc,{weekday:'long', day:'numeric', month:'long'})} ‚Üí ${endNice.toLocaleDateString(loc,{weekday:'long', day:'numeric', month:'long'})}`;

    const missing = idxList.some(i => i === -1);
    if (weeklyPdfBtn) weeklyPdfBtn.disabled = missing;
    if (weeklyXlsBtn) weeklyXlsBtn.disabled = missing;

    if (missing){
      const isEN = document.documentElement.lang === 'en';
      if (typeof setStatus==='function') setStatus(isEN ? 'Weekly range not fully available yet. Ensure forecast_days=14, then refetch.' : 'ŸÜÿ∑ÿßŸÇ ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ŸÉÿßŸÖŸÑŸãÿß ÿ®ÿπÿØ. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ forecast_days=14 ÿ´ŸÖ ÿ£ÿπÿØ ÿßŸÑÿ¨ŸÑÿ®.', 'error');
    } /* ready: no status shown per request */

    if (weeklyPdfBtn) weeklyPdfBtn.onclick = () => window.generateWeeklyPDF(window.__lastForecast.data, idxList, window.__lastForecast.windUnit);
    if (weeklyXlsBtn) weeklyXlsBtn.onclick = () => window.exportWeeklyExcel(window.__lastForecast.data, idxList, window.__lastForecast.windUnit);
  }

  function generateWeeklyPDF(data, indices, windUnitUI){
    const { jsPDF } = window.jspdf || {}; if (!jsPDF || !window.jspdf.jsPDF || !window.jspdf.jsPDF.API.autoTable) { alert('ŸÖŸÉÿ™ÿ®ÿßÿ™ PDF ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©'); return; }
    const doc = new jsPDF({orientation:'portrait',unit:'pt',format:'a4'});
    const margin = 40;
    indices.forEach((dayIdx, p)=>{
      const dayISO = data.daily.time[dayIdx];
      if (p>0) doc.addPage();

      // --- Weekly logo on RIGHT like daily ---
      try {
        var __wkImg = (window.LOGO_WK_DATA_URL || (typeof LOGO_DATA_URL!=='undefined' ? LOGO_DATA_URL : ''));
        if (__wkImg) {
          var __type = __wkImg.indexOf('image/jpeg')>-1 ? 'JPEG' : 'PNG';
          var __pageW = doc.internal.pageSize.getWidth();
          var __logoW = 140, __logoH = 40;
          doc.addImage(__wkImg, __type, __pageW - margin - __logoW, 25, __logoW, __logoH);
        }
      } catch(e) { console.warn('weekly logo error', e); }

      doc.setFont('helvetica','bold').setFontSize(16);
      doc.text('Daily Forecast ‚Äì Expected Production (MW)', margin, 50);
      doc.setFont('helvetica','normal').setFontSize(11);
      const dateEn = formatDate(dayISO, 'en-GB');
      doc.text(`Location: RGWE`, margin, 75);
      doc.text(`Date: ${dateEn}`, margin, 95);
      const hIdx = hoursForDay(dayIdx, data.hourly.time).slice(0,24);
      const rows = []; let windSum=0, tempSum=0, totalProdMW=0;
      hIdx.forEach(k=>{
        const dt   = new Date(data.hourly.time[k]);
        const hour = dt.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'});
        const wMs  = convertToMs(getWindArray(data)[k], windUnitUI);
        const T    = data.hourly.temperature_2m[k];
        const prod = expectedProductionMWFromSheet(wMs);
        windSum += wMs; tempSum += T; totalProdMW += prod;
        rows.push([hour, wMs.toFixed(1), T.toFixed(1), prod.toFixed(3)]);
      });
      doc.autoTable({ startY:120, styles:{font:'helvetica',fontSize:10,cellPadding:6,halign:'center'}, headStyles:{fillColor:[243,244,246],textColor:20},
        head:[['Hour','Wind Speed (m/s)','Temperature (¬∞C)','Expected Production (MW)']], body:rows });
      const y = doc.lastAutoTable.finalY || 120;
      const avgW = rows.length? windSum/rows.length : 0; const avgT = rows.length? tempSum/rows.length : 0;
      doc.setFont('helvetica','bold'); doc.text('Summary',margin,y+30);
      doc.setFont('helvetica','normal'); doc.text(`Average wind speed (m/s): ${avgW.toFixed(2)}`, margin, y+50);
      doc.text(`Average temperature (¬∞C): ${avgT.toFixed(2)}`, margin, y+70);
      doc.text(`Total expected production (MW): ${totalProdMW.toFixed(3)}`, margin, y+90);
    });
    const wDates = indices.map(i => data.daily.time[i]);
    doc.save(`WeeklyForecast_${wDates[0]}_to_${wDates[6]}.pdf`);
  }
  window.generateWeeklyPDF = generateWeeklyPDF;

  function exportWeeklyExcel(data, indices, windUnitUI){
    if (!window.XLSX || !XLSX.utils || !XLSX.writeFile) { alert('ŸÖŸÉÿ™ÿ®ÿ© Excel ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©'); return; }
    const wb = XLSX.utils.book_new();
    const allRows = []; const merges = []; let currentRow = 0;
    indices.forEach((dayIdx, dayNo) => {
      const hoursIdx = hoursForDay(dayIdx, data.hourly.time).slice(0,24);
      const dayISO   = data.daily.time[dayIdx];
      const dateObj  = new Date(dayISO + 'T00:00:00');
      const year     = dateObj.getFullYear();
      const titleRow = new Array(26).fill(''); titleRow[0] = `Forecasted Output Of The Facility, RGWE ${year}`;
      allRows.push(titleRow); merges.push({ s: { r: currentRow, c: 0 }, e: { r: currentRow, c: 25 } }); currentRow += 1;
      const r1 = new Array(26).fill(''); const niceDate = dateObj.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');
      r1[0] = niceDate; for(let c=1;c<=24;c++){ const k  = hoursIdx[c-1]; r1[c] = (typeof k==='number')? new Date(data.hourly.time[k]).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'}) : ''; }
      allRows.push(r1); currentRow += 1;
      const windRow = new Array(26).fill(''); windRow[0] = 'Expected Wind Speed, m/s'; let windSum=0;
      hoursIdx.forEach((k,i)=>{ const wMs = convertToMs(getWindArray(data)[k], windUnitUI); windRow[i+1] = Number.isFinite(wMs) ? Math.round(wMs) : ''; windSum += wMs; });
      windRow[25] = hoursIdx.length? +(windSum/hoursIdx.length).toFixed(2) : ''; allRows.push(windRow); currentRow += 1;
      const availRow = new Array(26).fill(''); availRow[0] = 'Availability %'; for (let i = 0; i < 24; i++) { availRow[i+1] = 98; } availRow[25] = 98; allRows.push(availRow); currentRow += 1;
      const powerRow = new Array(26).fill(''); powerRow[0] = 'Expected Production, MW'; let powerSum=0;
      hoursIdx.forEach((k,i)=>{ const wMs = convertToMs(getWindArray(data)[k], windUnitUI); const prodMW = expectedProductionMWFromSheet(wMs); powerRow[i+1] = Number.isFinite(prodMW) ? +prodMW.toFixed(3) : ''; powerSum += prodMW; });
      powerRow[25] = +powerSum.toFixed(3); allRows.push(powerRow); currentRow += 1;
      if (dayNo !== indices.length - 1) { allRows.push(new Array(26).fill('')); currentRow += 1; }
    });
    const ws = XLSX.utils.aoa_to_sheet(allRows); ws['!merges'] = (ws['!merges'] || []).concat(merges);
    const rows = allRows.length, cols = 26;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const addr = XLSX.utils.encode_cell({ r, c }); if (!ws[addr]) continue;
        const cell = ws[addr]; cell.s = cell.s || {};
        cell.s.border = { top: {style:'thick', color:{rgb:'000000'}}, bottom: {style:'thick', color:{rgb:'000000'}}, left: {style:'thick', color:{rgb:'000000'}}, right: {style:'thick', color:{rgb:'000000'}} };
        const val = cell.v; const isNumeric = (typeof val === 'number') || (typeof val === 'string' && val.trim() !== '' && !isNaN(Number(val)));
        const isTimeLike = (typeof val === 'string') && /^\d{2}:\d{2}$/.test(val.trim());
        if (isNumeric || isTimeLike) { cell.s.alignment = Object.assign({}, cell.s.alignment || {}, { horizontal: 'center', vertical: 'center' }); }
      }
    }
    const wDates = indices.map(i => data.daily.time[i]);
    XLSX.utils.book_append_sheet(wb, ws, 'Weekly');
    XLSX.writeFile(wb, `WeeklyForecast_${wDates[0]}_to_${wDates[6]}_ONE_SHEET.xlsx`);
  }
  window.exportWeeklyExcel = exportWeeklyExcel;

  (function hookWeekly(){
    const _origHandleFetch = window.handleFetch;
    window.handleFetch = async function(){
      if (typeof _origHandleFetch === 'function') { await _origHandleFetch(); }
      try { if (window.__lastForecast?.data) { renderWeeklyPanel(window.__lastForecast.data); } } catch(e){ console.error(e); }
    };
  })();
})();
</script>
<script>
// === Override: Weekly Excel (single sheet) ‚Äî one title, add temperature row, thin borders ===
(function(){
  function exportWeeklyExcel(data, indices, windUnitUI){
    if (!window.XLSX || !XLSX.utils || !XLSX.writeFile) { alert('ŸÖŸÉÿ™ÿ®ÿ© Excel ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©'); return; }
    const wb = XLSX.utils.book_new();

    const allRows = [];
    const merges = [];

    // ---- Global title ONCE at the very top ----
    const yearAny = new Date((data.daily.time[indices[0]]||'') + 'T00:00:00').getFullYear();
    const globalTitle = new Array(26).fill('');
    globalTitle[0] = `Forecasted Output Of The Facility, RGWE ${yearAny}`;
    allRows.push(globalTitle);
    merges.push({ s: { r: 0, c: 0 }, e: { r: 0, c: 25 } });
    let currentRow = 1;

    // ---- Per-day blocks (no repeating title per day) ----
    indices.forEach((dayIdx, dayNo) => {
      const hoursIdx = (function(){
        // Reuse existing helper if present
        try { if (window.hoursForDay) return window.hoursForDay(dayIdx, data.hourly.time).slice(0,24); } catch(e){}
        const dateISO = data.daily.time[dayIdx];
        const idxs = [];
        for (let k=0; k<data.hourly.time.length; k++){
          if (data.hourly.time[k].startsWith(dateISO)){ idxs.push(k); if (idxs.length===24) break; }
        }
        return idxs;
      })();

      const dayISO   = data.daily.time[dayIdx];
      const dateObj  = new Date(dayISO + 'T00:00:00');

      // Row: Date + 24 times
      const r1 = new Array(26).fill('');
      const niceDate = dateObj.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');
      r1[0] = niceDate;
      for (let c=1; c<=24; c++){
        const k = hoursIdx[c-1];
        r1[c] = (typeof k==='number')
          ? new Date(data.hourly.time[k]).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'})
          : '';
      }
      allRows.push(r1); currentRow += 1;

      // Row: Expected Wind Speed, m/s  + avg at last col
      function toMs(v,u){
        try{ if(window.convertToMs) return window.convertToMs(v,u); }catch(e){}
        if (!Number.isFinite(v)) return NaN;
        return u==='kn' || u==='knots' ? v*0.514444 : (u==='kmh' ? v/3.6 : (u==='mph' ? v*0.44704 : v));
      }
      const windRow = new Array(26).fill(''); windRow[0] = 'Expected Wind Speed, m/s';
      let windSum = 0;
      hoursIdx.forEach((k,i)=>{ const wMs = toMs(getWindArray(data)[k], windUnitUI); windRow[i+1] = Number.isFinite(wMs) ? Math.round(wMs) : ''; windSum += (Number.isFinite(wMs)? wMs : 0); });
      const windCount = hoursIdx.filter(k=> typeof k === 'number').length || 1;
      windRow[25] = +(windSum / windCount).toFixed(2);
      allRows.push(windRow); currentRow += 1;

      // Row: Expected Temperature, ¬∞C  + avg at last col (NEW)
      const tempRow = new Array(26).fill(''); tempRow[0] = 'Expected Temperature, ¬∞C';
      let tempSum = 0, tempCount = 0;
      hoursIdx.forEach((k,i)=>{
        const T = data.hourly.temperature_2m[k];
        const v = Number.isFinite(T) ? +T : '';
        tempRow[i+1] = v;
        if (Number.isFinite(T)) { tempSum += T; tempCount++; }
      });
      tempRow[25] = tempCount ? +(tempSum/tempCount).toFixed(2) : '';
      allRows.push(tempRow); currentRow += 1;

      // Row: Availability %
      const availRow = new Array(26).fill('');
      availRow[0] = 'Availability %';
      for (let i = 0; i < 24; i++) { availRow[i+1] = 98; }
      availRow[25] = 98;
      allRows.push(availRow); currentRow += 1;

      // Row: Expected Production, MW  + daily total at last col
      function expectedProd(w_ms){
        try{ if(window.expectedProductionMWFromSheet) return window.expectedProductionMWFromSheet(w_ms); }catch(e){}
        const cut=3,rated=12,cap=100; if(!Number.isFinite(w_ms)||w_ms<=cut) return 0; if(w_ms>=rated) return cap; const n=(w_ms-cut)/(rated-cut); return Math.pow(n,3)*cap;
      }
      const powerRow = new Array(26).fill(''); powerRow[0] = 'Expected Production, MW';
      let powerSum=0;
      hoursIdx.forEach((k,i)=>{ const wMs = toMs(getWindArray(data)[k], windUnitUI); const prodMW = expectedProd(wMs); powerRow[i+1] = Number.isFinite(prodMW) ? +prodMW.toFixed(3) : ''; powerSum += (Number.isFinite(prodMW)? prodMW : 0); });
      powerRow[25] = +powerSum.toFixed(3);
      allRows.push(powerRow); currentRow += 1;

      // Blank spacer row between days
      if (dayNo !== indices.length - 1) { allRows.push(new Array(26).fill('')); currentRow += 1; }
    });

    const ws = XLSX.utils.aoa_to_sheet(allRows);
    ws['!merges'] = (ws['!merges'] || []).concat(merges);

    // === THIN borders for all cells (instead of thick) ===
    const rows = allRows.length, cols = 26;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        if (!ws[addr]) continue;
        const cell = ws[addr]; cell.s = cell.s || {};
        cell.s.border = {
          top: {style:'thin', color:{rgb:'000000'}},
          bottom: {style:'thin', color:{rgb:'000000'}},
          left: {style:'thin', color:{rgb:'000000'}},
          right: {style:'thin', color:{rgb:'000000'}}
        };
        const val = cell.v;
        const isNumeric = (typeof val === 'number') || (typeof val === 'string' && val.trim() !== '' && !isNaN(Number(val)));
        const isTimeLike = (typeof val === 'string') && /^\d{2}:\d{2}$/.test(val.trim());
        if (isNumeric || isTimeLike || r===0) {
          cell.s.alignment = Object.assign({}, cell.s.alignment || {}, { horizontal: 'center', vertical: 'center' });
        }
      }
    }
    // Style the single global title row (bold + larger font)
    const titleAddr = XLSX.utils.encode_cell({ r: 0, c: 0 });
    if (ws[titleAddr]){
      ws[titleAddr].s = ws[titleAddr].s || {};
      ws[titleAddr].s.font = Object.assign({}, ws[titleAddr].s.font || {}, { bold: true, sz: 14 });
      ws[titleAddr].s.alignment = Object.assign({}, ws[titleAddr].s.alignment || {}, { horizontal: 'center', vertical: 'center' });
    }

    const wDates = indices.map(i => data.daily.time[i]);
    XLSX.utils.book_append_sheet(wb, ws, 'Weekly');
    XLSX.writeFile(wb, `WeeklyForecast_${wDates[0]}_to_${wDates[6]}_ONE_SHEET.xlsx`);
  }

  // expose override
  window.exportWeeklyExcel = exportWeeklyExcel;
})();
</script>
<script>
// === Override v3: Weekly Excel (one top time header, no spacer rows, thin borders) ===
(function(){
  function exportWeeklyExcel(data, indices, windUnitUI){
    if (!window.XLSX || !XLSX.utils || !XLSX.writeFile) { alert('ŸÖŸÉÿ™ÿ®ÿ© Excel ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©'); return; }
    const wb = XLSX.utils.book_new();
    const allRows = [];
    const merges = [];

    // Global title once
    const yearAny = new Date((data.daily.time[indices[0]]||'') + 'T00:00:00').getFullYear();
    const titleRow = new Array(26).fill('');
    titleRow[0] = `Forecasted Output Of The Facility, RGWE ${yearAny}`;
    allRows.push(titleRow);
    merges.push({ s: { r: 0, c: 0 }, e: { r: 0, c: 25 } });

    // Single time header row
    const headerRow = new Array(26).fill('');
    headerRow[0] = 'Date / Metric';
    for (let h=0; h<24; h++){ headerRow[1+h] = `${String(h).padStart(2,'0')}:00`; }
    headerRow[25] = 'Avg / Total';
    allRows.push(headerRow);

    function toMs(v,u){
      try{ if(window.convertToMs) return window.convertToMs(v,u); }catch(e){}
      if (!Number.isFinite(v)) return NaN;
      return u==='kn' || u==='knots' ? v*0.514444 : (u==='kmh' ? v/3.6 : (u==='mph' ? v*0.44704 : v));
    }
    function expectedProd(w_ms){
      try{ if(window.expectedProductionMWFromSheet) return window.expectedProductionMWFromSheet(w_ms); }catch(e){}
      const cut=3,rated=12,cap=100; if(!Number.isFinite(w_ms)||w_ms<=cut) return 0; if(w_ms>=rated) return cap; const n=(w_ms-cut)/(rated-cut); return Math.pow(n,3)*cap;
    }
    function hoursForDay(dayIdx, hourlyTimes){
      try{ if(window.hoursForDay) return window.hoursForDay(dayIdx, hourlyTimes).slice(0,24); }catch(e){}
      const dateISO = data.daily.time[dayIdx];
      const idxs = [];
      for (let k=0; k<data.hourly.time.length; k++){
        if (data.hourly.time[k].startsWith(dateISO)){ idxs.push(k); if (idxs.length===24) break; }
      }
      return idxs;
    }

    // Append per-day blocks: 4 rows each (wind, temp, avail, production), no blank rows
    indices.forEach((dayIdx) => {
      const hoursIdx = hoursForDay(dayIdx, data.hourly.time);
      const dayISO   = data.daily.time[dayIdx];
      const dateObj  = new Date(dayISO + 'T00:00:00');
      const niceDate = dateObj.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');

      // Wind
      const windRow = new Array(26).fill(''); windRow[0] = `${niceDate} ‚Äì Expected Wind Speed, m/s`;
      let windSum=0, windCount=0;
      hoursIdx.forEach((k,i)=>{ const wMs = toMs(getWindArray(data)[k], windUnitUI); const v = Number.isFinite(wMs)? Math.round(wMs) : ''; windRow[i+1]=v; if(Number.isFinite(wMs)){ windSum+=wMs; windCount++; } });
      windRow[25] = windCount ? +(windSum/windCount).toFixed(2) : ''; allRows.push(windRow);

      // Temperature
      const tempRow = new Array(26).fill(''); tempRow[0] = 'Expected Temperature, ¬∞C';
      let tempSum=0, tempCount=0;
      hoursIdx.forEach((k,i)=>{ const T = data.hourly.temperature_2m[k]; tempRow[i+1] = Number.isFinite(T) ? +T : ''; if(Number.isFinite(T)){ tempSum+=T; tempCount++; } });
      tempRow[25] = tempCount ? +(tempSum/tempCount).toFixed(2) : ''; allRows.push(tempRow);

      // Availability
      const availRow = new Array(26).fill(''); availRow[0] = 'Availability %';
      for (let i=0;i<24;i++) availRow[i+1] = 98;
      availRow[25] = 98; allRows.push(availRow);

      // Production
      const powerRow = new Array(26).fill(''); powerRow[0] = 'Expected Production, MW';
      let powerSum=0;
      hoursIdx.forEach((k,i)=>{ const wMs = toMs(getWindArray(data)[k], windUnitUI); const prodMW = expectedProd(wMs); powerRow[i+1] = Number.isFinite(prodMW) ? +prodMW.toFixed(3) : ''; powerSum += (Number.isFinite(prodMW)? prodMW : 0); });
      powerRow[25] = +powerSum.toFixed(3); allRows.push(powerRow);
    });

    const ws = XLSX.utils.aoa_to_sheet(allRows);
    ws['!merges'] = (ws['!merges'] || []).concat(merges);

    // Thin borders and alignment
    const rows = allRows.length, cols = 26;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        if (!ws[addr]) continue;
        const cell = ws[addr]; cell.s = cell.s || {};
        cell.s.border = {
          top: {style:'thin', color:{rgb:'000000'}},
          bottom: {style:'thin', color:{rgb:'000000'}},
          left: {style:'thin', color:{rgb:'000000'}},
          right: {style:'thin', color:{rgb:'000000'}}
        };
        const val = cell.v;
        const isNumeric = (typeof val === 'number') || (typeof val === 'string' && val.trim() !== '' && !isNaN(Number(val)));
        const isTimeLike = (typeof val === 'string') && /^\\d{2}:\\d{2}$/.test(val.trim());
        if (isNumeric || isTimeLike || r<=1) {
          cell.s.alignment = Object.assign({}, cell.s.alignment || {}, { horizontal: 'center', vertical: 'center' });
        }
        if (r===0){ // title row bold big
          cell.s.font = Object.assign({}, cell.s.font || {}, { bold: true, sz: 14 });
        }
        if (r===1){ // header row bold\n          cell.s.font = Object.assign({}, cell.s.font || {}, { bold: true });\n        }\n      }\n    }\n\n    const wDates = indices.map(i => data.daily.time[i]);\n    XLSX.utils.book_append_sheet(wb, ws, 'Weekly');\n    XLSX.writeFile(wb, `WeeklyForecast_${wDates[0]}_to_${wDates[6]}_ONE_SHEET.xlsx`);\n  }\n\n  window.exportWeeklyExcel = exportWeeklyExcel;\n})();\n</script>\n

<script>
/* === Override v4 (forced) ‚Äî Weekly Excel:
   - Single time header row at top (00:00..23:00)
   - All days appended into ONE continuous table (no blank rows)
   - Thin borders
   - Hard-bind the Weekly Excel button at capture phase to ensure using this function
*/
(function(){
  // Helpers (local, so we don't depend on earlier scopes)
  function ymdLocal(d){ const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; }
  function nextSunday(from = new Date()){ const day=from.getDay(); const delta=((7-day)%7)||7; const d=new Date(from); d.setHours(0,0,0,0); d.setDate(d.getDate()+delta); return d; }
  function getNextWeekDates(){ const start=nextSunday(new Date()); const days=[]; for(let i=0;i<7;i++){ const di=new Date(start); di.setDate(start.getDate()+i); days.push(ymdLocal(di)); } return days; }
  function indicesForDates(dates, dailyTimes){ return dates.map(d => dailyTimes.indexOf(d)); }
  function toMs(v,u){
    try{ if(window.convertToMs) return window.convertToMs(v,u); }catch(e){}
    if (!Number.isFinite(v)) return NaN;
    return u==='kn' || u==='knots' ? v*0.514444 : (u==='kmh' ? v/3.6 : (u==='mph' ? v*0.44704 : v));
  }
  function expectedProd(w_ms){
    try{ if(window.expectedProductionMWFromSheet) return window.expectedProductionMWFromSheet(w_ms); }catch(e){}
    const cut=3,rated=12,cap=100; if(!Number.isFinite(w_ms)||w_ms<=cut) return 0; if(w_ms>=rated) return cap; const n=(w_ms-cut)/(rated-cut); return Math.pow(n,3)*cap;
  }
  function hoursForDay(dayIdx, hourlyTimes){
    try{ if(window.hoursForDay) return window.hoursForDay(dayIdx, hourlyTimes).slice(0,24); }catch(e){}
    const dateISO = window.__lastForecast?.data?.daily?.time?.[dayIdx];
    const idxs = [];
    for (let k=0; k<hourlyTimes.length; k++){
      if (hourlyTimes[k].startsWith(dateISO)){ idxs.push(k); if (idxs.length===24) break; }
    }
    return idxs;
  }

  function exportWeeklyExcelV4(data, indices, windUnitUI){
    if (!window.XLSX || !XLSX.utils || !XLSX.writeFile) { alert('ŸÖŸÉÿ™ÿ®ÿ© Excel ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÅÿ±ÿ©'); return; }
    const wb = XLSX.utils.book_new();
    const allRows = [];
    const merges = [];

    // Global title once
    const yearAny = new Date((data.daily.time[indices[0]]||'') + 'T00:00:00').getFullYear();
    const titleRow = new Array(26).fill('');
    titleRow[0] = `Forecasted Output Of The Facility, RGWE ${yearAny}`;
    allRows.push(titleRow);
    merges.push({ s: { r: 0, c: 0 }, e: { r: 0, c: 25 } });

    // Single time header row
    const headerRow = new Array(26).fill('');
    headerRow[0] = 'Date / Metric';
    for (let h=0; h<24; h++){ headerRow[1+h] = `${String(h).padStart(2,'0')}:00`; }
    headerRow[25] = 'Avg / Total';
    allRows.push(headerRow);

    // Append per-day blocks: 4 rows (wind, temp, avail, production) ‚Äî NO blank rows
    indices.forEach((dayIdx) => {
      const idxs = hoursForDay(dayIdx, data.hourly.time);
      const dayISO   = data.daily.time[dayIdx];
      const dateObj  = new Date(dayISO + 'T00:00:00');
      const niceDate = dateObj.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');

      // Wind
      const windRow = new Array(26).fill(''); windRow[0] = `${niceDate} ‚Äì Expected Wind Speed, m/s`;
      let windSum=0, windCount=0;
      idxs.forEach((k,i)=>{ const wMs = toMs(getWindArray(data)[k], windUnitUI); const v = Number.isFinite(wMs)? Math.round(wMs) : ''; windRow[i+1]=v; if(Number.isFinite(wMs)){ windSum+=wMs; windCount++; } });
      windRow[25] = windCount ? +(windSum/windCount).toFixed(2) : ''; allRows.push(windRow);

      // Temperature
      const tempRow = new Array(26).fill(''); tempRow[0] = 'Expected Temperature, ¬∞C';
      let tempSum=0, tempCount=0;
      idxs.forEach((k,i)=>{ const T = data.hourly.temperature_2m[k]; tempRow[i+1] = Number.isFinite(T) ? +T : ''; if(Number.isFinite(T)){ tempSum+=T; tempCount++; } });
      tempRow[25] = tempCount ? +(tempSum/tempCount).toFixed(2) : ''; allRows.push(tempRow);

      // Availability
      const availRow = new Array(26).fill(''); availRow[0] = 'Availability %';
      for (let i=0;i<24;i++) availRow[i+1] = 98;
      availRow[25] = 98; allRows.push(availRow);

      // Production
      const powerRow = new Array(26).fill(''); powerRow[0] = 'Expected Production, MW';
      let powerSum=0;
      idxs.forEach((k,i)=>{ const wMs = toMs(getWindArray(data)[k], windUnitUI); const prodMW = expectedProd(wMs); powerRow[i+1] = Number.isFinite(prodMW) ? +prodMW.toFixed(3) : ''; powerSum += (Number.isFinite(prodMW)? prodMW : 0); });
      powerRow[25] = +powerSum.toFixed(3); allRows.push(powerRow);
    });

    const ws = XLSX.utils.aoa_to_sheet(allRows);
    ws['!merges'] = (ws['!merges'] || []).concat(merges);

    // Thin borders & alignment
    const rows = allRows.length, cols = 26;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        if (!ws[addr]) continue;
        const cell = ws[addr]; cell.s = cell.s || {};
        cell.s.border = {
          top: {style:'thin', color:{rgb:'000000'}},
          bottom: {style:'thin', color:{rgb:'000000'}},
          left: {style:'thin', color:{rgb:'000000'}},
          right: {style:'thin', color:{rgb:'000000'}}
        };
        const val = cell.v;
        const isNumeric = (typeof val === 'number') || (typeof val === 'string' && val.trim() !== '' && !isNaN(Number(val)));
        const isTimeLike = (typeof val === 'string') && /^\\d{2}:\\d{2}$/.test(val?.toString().trim());
        if (isNumeric || isTimeLike || r<=1) {
          cell.s.alignment = Object.assign({}, cell.s.alignment || {}, { horizontal: 'center', vertical: 'center' });
        }
        if (r===0){ cell.s.font = Object.assign({}, cell.s.font || {}, { bold: true, sz: 14 }); }
        if (r===1){ cell.s.font = Object.assign({}, cell.s.font || {}, { bold: true }); }
        if (r>=2 && c===0){ cell.s.font = Object.assign({}, cell.s.font || {}, { bold: true }); }
      }
    }

    const wDates = indices.map(i => data.daily.time[i]);
    XLSX.utils.book_append_sheet(wb, ws, 'Weekly');
    XLSX.writeFile(wb, `WeeklyForecast_${wDates[0]}_to_${wDates[6]}_ONE_TABLE.xlsx`);
  }

  // Make globally accessible
  window.exportWeeklyExcelV4 = exportWeeklyExcelV4;
  window.exportWeeklyExcel   = exportWeeklyExcelV4; // override any previous one

  // Hard-bind the button at capture phase so we bypass older handlers
  document.addEventListener('click', function(ev){
    const btn = ev.target && ev.target.closest && ev.target.closest('#weeklyXlsBtn');
    if (!btn) return;
    ev.stopImmediatePropagation && ev.stopImmediatePropagation();
    ev.stopPropagation();
    ev.preventDefault();

    const store = window.__lastForecast;
    const data = store && store.data;
    if(!data || !data.daily || !data.daily.time){ alert('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿπÿØ. ÿßÿ∂ÿ∫ÿ∑ \"ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§\" ÿ£ŸàŸÑŸãÿß.'); return; }

    const weekDates = getNextWeekDates();
    const idxList = indicesForDates(weekDates, data.daily.time);
    if (idxList.some(i=> i===-1)) { alert('ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿßŸÑŸÇÿßÿØŸÖ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸÖŸÑÿ©. ÿ™ÿ£ŸÉÿØ ÿ£ŸÜ forecast_days=14 ÿ´ŸÖ ÿ£ÿπÿØ ÿßŸÑÿ¨ŸÑÿ®.'); return; }

    window.exportWeeklyExcelV4(data, idxList, store.windUnit);
  }, true);
})();
</script>
<script>
(function(){
  function toMs(v,u){
    try{ if(window.convertToMs) return window.convertToMs(v,u); }catch(e){}
    if (!Number.isFinite(v)) return NaN;
    return u==='kn'||u==='knots'? v*0.514444 : (u==='kmh'? v/3.6 : (u==='mph'? v*0.44704 : v));
  }
  function hoursForDaySafe(dayIdx, hourlyTimes){
    try{ if(window.hoursForDay) return window.hoursForDay(dayIdx, hourlyTimes).slice(0,24); }catch(e){}
    const dateISO = window.__lastForecast?.data?.daily?.time?.[dayIdx];
    const idxs = [];
    for (let k=0; k<hourlyTimes.length; k++){
      if (hourlyTimes[k].startsWith(dateISO)){ idxs.push(k); if (idxs.length===24) break; }
    }
    return idxs;
  }
  function escHtml(s){ return String(s).replace(/[&<>"]/g, m=>({ '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;'}[m])); }

  function buildDayEmailHTML(index, data, windUnitUI){
    const dayISO = data.daily.time[index];
    const dt0 = new Date(dayISO + 'T00:00:00');
    const niceDate = dt0.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');

    const hIdx = hoursForDaySafe(index, data.hourly.time);
    const times = [];
    for (let c=0;c<24;c++){
      const k = hIdx[c];
      times.push(typeof k==='number' ? new Date(data.hourly.time[k]).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'}) : '');
    }

    let windSum = 0, windCnt = 0;
    const windRow = [];
    for (let i=0;i<24;i++){
      const k = hIdx[i]; const w = toMs(getWindArray(data)[k], windUnitUI);
      const cell = Number.isFinite(w) ? Math.round(w) : '';
      windRow.push(cell);
      if (Number.isFinite(w)){ windSum += w; windCnt++; }
    }
    const windAvg = windCnt ? (windSum/windCnt).toFixed(2) : '';

    const availRow = Array.from({length:24}, ()=>98);

    let pSum = 0;
    const prodRow = [];
    for (let i=0;i<24;i++){
      const k = hIdx[i]; const w = toMs(getWindArray(data)[k], windUnitUI);
      const prodMW = (typeof window.expectedProductionMWFromSheet==='function') ? window.expectedProductionMWFromSheet(w) : 0;
      const v = Number.isFinite(prodMW) ? (+prodMW).toFixed(3) : '';
      prodRow.push(v);
      if (Number.isFinite(prodMW)) pSum += prodMW;
    }
    const prodTotal = pSum.toFixed(3);

    const cell = 'style="border:1px solid #000;padding:8px;text-align:center;font:14px Arial,Helvetica,sans-serif"';
    const cellL= 'style="border:1px solid #000;padding:8px;text-align:left;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
    const head = 'style="border:1px solid #000;padding:8px;text-align:center;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
    const title = 'style="text-align:center; text-align:center; padding:10px 6px;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
    const wrap = 'style="border-collapse:collapse;width:100%;max-width:1300px"';

    const tHeader = `
      <tr>
        <td ${cellL}>${escHtml(niceDate)}</td>
        ${times.map(t=>`<td ${head}>${escHtml(t)}</td>`).join('')}
        <td ${head}>Avg / Total</td>
      </tr>`;

    return `
      <div style="font:13px Arial,Helvetica,sans-serif;color:#000"><p style="margin:0 0 12px 0; white-space:pre-line">Dear all,\n\nAttached below is the RGWE forecasted output of the facility for your appreciated interest.</p>
        <div ${title}>Forecasted Output Of The Facility, RGWE 2025</div>
        <table ${wrap}>
          ${tHeader}
          <tr><td ${cellL}>Expected Wind Speed, m/s</td>${windRow.map(v=>`<td ${cell}>${escHtml(v)}</td>`).join('')}<td ${cell}>${escHtml(windAvg)}</td></tr>
          <tr><td ${cellL}>Availability %</td>${availRow.map(v=>`<td ${cell}>${v}</td>`).join('')}<td ${cell}>98</td></tr>
          <tr><td ${cellL}>Expected Production, MW</td>${prodRow.map(v=>`<td ${cell}>${escHtml(v)}</td>`).join('')}<td ${cell}>${escHtml(prodTotal)}</td></tr>
        </table>
      </div>`;
  }

  function saveAsEml({subject, html, to='', cc=''}){
    function b64(s){ return btoa(unescape(encodeURIComponent(s))); }
    const eml =
      (to ? ('To: '+to+'
') : '') +
      'X-Unsent: 1
' +
      'Subject: '+subject+'
' +
      'MIME-Version: 1.0
' +
      'Content-Type: text/html; charset=UTF-8
' +
      'Content-Transfer-Encoding: base64

' +
      b64(html);
    const blob = new Blob([eml], {type:'message/rfc822'});
    const url  = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = subject.replace(/[^a-z0-9_\-]+/gi,'_') + '.eml';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 2000);
  }

  window.exportEmailEML = function(index, data, windUnitUI){
    if(!data || !data.daily || !data.hourly){ alert('ÿ±ÿ¨ÿßÿ°Ÿã ÿ≠ÿØŸëŸêÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§ ÿ£ŸàŸÑŸãÿß.'); return; }
    const langEN = document.documentElement.lang === 'en';
    const dayISO = data.daily.time[index];
    const dt0 = new Date(dayISO + 'T00:00:00');
    const niceDate = dt0.toLocaleDateString(langEN?'en-GB':'ar-EG',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');
    const subject = 'Forecasted Output Of The Facility - RGWE';

    const inpTo = document.getElementById('emailTo');
      const toList = (inpTo && inpTo.value) ? inpTo.value.split(/[;,]/).map(s=>s.trim()).filter(Boolean) : (typeof window.__rgwe_getToList==='function' ? window.__rgwe_getToList() : []);
      const toHeader = (toList && toList.length) ? toList.join(', ') : '';
    const ccList = (typeof window.__rgwe_getCcList==='function') ? window.__rgwe_getCcList() : [];
    const ccHeader = (ccList && ccList.length) ? ccList.join(', ') : '';

    const html = buildDayEmailHTML(index, data, windUnitUI);
    saveAsEml({subject, html, to: toHeader, cc: ccHeader});
  };
  };
})();
</script>
<script>
(function(){
  // --- helpers added to improve reliability ---
  function stripHtml(html){ const div=document.createElement('div'); div.innerHTML = html; return div.textContent || div.innerText || ''; }

  async function copyHtmlToClipboard(html){
    try{
      if (navigator.clipboard && window.ClipboardItem){
        const item = new ClipboardItem({
          "text/html": new Blob([html], {type:"text/html"}),
          "text/plain": new Blob([stripHtml(html)], {type:"text/plain"})
        });
        await navigator.clipboard.write([item]);
        return true;
      }else{
        // fallback: execCommand
        const div = document.createElement('div');
        div.contentEditable = 'true';
        div.style.position='fixed'; div.style.opacity='0'; div.style.pointerEvents='none';
        document.body.appendChild(div);
        div.innerHTML = html;
        const range = document.createRange();
        range.selectNodeContents(div);
        const sel = window.getSelection();
        sel.removeAllRanges(); sel.addRange(range);
        const ok = document.execCommand('copy');
        document.body.removeChild(div);
        return ok;
      }
    }catch(e){ console.warn('Clipboard copy failed', e); return false; }
  }

  function openOWACompose(subject){
    const toList = (typeof window.__rgwe_getToList==='function') ? window.__rgwe_getToList() : [];
    const toParam = encodeURIComponent(toList.join(';'));
    const url = 'https://outlook.office.com/mail/deeplink/compose?to=' + toParam + '&subject=' + encodeURIComponent(subject) + '&body=' + encodeURIComponent('(Paste the table here)‚Ä¶');
    window.open(url, '_blank', 'noopener');
  }

  function openMailto(subject){
    window.location.href = 'mailto:?subject=' + encodeURIComponent(subject);
  }

  // Monkey-patch exportEmailEML to include robust fallback sequence
  if (window.exportEmailEML){
    const _orig = window.exportEmailEML;
    window.exportEmailEML = async function(index, data, windUnitUI){
      try{
        _orig(index, data, windUnitUI); // try EML method first
      }catch(e){
        console.warn('EML export failed:', e);
      }
      // Always also try to copy HTML and open compose, to satisfy strict environments
      try{
        // We need the same HTML used by _orig; rebuild quickly by calling internal builder if available
        let html = null;
        if (typeof buildDayEmailHTML === 'function') {
          html = buildDayEmailHTML(index, data, windUnitUI);
        }
        if (html){
          const ok = await copyHtmlToClipboard(html);
          const subject = 'Forecasted Output Of The Facility - RGWE';
          // Prefer OWA compose (web) if available, otherwise fall back to mailto (desktop)
          // openOWACompose(subject); // disabled to use Outlook draft via EML
if (!ok){
            setTimeout(()=>{
              openMailto(subject);
              alert('ÿ™ŸÖ ŸÅÿ™ÿ≠ ŸÜÿßŸÅÿ∞ÿ© ÿßŸÑÿ•ŸäŸÖŸäŸÑ. ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ∏Ÿáÿ± ÿßŸÑÿ¨ÿØŸàŸÑ ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿßÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÑÿµŸÇ (Ctrl+V) ŸÑÿ•ÿØÿ±ÿßÿ¨ ÿßŸÑÿ¨ÿØŸàŸÑ ÿßŸÑŸÖŸÜÿ≥ŸàÿÆ.');
            }, 400);
          }else{
            alert('ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑÿ¨ÿØŸàŸÑ ÿ®ÿµŸäÿ∫ÿ© HTML. ÿ®ÿπÿØ ŸÅÿ™ÿ≠ ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿ•ŸäŸÖŸäŸÑÿå ÿßÿ∂ÿ∫ÿ∑ ŸÑÿµŸÇ (Ctrl+V) ŸÑŸäÿ∏Ÿáÿ± ÿßŸÑÿ¨ÿØŸàŸÑ.');
          }
        }
      }catch(e){
        console.warn('Fallback compose failed:', e);
      }
    };
  }

  // Improve saveAsEml to try open in new tab before download (for some browsers)
  if (typeof saveAsEml === 'function'){
    const _save = saveAsEml;
    window.saveAsEml = function(opts){
      try{
        // call original to construct blob+download
        _save(opts);
      }catch(e){ console.warn('saveAsEml download failed', e); }
      try{
        // additionally try navigating to object URL (some browsers will prompt app)
        const eml =
          'Subject: ' + (opts.subject||'') + '\\r\\n' +
          'MIME-Version: 1.0\\r\\n' +
          'Content-Type: text/html; charset=UTF-8\\r\\n' +
          'Content-Transfer-Encoding: base64\\r\\n\\r\\n' +
          (function(){ try{ return btoa(unescape(encodeURIComponent(opts.html||''))); }catch(e){ return ''; } })();
        const blob = new Blob([eml], {type:'message/rfc822'});
        const url = URL.createObjectURL(blob);
        const w = window.open(url, '_blank');
        setTimeout(()=>URL.revokeObjectURL(url), 60000);
      }catch(e){ console.warn('Opening EML in new tab failed', e); }
    };
  }
})();
</script>
<script>
(function(){
  function parseToList(raw){
    if (!raw) return [];
    return raw.split(/[;,]/).map(s=>s.trim()).filter(Boolean);
  }
  function normalizeToHeader(list){ return list.join(', '); } // for EML
  function normalizeToOWA(list){ return list.join(';'); } // for OWA
  function normalizeToMailto(list){ return list.join(','); } // for mailto

  function setToValue(v){ try{ localStorage.setItem('rgwe_to', v || ''); }catch(e){} }
  function getToValue(){ try{ return localStorage.getItem('rgwe_to') || ''; }catch(e){ return ''; } }

  const DEFAULT_TO = "tarikeng@yahoo.com; roody_rfr2020@yahoo.com; Rasha_boot@yahoo.com; NECC <necc.2@hotmail.com>; hgadsuez@yahoo.com; hamidaelsanea@gmail.com; Eng.elharirya@gmail.com; eman_eetc@yahoo.com; control.system.necc@gmail.com; ashraflotfih@gmail.com; eng_abdelfatah73@yahoo.com";

  window.__rgwe_getToList = function(){
    const inp = document.getElementById('emailTo');
    const raw = inp && inp.value ? inp.value : getToValue();
    return parseToList(raw);
  };
  window.__rgwe_getCcList = function(){
    const inp = document.getElementById('emailCc');
    const stored = (function(){ try{ return localStorage.getItem('rgwe_cc') || ''; }catch(e){ return ''; } })();
    const raw = inp && inp.value ? inp.value : stored;
    return parseToList(raw);
  };

  document.addEventListener('DOMContentLoaded', function(){
    const inp = document.getElementById('emailTo');
    if (inp){
      if (!getToValue()) { try{ localStorage.setItem('rgwe_to', DEFAULT_TO); }catch(e){} }
      if (!getToValue() && inp.value) { try{ localStorage.setItem('rgwe_to', inp.value); }catch(e){} }
      inp.value = getToValue() || inp.value;
      inp.addEventListener('change', ()=> setToValue(inp.value));
      inp.addEventListener('blur', ()=> setToValue(inp.value));
    }
  });
})();
</script>
<script>
// === Weekly Email Exporter ‚Äî v6 (standalone, preserve Excel button) ===
(function(){
  function saveAsEmlWeekly(params){
    try{
      var subject = params.subject || '';
      var html    = params.html || '';
      var to      = params.to || '';
      var cc      = params.cc || '';
      var headers = [
        'X-Unsent: 1',
        (to ? 'To: ' + to : ''),
        (cc ? 'Cc: ' + cc : ''),
        'Subject: ' + subject,
        'MIME-Version: 1.0',
        'Content-Type: text/html; charset=UTF-8',
        'Content-Transfer-Encoding: base64'
      ].filter(Boolean).join('\r\n');
      function b64(s){ return btoa(unescape(encodeURIComponent(s))); }
      var eml = headers + '\r\n\r\n' + b64(html);
      try{
        var blob = new Blob([eml], {type:'message/rfc822'});
        var url  = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url; a.download = 'RGWE_weekly_forecast.eml';
        document.body.appendChild(a); a.click();
        setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 1200);
      }catch(e){
        var a2 = document.createElement('a');
        a2.href = 'data:message/rfc822;charset=utf-8,' + encodeURIComponent(eml);
        a2.download = 'RGWE_weekly_forecast.eml';
        document.body.appendChild(a2); a2.click(); a2.remove();
      }
    }catch(e){ alert('EML save failed (v6): ' + e.message); }
  }

  function esc(s){ return String(s==null? '' : s).replace(/&/,'&amp;').replace(/</,'&lt;').replace(/>/,'&gt;'); }

  function toMsLocal(v,u){
    if (typeof v!=='number' || !isFinite(v)) return NaN;
    u = (u||'').toLowerCase();
    if (u==='kn'||u==='kts'||u==='knot'||u==='knots') return v*0.514444;
    if (u==='kmh'||u==='km/h') return v/3.6;
    if (u==='mph') return v*0.44704;
    return v;
  }

  function buildWeekly(indices, data, windUnitUI){
    var yearAny = new Date((data.daily.time[indices[0]]||'') + 'T00:00:00').getFullYear();
    var cell  = 'style="border:1px solid #000;padding:8px;text-align:center;font:14px Arial,Helvetica,sans-serif"';
    var cellL = 'style="border:1px solid #000;padding:8px;text-align:left;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
    var head  = 'style="border:1px solid #000;padding:8px;text-align:center;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
    var title = 'style="text-align:center; padding:10px 6px;font:16px Arial,Helvetica,sans-serif;font-weight:bold;color:#000"';
    var wrap  = 'style="border-collapse:collapse;width:100%;max-width:1300px"';

    var blocks = [];
    for (var h=0; h<indices.length; h++){
      var index = indices[h];
      var dayISO = data.daily.time[index];
      var dt0    = new Date(dayISO + 'T00:00:00');
      var nice   = dt0.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'});
      nice = nice.split('/').join('-');

      var hIdx = [];
      for (var k=0; k<data.hourly.time.length; k++){
        var t = data.hourly.time[k];
        if (t && t.indexOf(dayISO)===0){ hIdx.push(k); if (hIdx.length===24) break; }
      }

      var times = [];
      for (var c=0;c<24;c++){
        var hk = hIdx[c];
        times.push(typeof hk==='number' ? new Date(data.hourly.time[hk]).toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'}) : '');
      }

      var wSum=0, wCnt=0, windRow=[];
      for (var i=0;i<24;i++){
        var k1=hIdx[i]; var w=toMsLocal(getWindArray(data)[k1], windUnitUI);
        var v=(isFinite(w)? Math.round(w): '');
        windRow.push(v); if (isFinite(w)){ wSum+=w; wCnt++; }
      }
      var wAvg = wCnt? (wSum/wCnt).toFixed(2) : '';

      var tSum=0, tCnt=0, tempRow=[];
      for (var j=0;j<24;j++){
        var k2=hIdx[j]; var T=data.hourly.temperature_2m[k2];
        var v2=(isFinite(T)? (+T).toFixed(1): '');
        tempRow.push(v2); if (isFinite(T)){ tSum+=T; tCnt++; }
      }
      var tAvg = tCnt? (tSum/tCnt).toFixed(2) : '';

      var avail = 98;
      try{ var availInp = document.getElementById('avail'); if (availInp) { var aVal = parseFloat(availInp.value); if (!isNaN(aVal)) avail = aVal; } }catch(e){}
      var availRow = new Array(24).fill(avail);

      var pSum=0, prodRow=[];
      for (var m=0;m<24;m++){
        var k3=hIdx[m]; var w3=toMsLocal(getWindArray(data)[k3], windUnitUI);
        var prodMW = (typeof window.expectedProductionMWFromSheet==='function') ? window.expectedProductionMWFromSheet(w3) : 0;
        var pv = (isFinite(prodMW)? (+prodMW).toFixed(3): '');
        prodRow.push(pv); if (isFinite(prodMW)) pSum += prodMW;
      }
      var pTot = pSum.toFixed(3);

      blocks.push(
        '<tr><td '+cellL+'>'+esc(nice)+'</td>'+
        times.map(function(t){return '<td '+head+'>'+esc(t)+'</td>';}).join('')+
        '<td '+head+'>Avg / Total</td></tr>'+
        '<tr><td '+cellL+'>Expected Wind Speed, m/s</td>'+windRow.map(function(v){return '<td '+cell+'>'+esc(v)+'</td>';}).join('')+'<td '+cell+'>'+esc(wAvg)+'</td></tr>'+
        '<tr><td '+cellL+'>Expected Temperature, ¬∞C</td>'+tempRow.map(function(v){return '<td '+cell+'>'+esc(v)+'</td>';}).join('')+'<td '+cell+'>'+esc(tAvg)+'</td></tr>'+
        '<tr><td '+cellL+'>Availability %</td>'+availRow.map(function(){return '<td '+cell+'>'+esc(avail)+'</td>';}).join('')+'<td '+cell+'>'+esc(avail)+'</td></tr>'+
        '<tr><td '+cellL+'>Expected Production, MW</td>'+prodRow.map(function(v){return '<td '+cell+'>'+esc(v)+'</td>';}).join('')+'<td '+cell+'>'+esc(pTot)+'</td></tr>'
      );
    }

    return ''+
      '<div style="font:13px Arial,Helvetica,sans-serif;color:#000"><p style="margin:0 0 12px 0; white-space:pre-line">Dear all,\n\nAttached below is the RGWE forecasted output of the facility for your appreciated interest.</p>'+
      '<div '+title+'>Forecasted Output Of The Facility, RGWE 2025</div>'+
      '<table '+wrap+'>'+
      blocks.join('')+
      '</table>'+
      '</div>';
  }

  function computeIndices(data){
    try{
      if (typeof window.getNextWeekDates==='function' && typeof window.indicesForDates==='function'){
        var weekDates = window.getNextWeekDates();
        var idx = window.indicesForDates(weekDates, data.daily.time);
        if (Array.isArray(idx) && idx.length===7 && idx.every(function(z){return z>=0;})) return idx;
      }
    }catch(e){}
    var dailyDates = data.daily.time || [];
    var pad = function(n){ return String(n).padStart(2,'0'); };
    var t = new Date();
    var todayISO = [t.getFullYear(), pad(t.getMonth()+1), pad(t.getDate())].join('-');
    var startIdx = dailyDates.findIndex(function(s){ return s >= todayISO; });
    if (startIdx < 0) startIdx = 0;
    var out = [];
    for (var k= startIdx; k<dailyDates.length && out.length<7; k++) out.push(k);
    return out;
  }

  window.exportWeeklyEmailEML = function(indices, data, windUnitUI){
    try{
      var lf = window.__lastForecast;
      if (!lf || !lf.data || !lf.data.daily || !lf.data.hourly){ alert('ÿ±ÿ¨ÿßÿ°Ÿã ÿ≠ÿØŸëŸêÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§ ÿ£ŸàŸÑŸãÿß.'); return; }
      var dataObj = data || lf.data;
      var idxList = (Array.isArray(indices) && indices.length===7) ? indices : computeIndices(dataObj);
      if (!Array.isArray(idxList) || idxList.length !== 7 || idxList.some(function(i){return i<0;})){
        alert('ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸÖŸÑÿ©.'); return;
      }
      var langEN = document.documentElement.lang === 'en';
      var loc    = langEN ? 'en-GB' : 'ar-EG';
      var startISO = dataObj.daily.time[idxList[0]];
      var endISO   = dataObj.daily.time[idxList[6]];
      var startD   = new Date(startISO + 'T00:00:00');
      var endD     = new Date(endISO   + 'T00:00:00');
      var niceRange = startD.toLocaleDateString(loc,{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}) +
                      ' ‚Üí ' +
                      endD.toLocaleDateString(loc,{weekday:'long', day:'numeric', month:'numeric', year:'numeric'});
      niceRange = niceRange.split('/').join('-');

      var subject = langEN ? ('RGWE Weekly Forecast ‚Äì ' + niceRange) : ('ÿ™ŸÜÿ®ÿ§ RGWE ‚Äì ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ' + niceRange);

      var inpTo  = document.getElementById('emailTo');
      var toList = (inpTo && inpTo.value) ? inpTo.value.split(/[;,]/).map(function(s){return s.trim();}).filter(Boolean)
                    : (typeof window.__rgwe_getToList==='function' ? window.__rgwe_getToList() : []);
      var toHeader = (toList && toList.length) ? toList.join(', ') : '';
      var ccList   = (typeof window.__rgwe_getCcList==='function') ? window.__rgwe_getCcList()
                      : ((document.getElementById('emailCc') && document.getElementById('emailCc').value || '').split(/[;,]/).map(function(s){return s.trim();}).filter(Boolean));
      var ccHeader = (ccList && ccList.length) ? ccList.join(', ') : '';

      var html = buildWeekly(idxList, dataObj, lf.windUnit);
      if (typeof window.saveAsEml === 'function'){
        window.saveAsEml({ subject: 'Forecasted Output Of The Facility - RGWE', html:html, to:toHeader, cc:ccHeader});
      } else {
        saveAsEmlWeekly({subject: 'Forecasted Output Of The Facility - RGWE', html:html, to:toHeader, cc:ccHeader});
      }
    }catch(e){
      alert('ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿ•ŸäŸÖŸäŸÑ (weekly v6): ' + e.message);
    }
  };

  function wireWeeklyButton(){
    var btn = document.getElementById('weeklyEmailBtn');
    if (btn){
      btn.type = 'button';
      btn.textContent = (document.documentElement.lang === 'en') ? 'Export as Email (Week)' : 'ÿ™ÿµÿØŸäÿ± ŸÉÿ•ŸäŸÖŸäŸÑ ŸÑŸÑÿ£ÿ≥ÿ®Ÿàÿπ';
      btn.addEventListener('click', function(){
        var lf = window.__lastForecast;
        if (!lf || !lf.data || !lf.data.daily || !lf.data.hourly){
          alert('ÿ±ÿ¨ÿßÿ°Ÿã ÿ≠ÿØŸëŸêÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§ ÿ£ŸàŸÑŸãÿß.');
          return;
        }
        window.exportWeeklyEmailEML([], lf.data, lf.windUnit);
      });
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wireWeeklyButton);
  } else {
    wireWeeklyButton();
  }
})();
// === End Weekly Email Exporter ===
</script>
<script>
// === Wind height selector helpers ===
(function(){
  window.__windHeight = parseInt(localStorage.getItem('windHeight')||'80',10);
  function currentWindHeight(){ return (window.__windHeight||80); }
  window.getWindArray = function(data){
    var h = currentWindHeight();
    var key = 'wind_speed_' + h + 'm';
    return (data && data.hourly && data.hourly[key]) ? data.hourly[key] : [];
  };
  function refreshAll(){
    try{
      var lf = window.__lastForecast;
      if (!lf || !lf.data) return;
      // re-render cards in current language
      if (document.documentElement.lang === 'en'){
        if (typeof renderCardsEN==='function') renderCardsEN(lf.data, lf.windUnit);
      } else {
        if (typeof renderCardsAR==='function') renderCardsAR(lf.data, lf.windUnit);
      }
    }catch(e){ console.warn('refreshAll err', e); }
  }
  document.addEventListener('DOMContentLoaded', function(){
    var sel = document.getElementById('windHeightSel');
    if (sel){
      // init value from storage
      sel.value = String(currentWindHeight());
      sel.addEventListener('change', function(e){
        var v = parseInt(e.target.value,10);
        if (!isFinite(v)) return;
        window.__windHeight = v;
        localStorage.setItem('windHeight', String(v));
        refreshAll();
      });
    }
  });
})();
// === End wind height selector helpers ===
</script>
<script>
// === Weekly Email: start from NEXT SUNDAY (Sun->Sat) & match Excel indices ===
(function(){
  // 0) Capture indices used by the app's Excel exporter (if any) to ensure perfect match
  try{
    if (typeof window.exportWeeklyExcel === 'function' && !window.__weeklyExcelPatched){
      const __orig = window.exportWeeklyExcel;
      window.exportWeeklyExcel = function(data, idxList, windUnit){
        try{ window.__weeklyLastIndices = Array.isArray(idxList) ? idxList.slice() : undefined; }catch(e){}
        return __orig.apply(this, arguments);
      };
      window.__weeklyExcelPatched = true;
    }
  }catch(e){}

  // 1) Compute next WEEK indices starting upcoming Sunday (if today is Sunday -> next week)
  function computeNextWeekSundayIndices(dailyDatesISO){
    if (!Array.isArray(dailyDatesISO) || !dailyDatesISO.length) return [];
    const today = new Date();
    const dow = today.getDay(); // 0=Sun ... 6=Sat
    let daysUntilNextSunday = (7 - dow) % 7;
    if (daysUntilNextSunday === 0) daysUntilNextSunday = 7; // push to next week if today is Sunday
    const start = new Date(today.getFullYear(), today.getMonth(), today.getDate() + daysUntilNextSunday);
    const pad = n => String(n).padStart(2,'0');
    const target = [];
    for (let i=0;i<7;i++){
      const d = new Date(start.getFullYear(), start.getMonth(), start.getDate()+i);
      target.push(`${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`);
    }
    // map to indices if all present
    const idx = target.map(t => dailyDatesISO.indexOf(t));
    if (idx.every(i => i>=0)) return idx;
    // fallback: first 7 dates >= start
    const startISO = `${start.getFullYear()}-${pad(start.getMonth()+1)}-${pad(start.getDate())}`;
    let startIdx = dailyDatesISO.findIndex(s => s >= startISO);
    if (startIdx < 0) startIdx = 0;
    const out = [];
    for (let k=startIdx; k<dailyDatesISO.length && out.length<7; k++) out.push(k);
    return out.length===7 ? out : [];
  }

  // 2) Override/augment existing weekly email export wiring to use our indices
  function wireWeeklyEmailFix(){
    const btn = document.getElementById('weeklyEmailBtn');
    if (!btn) return;
    // Avoid double-binding
    if (btn.__weeklyFixed) return;
    btn.__weeklyFixed = true;

    btn.addEventListener('click', function(ev){
      try{
        const lf = window.__lastForecast;
        if (!lf || !lf.data || !lf.data.daily || !lf.data.hourly){
          alert('ÿ±ÿ¨ÿßÿ°Ÿã ÿ≠ÿØŸëŸêÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§ ÿ£ŸàŸÑŸãÿß.');
          return;
        }
        // Prefer indices captured from Excel (perfect match)
        let idxList = Array.isArray(window.__weeklyLastIndices) ? window.__weeklyLastIndices.slice() : [];
        if (!idxList || idxList.length !== 7 || idxList.some(i=>i<0)){
          // Compute from NEXT SUNDAY ‚Üí SATURDAY
          idxList = computeNextWeekSundayIndices(lf.data.daily.time);
        }
        if (!idxList || idxList.length !== 7 || idxList.some(i=>i<0)){
          alert('ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸÖŸÑÿ©.');
          return;
        }
        // Call existing exporter with our indices
        if (typeof window.exportWeeklyEmailEML === 'function'){
          window.exportWeeklyEmailEML(idxList, lf.data, lf.windUnit);
        } else {
          alert('Ÿàÿ∏ŸäŸÅÿ© ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ•ŸäŸÖŸäŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©.');
        }
      }catch(e){
        alert('ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿ•ŸäŸÖŸäŸÑ ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä: ' + e.message);
      }
    }, { once: false });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wireWeeklyEmailFix);
  } else {
    wireWeeklyEmailFix();
  }
})();
// === End Weekly Email Week Fix ===
</script>
<script>
// === Weekly Email: enforce single handler & NEXT SUNDAY (no duplicates) ===
(function(){
  function computeNextWeekSundayIndices(dailyDatesISO){
    if (!Array.isArray(dailyDatesISO) || !dailyDatesISO.length) return [];
    const today = new Date();
    const dow = today.getDay(); // 0=Sun ... 6=Sat
    let daysUntilNextSunday = (7 - dow) % 7;
    if (daysUntilNextSunday === 0) daysUntilNextSunday = 7; // if today is Sunday -> next week
    const start = new Date(today.getFullYear(), today.getMonth(), today.getDate() + daysUntilNextSunday);
    const pad = n => String(n).padStart(2,'0');
    const target = [];
    for (let i=0;i<7;i++){
      const d = new Date(start.getFullYear(), start.getMonth(), start.getDate()+i);
      target.push(`${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`);
    }
    const idx = target.map(t => dailyDatesISO.indexOf(t));
    if (idx.every(i => i>=0)) return idx;
    const startISO = `${start.getFullYear()}-${pad(start.getMonth()+1)}-${pad(start.getDate())}`;
    let startIdx = dailyDatesISO.findIndex(s => s >= startISO);
    if (startIdx < 0) startIdx = 0;
    const out = [];
    for (let k=startIdx; k<dailyDatesISO.length && out.length<7; k++) out.push(k);
    return out.length===7 ? out : [];
  }

  function setupWeeklyEmailNoDup(){
    const oldBtn = document.getElementById('weeklyEmailBtn');
    if (!oldBtn) return;

    // Replace the node to strip ALL previous listeners
    const btn = oldBtn.cloneNode(true);
    oldBtn.parentNode.replaceChild(btn, oldBtn);

    // Single capturing handler to stop others
    btn.addEventListener('click', function(ev){
      try{
        ev.preventDefault();
        ev.stopImmediatePropagation();
        ev.stopPropagation();

        const lf = window.__lastForecast;
        if (!lf || !lf.data || !lf.data.daily || !lf.data.hourly){
          alert('ÿ±ÿ¨ÿßÿ°Ÿã ÿ≠ÿØŸëŸêÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§ ÿ£ŸàŸÑŸãÿß.');
          return;
        }
        // Prefer Excel-captured indices if present (should already be Sun->Sat)
        let idxList = Array.isArray(window.__weeklyLastIndices) ? window.__weeklyLastIndices.slice() : [];
        if (!idxList || idxList.length !== 7 || idxList.some(i=>i<0)){
          idxList = computeNextWeekSundayIndices(lf.data.daily.time);
        }
        if (!idxList || idxList.length !== 7 || idxList.some(i=>i<0)){
          alert('ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸÖŸÑÿ©.');
          return;
        }
        if (typeof window.exportWeeklyEmailEML === 'function'){
          window.exportWeeklyEmailEML(idxList, lf.data, lf.windUnit);
        } else {
          alert('Ÿàÿ∏ŸäŸÅÿ© ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ•ŸäŸÖŸäŸÑ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©.');
        }
      }catch(e){
        alert('ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑÿ•ŸäŸÖŸäŸÑ ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä: ' + e.message);
      }
    }, true); // capture=true to ensure we run before any bubbling handlers
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', setupWeeklyEmailNoDup);
  } else {
    setupWeeklyEmailNoDup();
  }
})();
// === End Weekly Email no-duplicate fix ===
</script>
<script id="rgwe-model-switch">
(function(){
  const H_SEL_ID = 'windHeightSel';
  function getSel(){ return document.getElementById('modelSelect'); }
  function setHeights(list, defVal){
    const sel = document.getElementById(H_SEL_ID);
    if(!sel) return;
    const cur = Number(sel.value||defVal);
    sel.innerHTML = '';
    list.forEach(h=>{
      const o = document.createElement('option');
      o.value = String(h); o.textContent = h+' m';
      sel.appendChild(o);
    });
    sel.value = String(list.includes(cur)? cur : defVal);
    window.__windHeight = Number(sel.value);
  }
  function bindHeightChange(){
    const sel = document.getElementById(H_SEL_ID);
    if(!sel || sel.__rgweBound) return;
    sel.__rgweBound = true;
    sel.addEventListener('change', ()=>{ window.__windHeight = Number(sel.value||80); });
  }
  if(!window.__origGetForecast){ window.__origGetForecast = window.getForecast; }
  async function ecmwfForecast(lat, lon, windUnit){
    const url = new URL('https://api.open-meteo.com/v1/ecmwf');
    url.searchParams.set('latitude', lat);
    url.searchParams.set('longitude', lon);
    url.searchParams.set('timezone', 'auto');
    url.searchParams.set('daily','temperature_2m_max,temperature_2m_min');
    url.searchParams.set('hourly','temperature_2m,wind_speed_10m,wind_speed_100m,wind_gusts_10m');
    url.searchParams.set('windspeed_unit', windUnit);
    const pad=n=>String(n).padStart(2,'0');
    const now = new Date();
    const startISO = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}`;
    const endDate  = new Date(now.getFullYear(), now.getMonth(), now.getDate()+13);
    const endISO   = `${endDate.getFullYear()}-${pad(endDate.getMonth()+1)}-${pad(endDate.getDate())}`;
    url.searchParams.set('start_date', startISO);
    url.searchParams.set('end_date',   endISO);
    url.searchParams.set('_', Date.now());
    const res = await fetch(url.toString(), { cache: 'no-store' });
    if(!res.ok){ let txt=''; try{ txt = await res.text(); }catch(e){}; throw new Error('Fetch failed '+res.status+' '+res.statusText+' ‚Äî '+txt.slice(0,140)); }
    return res.json();
  })();
</script>

<script>
(function(){
  const KEY = 'rgwe_theme';

  function setTheme(t){
    document.documentElement.classList.toggle('dark', t === 'dark');
    try{ localStorage.setItem(KEY, t); }catch(_){}
    updateLabel();
  }

  function currentLang(){
    try{
      const s = document.getElementById('langSelect');
      if(s && s.value) return s.value;
    }catch(_){}
    return (document.documentElement.lang === 'en') ? 'en' : 'ar';
  }

  // ÿ•ŸÜÿ¥ÿßÿ° ÿ≤ÿ± ÿßŸÑÿ™ÿ®ÿØŸäŸÑ Ÿàÿ≠ŸÇŸÜŸá
  const btn = document.createElement('button');
  btn.id = 'themeToggle';
  btn.type = 'button';
  btn.className = 'lang-select';
  btn.style.minWidth = '120px';

  function updateLabel(){
    const isDark = document.documentElement.classList.contains('dark');
    const isAR = currentLang() !== 'en';
    btn.textContent = isDark ? (isAR ? '‚òÄÔ∏è ŸÜŸáÿßÿ±Ÿä' : '‚òÄÔ∏è Light') : (isAR ? 'üåô ŸÑŸäŸÑŸä' : 'üåô Dark');
    btn.title = isAR ? 'ÿ™ÿ®ÿØŸäŸÑ ÿßŸÑŸàÿ∂ÿπ' : 'Toggle theme';
    btn.setAttribute('aria-pressed', isDark ? 'true' : 'false');
  }

  btn.addEventListener('click', function(){
    const isDark = document.documentElement.classList.contains('dark');
    setTheme(isDark ? 'light' : 'dark');
  });

  // ÿ∂ŸéŸÖŸë ÿßŸÑÿ≤ÿ± ÿ®ÿ¨Ÿàÿßÿ± ŸÖŸèÿ≠ÿØŸëŸêÿØ ÿßŸÑŸÑÿ∫ÿ© ŸÅŸä ÿßŸÑÿ™ÿ±ŸàŸäÿ≥ÿ©
  const langSel = document.getElementById('langSelect');
  const holder  = (langSel && langSel.parentElement) || document.querySelector('header .flex.items-center');
  if(holder){ holder.appendChild(btn); }

  // ŸÑŸà ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ∫ŸäŸëÿ± ÿßŸÑŸÑÿ∫ÿ©‚Ä¶ ÿ≠ÿØŸëÿ´ ŸÜÿµ ÿßŸÑÿ≤ÿ±
  if(langSel){ langSel.addEventListener('change', updateLabel); }

  // ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
  try{
    const saved = localStorage.getItem(KEY);
    if(saved === 'dark' || saved === 'light'){ setTheme(saved); }
    else{
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      setTheme(prefersDark ? 'dark' : 'light');
    }
  }catch(_){
    setTheme('light');
  }
})();
</script>

<script id="rgwe-i18n-patch">
(function(){
  function patchI18nExtras(locale){
    var toLbl = document.querySelector('label[for="emailTo"]');
    var ccLbl = document.querySelector('label[for="emailCc"]');
    var helpParas = document.querySelectorAll('label[for="emailTo"] ~ p.text-xs, label[for="emailCc"] ~ p.text-xs');
    var modelSel = document.getElementById('modelSelect');
    var heightLbl = (function(){ var sel=document.getElementById('windHeightSel'); return sel && sel.previousElementSibling && sel.previousElementSibling.tagName==='LABEL' ? sel.previousElementSibling : null; })();

    if(locale === 'en'){
      if(toLbl) toLbl.textContent = 'Send to (To)';
      if(ccLbl) ccLbl.textContent = 'CC';
      helpParas.forEach(function(p){ p.textContent = 'You can enter multiple emails separated by ; or , and it will be saved automatically.'; });
      if(modelSel){
        var opt = function(v,t){ var o = modelSel.querySelector('option[value="'+v+'"]').textContent = t; };
        opt('default','Forecast (multi-model)');
        opt('ecmwf','ECMWF (10m/100m)');
      }
      if(heightLbl) heightLbl.textContent = 'Wind height';
    } else {
      if(toLbl) toLbl.textContent = 'ÿ•ÿ±ÿ≥ÿßŸÑ ÿ•ŸÑŸâ (To)';
      if(ccLbl) ccLbl.textContent = 'ŸÜÿ≥ÿÆÿ© ÿ•ŸÑŸâ (CC)';
      helpParas.forEach(function(p){ p.textContent = 'ŸäŸÖŸÉŸÜ ŸÉÿ™ÿßÿ®ÿ© ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ®ÿ±ŸäÿØ ŸÖŸÅÿµŸàŸÑ ÿ®ŸÄ ; ÿ£Ÿà , Ÿàÿ≥Ÿäÿ™ŸÖ ÿ≠ŸÅÿ∏Ÿá ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß.'; });
      if(modelSel){
        var opt = function(v,t){ var o = modelSel.querySelector('option[value="'+v+'"]').textContent = t; };
        opt('default','Forecast (ŸÖÿ™ÿπÿØÿØ ÿßŸÑŸÜŸÖÿßÿ∞ÿ¨)');
        opt('ecmwf','ECMWF (10m/100m)');
      }
      if(heightLbl) heightLbl.textContent = 'ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿ±Ÿäÿßÿ≠';
    }
  }

  // Apply on load based on saved locale
  document.addEventListener('DOMContentLoaded', function(){
    try{
      var saved = localStorage.getItem('locale') || 'ar';
      patchI18nExtras(saved);
      try{var sig=document.querySelector('#rgweSignature .label'); if(sig){ sig.textContent = 'Designed by'; }}catch(_){}
      var sel = document.getElementById('langSelect');
      if(sel){
        sel.addEventListener('change', function(e){ patchI18nExtras(e.target.value); try{var sig=document.querySelector('#rgweSignature .label'); if(sig){ sig.textContent = 'Designed by'; }}catch(_){} });
      }
    }catch(e){ console.error(e); }
  });
})();
</script>

<script id="rgwe-signature-enforce">
document.addEventListener('DOMContentLoaded', function(){
  var sig = document.querySelector('#rgweSignature .label');
  if(sig) sig.textContent = 'Designed by';
});
</script>


<script id="rgwe-signature-ua">
document.addEventListener('DOMContentLoaded', function(){
  var sig = document.querySelector('#rgweSignature .label');
  if(sig) sig.textContent = 'DESIGNED BY';
});
</script>




<script id="rgwe-lock-to-cc-script">
(function(){
  const HASH_HEX = "218a31278877e01cf68fb546ef97cc016d40a8ce8cb842a0171050e0e6e186b3";
  const KEY = "rgwe_to_cc_unlocked";

  function isArabicNow(){
    const html = document.documentElement;
    const body = document.body || {};
    const lang = (html.lang || body.lang || "").toLowerCase();
    const dir  = (html.dir || body.dir || "").toLowerCase();
    if (lang.startsWith("ar")) return true;
    if (dir === "rtl") return true;
    const bodyLangAttr = (body.getAttribute ? (body.getAttribute("data-lang")||"") : "").toLowerCase();
    if (bodyLangAttr.startsWith("ar")) return true;
    const lab = document.querySelector('label[for="emailTo"]');
    if (lab && /[\u0600-\u06FF]/.test(lab.textContent)) return true;
    return false;
  }

  function dict(){
    const ar = {
      open: "üîí ŸÅÿ™ÿ≠ ÿßŸÑÿ™ÿ≠ÿ±Ÿäÿ±",
      close: "üîì ŸÇŸÅŸÑ ÿßŸÑÿ™ÿ≠ÿ±Ÿäÿ±",
      title: "ÿ≠ŸÖÿßŸäÿ© ÿ≠ŸÇŸàŸÑ ÿßŸÑÿ®ÿ±ŸäÿØ",
      prompt: "ÿ£ÿØÿÆŸÑ ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ŸÑŸÅÿ™ÿ≠ ÿßŸÑÿ™ÿ≠ÿ±Ÿäÿ±.",
      cancel: "ÿ•ŸÑÿ∫ÿßÿ°",
      ok: "ŸÅÿ™ÿ≠",
      wrong: "ŸÉŸÑŸÖÿ© ÿßŸÑŸÖÿ±Ÿàÿ± ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©",
      unexpected: "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ"
    };
    const en = {
      open: "üîí Unlock editing",
      close: "üîì Lock editing",
      title: "Protect email fields",
      prompt: "Enter password to unlock editing.",
      cancel: "Cancel",
      ok: "Unlock",
      wrong: "Incorrect password",
      unexpected: "Unexpected error"
    };
    return isArabicNow() ? ar : en;
  }

  function qs(id){ return document.getElementById(id); }
  function addLockBtn(input) {
    if (!input) return;
    input.classList.add("rgwe-locked-field");
    input.readOnly = true;
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "rgwe-lock-btn";
    btn.textContent = dict().open;
    btn.addEventListener("click", openOverlay);
    input.insertAdjacentElement("afterend", btn);
  }

  async function sha256Hex(s){
    const enc = new TextEncoder();
    const buf = await crypto.subtle.digest("SHA-256", enc.encode(s));
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  function setUnlocked(unlocked){
    const to = document.getElementById("emailTo");
    const cc = document.getElementById("emailCc");
    const btns = document.querySelectorAll(".rgwe-lock-btn");
    [to, cc].forEach(el => { if(!el) return; el.readOnly = !unlocked; });
    const L = dict();
    btns.forEach(btn => { btn.textContent = (unlocked ? L.close : L.open); });
    try { sessionStorage.setItem(KEY, unlocked ? "1" : "0"); } catch(_){}
  }

  function buildOverlayHtml(){
    const L = dict();
    const dir = isArabicNow() ? "rtl" : "ltr";
    return `
<div id="rgwe-unlock-overlay" role="dialog" aria-modal="true" style="position:fixed;inset:0;z-index:99999;display:none;place-items:center;backdrop-filter:blur(6px);background:rgba(0,0,0,.35)">
  <div id="rgwe-unlock-card" style="background:var(--rgwe-card-bg,#fff);border-radius:16px;padding:20px;width:min(92%,380px);box-shadow:0 10px 25px rgba(0,0,0,.25);direction:${dir};font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Helvetica Neue,Arial">
    <h3 style="margin:0 0 8px;font-size:1.05rem">${L.title}</h3>
    <p style="margin:0 0 8px;color:#6b7280">${L.prompt}</p>
    <form id="rgwe-unlock-form">
      <input id="rgwe-unlock-input" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="current-password" style="width:100%;padding:10px 12px;border-radius:12px;border:1px solid #e5e7eb;margin:6px 0 10px" />
      <div class="row" style="display:flex;gap:8px">
        <button type="button" id="rgwe-unlock-cancel" style="flex:1;padding:10px 12px;border-radius:12px;border:none;background:#e5e7eb">${L.cancel}</button>
        <button type="submit" id="rgwe-unlock-ok" style="flex:1;padding:10px 12px;border-radius:12px;border:none;background:#059669;color:#fff;font-weight:600">${L.ok}</button>
      </div>
      <div id="rgwe-unlock-err" aria-live="polite" style="color:#b91c1c;font-size:.85rem;min-height:1.2em;margin-top:6px"></div>
    </form>
  </div>
</div>`;
  }

  function ensureOverlay(){
    let ov = qs("rgwe-unlock-overlay");
    if (!ov) {
      document.body.insertAdjacentHTML("beforeend", buildOverlayHtml());
      ov = qs("rgwe-unlock-overlay");
      const cancel = qs("rgwe-unlock-cancel");
      if (cancel) cancel.addEventListener("click", closeOverlay);
      const form = qs("rgwe-unlock-form");
      const inp = qs("rgwe-unlock-input");
      const err = qs("rgwe-unlock-err");
      if (form) form.addEventListener("submit", async function(e){
        e.preventDefault();
        err.textContent = "";
        try {
          const got = await sha256Hex((inp.value||"").trim());
          if (got === HASH_HEX) {
            setUnlocked(true);
            closeOverlay();
          } else {
            err.textContent = dict().wrong;
          }
        } catch(ex) {
          console.error(ex); err.textContent = dict().unexpected;
        }
      }, {passive:false});
    }
    return ov;
  }

  function openOverlay(){
    const ov = ensureOverlay();
    if (!ov) return;
    ov.style.display = "grid";
    const inp = qs("rgwe-unlock-input"); if (inp) { inp.value=""; setTimeout(()=>inp.focus(),0); }
  }

  function closeOverlay(){
    const ov = qs("rgwe-unlock-overlay"); if (ov) ov.style.display = "none";
  }

  function refreshTexts(){
    const L = dict();
    document.querySelectorAll(".rgwe-lock-btn").forEach(btn => {
      const unlocked = (qs("emailTo") && !qs("emailTo").readOnly) || (qs("emailCc") && !qs("emailCc").readOnly);
      btn.textContent = unlocked ? L.close : L.open;
    });
    const card = qs("rgwe-unlock-card");
    if (card){
      const dir = isArabicNow() ? "rtl" : "ltr";
      card.style.direction = dir;
      const h3 = card.querySelector("h3");
      const p = card.querySelector("p");
      const ok = qs("rgwe-unlock-ok");
      const cancel = qs("rgwe-unlock-cancel");
      if (h3) h3.textContent = L.title;
      if (p)  p.textContent  = L.prompt;
      if (ok) ok.textContent = L.ok;
      if (cancel) cancel.textContent = L.cancel;
    }
  }

  function observeLang(){
    const target = document.documentElement;
    const obs = new MutationObserver(() => refreshTexts());
    obs.observe(target, { attributes: true, attributeFilter: ["lang","dir"] });
    if (document.body){
      obs.observe(document.body, { attributes: true, attributeFilter: ["lang","dir","data-lang"] });
    }
    document.addEventListener("change", () => setTimeout(refreshTexts, 0), true);
    document.addEventListener("click",  () => setTimeout(refreshTexts, 0), true);
  }

  document.addEventListener("DOMContentLoaded", function(){
    const to = document.getElementById("emailTo");
    const cc = document.getElementById("emailCc");
    addLockBtn(to);
    addLockBtn(cc);
    const unlocked = (function(){ try{return sessionStorage.getItem(KEY)==="1"}catch(_){return false;}})();
    setUnlocked(unlocked);
    observeLang();
    refreshTexts();
  });
})();
</script>



<script id="rgwe-i18n-weekly-script">
(function(){
  function isArabicNow(){
    const html = document.documentElement;
    const body = document.body || {};
    const lang = (html.lang || body.lang || "").toLowerCase();
    const dir  = (html.dir || body.dir || "").toLowerCase();
    if (lang.startsWith("ar")) return true;
    if (dir === "rtl") return true;
    const bodyLangAttr = (body.getAttribute ? (body.getAttribute("data-lang")||"") : "").toLowerCase();
    if (bodyLangAttr.startsWith("ar")) return true;
    return false;
  }

  function refreshWeeklyTexts(){
    const ar = {
      weeklyEmail: "ÿ™ÿµÿØŸäÿ± ŸÉÿ•ŸäŸÖŸäŸÑ ŸÑŸÑÿ£ÿ≥ÿ®Ÿàÿπ",
      genPdf: "ÿ™ŸàŸÑŸäÿØ PDF ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä",
      dlXls: "ÿ™ÿ≠ŸÖŸäŸÑ ŸÖŸÑŸÅ ÿ•ŸÉÿ≥ŸÑ ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä (ÿµŸÅÿ≠ÿ© Ÿàÿßÿ≠ÿØÿ©)",
      note: "PDF: ÿµŸÅÿ≠ÿ© ŸÑŸÉŸÑ ŸäŸàŸÖ. ÿ•ŸÉÿ≥ŸÑ: ŸÉŸÑ ÿßŸÑÿ£ŸäÿßŸÖ ŸÅŸä ÿµŸÅÿ≠ÿ© Ÿàÿßÿ≠ÿØÿ©."
    };
    const en = {
      weeklyEmail: "Email weekly export",
      genPdf: "Generate weekly PDF",
      dlXls: "Download weekly Excel (one sheet)",
      note: "PDF: one page per day. Excel: all days in a single sheet."
    };
    const L = isArabicNow() ? ar : en;

    // Weekly email button (known id in earlier versions)
    const weeklyBtn = document.getElementById("weeklyEmailBtn");
    if (weeklyBtn) weeklyBtn.textContent = L.weeklyEmail;

    // If your weekly PDF/Excel buttons have these exact English labels already,
    // this will only affect Arabic pages; otherwise we set them explicitly:
    const pdfBtn = document.querySelector('[data-weekly="pdf"]') || null;
    const xlsBtn = document.querySelector('[data-weekly="excel"]') || null;
    if (pdfBtn) pdfBtn.textContent = L.genPdf;
    if (xlsBtn) xlsBtn.textContent = L.dlXls;

    // Optional note element under the buttons
    const noteEl = document.querySelector('[data-weekly="note"]');
    if (noteEl) noteEl.textContent = L.note;
  }

  function observeLang(){
    const target = document.documentElement;
    const obs = new MutationObserver(() => refreshWeeklyTexts());
    obs.observe(target, { attributes: true, attributeFilter: ["lang","dir"] });
    if (document.body){
      obs.observe(document.body, { attributes: true, attributeFilter: ["lang","dir","data-lang"] });
    }
    document.addEventListener("change", () => setTimeout(refreshWeeklyTexts, 0), true);
    document.addEventListener("click",  () => setTimeout(refreshWeeklyTexts, 0), true);
  }

  document.addEventListener("DOMContentLoaded", function(){
    refreshWeeklyTexts();
    observeLang();
  });
})();
</script>

<script id="rgwe-default-windheight-10m">
document.addEventListener('DOMContentLoaded', function(){
  try{
    var tried = 0;
    function setTo10(sel){
      if (!sel) return false;
      // Only change if it looks like the wind-height select
      var label = null;
      // Try previous label in same container
      var p = sel.previousElementSibling;
      if (p && p.tagName && p.tagName.toLowerCase() === 'label') label = p;
      if (!label){
        // Try to find a label by 'for' attribute
        var id = sel.id;
        if (id) label = document.querySelector('label[for="'+id+'"]');
      }
      var txt = (label && label.textContent || '').toLowerCase();
      var isWindHeight = txt.includes('wind height') || /ÿßÿ±ÿ™ŸÅÿßÿπ/.test(txt);
      if (!isWindHeight && !(sel.id||'').toLowerCase().includes('windheight') && !(sel.name||'').toLowerCase().includes('windheight')){
        return false;
      }
      // If app hasn't already set a different value, set to 10
      if (!sel.value || sel.value === '80' || sel.value === '100' || sel.value === '90'){
        sel.value = '10';
        // Also reflect selected attribute for 10 if present
        var opt10 = sel.querySelector('option[value="10"], option[value=10]');
        if (opt10){ 
          sel.querySelectorAll('option').forEach(function(o){ o.removeAttribute('selected'); });
          opt10.setAttribute('selected', 'selected');
        }
      }
      return true;
    }
    var sel = document.getElementById('windHeightSel') 
           || document.querySelector('select[name="windHeight"]') 
           || null;
    var done = setTo10(sel);
    if (!done){
      document.querySelectorAll('select').forEach(function(s){ if (!done) done = setTo10(s); });
    }
  }catch(e){/* no-op */}
});
</script>

</body>
</html>
<script>
/* === Excel Export Override v6 ===
   - Fixes download issues by generating a Blob and clicking a hidden <a>
   - Ensures XLSX library is loaded dynamically if missing
   - Keeps: single title row, single time header row, one continuous table, thin borders, bold first column labels
*/
(function(){
  function ensureXLSX(cb){
    if (window.XLSX && XLSX.utils && XLSX.write) return cb();
    var s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
    s.onload = function(){ cb(); };
    s.onerror = function(){ alert('ÿ™ÿπÿ∞ÿ± ÿ™ÿ≠ŸÖŸäŸÑ ŸÖŸÉÿ™ÿ®ÿ© Excel ŸÖŸÜ CDN'); };
    document.head.appendChild(s);
  }

  function ymdLocal(d){ const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; }
  function nextSunday(from = new Date()){ const day=from.getDay(); const delta=((7-day)%7)||7; const d=new Date(from); d.setHours(0,0,0,0); d.setDate(d.getDate()+delta); return d; }
  function getNextWeekDates(){ const start=nextSunday(new Date()); const days=[]; for(let i=0;i<7;i++){ const di=new Date(start); di.setDate(start.getDate()+i); days.push(ymdLocal(di)); } return days; }
  function indicesForDates(dates, dailyTimes){ return dates.map(d => dailyTimes.indexOf(d)); }

  function toMs(v,u){
    try{ if(window.convertToMs) return window.convertToMs(v,u); }catch(e){}
    if (!Number.isFinite(v)) return NaN;
    return u==='kn' || u==='knots' ? v*0.514444 : (u==='kmh' ? v/3.6 : (u==='mph' ? v*0.44704 : v));
  }
  function expectedProd(w_ms){
    try{ if(window.expectedProductionMWFromSheet) return window.expectedProductionMWFromSheet(w_ms); }catch(e){}
    const cut=3,rated=12,cap=100; if(!Number.isFinite(w_ms)||w_ms<=cut) return 0; if(w_ms>=rated) return cap; const n=(w_ms-cut)/(rated-cut); return Math.pow(n,3)*cap;
  }
  function hoursForDay(dayIdx, hourlyTimes){
    try{ if(window.hoursForDay) return window.hoursForDay(dayIdx, hourlyTimes).slice(0,24); }catch(e){}
    const dateISO = window.__lastForecast?.data?.daily?.time?.[dayIdx];
    const idxs = [];
    for (let k=0; k<hourlyTimes.length; k++){
      if (hourlyTimes[k].startsWith(dateISO)){ idxs.push(k); if (idxs.length===24) break; }
    }
    return idxs;
  }

  function buildWeeklyWorkbook(data, indices, windUnitUI){
    const wb = XLSX.utils.book_new();
    const allRows = [];
    const merges = [];

    // Global title once
    const yearAny = new Date((data.daily.time[indices[0]]||'') + 'T00:00:00').getFullYear();
    const titleRow = new Array(26).fill('');
    titleRow[0] = `Forecasted Output Of The Facility, RGWE ${yearAny}`;
    allRows.push(titleRow);
    merges.push({ s: { r: 0, c: 0 }, e: { r: 0, c: 25 } });

    // Single time header row
    const headerRow = new Array(26).fill('');
    headerRow[0] = 'Date / Metric';
    for (let h=0; h<24; h++){ headerRow[1+h] = `${String(h).padStart(2,'0')}:00`; }
    headerRow[25] = 'Avg / Total';
    allRows.push(headerRow);

    // Append per-day blocks: 4 rows (wind, temp, avail, production) ‚Äî NO blank rows
    indices.forEach((dayIdx) => {
      const idxs = hoursForDay(dayIdx, data.hourly.time);
      const dayISO   = data.daily.time[dayIdx];
      const dateObj  = new Date(dayISO + 'T00:00:00');
      const niceDate = dateObj.toLocaleDateString('en-GB',{weekday:'long', day:'numeric', month:'numeric', year:'numeric'}).replace(/\//g,'-');

      // Wind
      const windRow = new Array(26).fill(''); windRow[0] = `${niceDate} ‚Äì Expected Wind Speed, m/s`;
      let windSum=0, windCount=0;
      idxs.forEach((k,i)=>{ const wMs = toMs(getWindArray(data)[k], windUnitUI); const v = Number.isFinite(wMs)? Math.round(wMs) : ''; windRow[i+1]=v; if(Number.isFinite(wMs)){ windSum+=wMs; windCount++; } });
      windRow[25] = windCount ? +(windSum/windCount).toFixed(2) : ''; allRows.push(windRow);

      // Temperature
      const tempRow = new Array(26).fill(''); tempRow[0] = 'Expected Temperature, ¬∞C';
      let tempSum=0, tempCount=0;
      idxs.forEach((k,i)=>{ const T = data.hourly.temperature_2m[k]; tempRow[i+1] = Number.isFinite(T) ? +T : ''; if(Number.isFinite(T)){ tempSum+=T; tempCount++; } });
      tempRow[25] = tempCount ? +(tempSum/tempCount).toFixed(2) : ''; allRows.push(tempRow);

      // Availability
      const availRow = new Array(26).fill(''); availRow[0] = 'Availability %';
      for (let i=0;i<24;i++) availRow[i+1] = 98;
      availRow[25] = 98; allRows.push(availRow);

      // Production
      const powerRow = new Array(26).fill(''); powerRow[0] = 'Expected Production, MW';
      let powerSum=0;
      idxs.forEach((k,i)=>{ const wMs = toMs(getWindArray(data)[k], windUnitUI); const prodMW = expectedProd(wMs); powerRow[i+1] = Number.isFinite(prodMW) ? +prodMW.toFixed(3) : ''; powerSum += (Number.isFinite(prodMW)? prodMW : 0); });
      powerRow[25] = +powerSum.toFixed(3); allRows.push(powerRow);
    });

    const ws = XLSX.utils.aoa_to_sheet(allRows);
    ws['!merges'] = (ws['!merges'] || []).concat(merges);

    // Thin borders & alignment + bold title/header/first col labels
    const rows = allRows.length, cols = 26;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const addr = XLSX.utils.encode_cell({ r, c });
        if (!ws[addr]) continue;
        const cell = ws[addr]; cell.s = cell.s || {};
        cell.s.border = {
          top: {style:'thin', color:{rgb:'000000'}},
          bottom: {style:'thin', color:{rgb:'000000'}},
          left: {style:'thin', color:{rgb:'000000'}},
          right: {style:'thin', color:{rgb:'000000'}}
        };
        const val = cell.v;
        const isNumeric = (typeof val === 'number') || (typeof val === 'string' && val.trim() !== '' && !isNaN(Number(val)));
        const isTimeLike = (typeof val === 'string') && /^\\d{2}:\\d{2}$/.test(val?.toString().trim());
        if (isNumeric || isTimeLike || r<=1) {
          cell.s.alignment = Object.assign({}, cell.s.alignment || {}, { horizontal: 'center', vertical: 'center' });
        }
        if (r===0){ cell.s.font = Object.assign({}, cell.s.font || {}, { bold: true, sz: 14 }); }
        if (r===1){ cell.s.font = Object.assign({}, cell.s.font || {}, { bold: true }); }
        if (r>=2 && c===0){ cell.s.font = Object.assign({}, cell.s.font || {}, { bold: true }); }
      }
    }

    XLSX.utils.book_append_sheet(wb, ws, 'Weekly');
    return wb;
  }

  function saveWorkbook(wb, filename){
    try{
      const wbout = XLSX.write(wb, {bookType:'xlsx', type:'array'});
      const blob = new Blob([wbout], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){ URL.revokeObjectURL(a.href); a.remove(); }, 2000);
    }catch(e){
      console.error(e);
      alert('ÿ™ÿπÿ∞ÿ± ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸÑŸÅ Excel ŸÅŸä ÿßŸÑŸÖÿ™ÿµŸÅÿ≠.');
    }
  }

  function exportWeeklyExcelV6(data, indices, windUnitUI){
    ensureXLSX(function(){
      const wb = buildWeeklyWorkbook(data, indices, windUnitUI);
      const wDates = indices.map(i => data.daily.time[i]);
      const fname = `WeeklyForecast_${wDates[0]}_to_${wDates[6]}_ONE_TABLE.xlsx`;
      saveWorkbook(wb, fname);
    });
  }

  // Make globally accessible and hard-bind button to this override
  window.exportWeeklyExcel = exportWeeklyExcelV6;
  document.addEventListener('click', function(ev){
    const btn = ev.target && ev.target.closest && ev.target.closest('#weeklyXlsBtn');
    if (!btn) return;
    ev.stopImmediatePropagation && ev.stopImmediatePropagation();
    ev.stopPropagation();
    ev.preventDefault();

    const store = window.__lastForecast;
    const data = store && store.data;
    if(!data || !data.daily || !data.daily.time){ alert('ŸÑŸÖ Ÿäÿ™ŸÖ ÿ¨ŸÑÿ® ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿπÿØ. ÿßÿ∂ÿ∫ÿ∑ \"ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ™ŸÜÿ®ÿ§\" ÿ£ŸàŸÑŸãÿß.'); return; }

    const weekDates = getNextWeekDates();
    const idxList = indicesForDates(weekDates, data.daily.time);
    if (idxList.some(i=> i===-1)) { alert('ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ÿ≥ÿ®Ÿàÿπ ÿßŸÑŸÇÿßÿØŸÖ ÿ∫Ÿäÿ± ŸÖŸÉÿ™ŸÖŸÑÿ©. ÿ™ÿ£ŸÉÿØ ÿ£ŸÜ forecast_days=14 ÿ´ŸÖ ÿ£ÿπÿØ ÿßŸÑÿ¨ŸÑÿ®.'); return; }

    exportWeeklyExcelV6(data, idxList, store.windUnit);
  }, true);
})();
</script>
