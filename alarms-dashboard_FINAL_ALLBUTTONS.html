<!--
  Offline Turbine Alarms Dashboard
  نسخة عربية بالكامل تعرض الإنذارات حسب التوربين وتتيح تصفية حسب الفئة والزمن.

  هذه الصفحة لا تعتمد على أية مكتبات خارجية أو اتصال بالإنترنت لقراءة ملفات CSV.
  لقراءة ملفات Excel (XLS/XLSX) يتم تحميل مكتبة SheetJS (XLSX.js) تلقائياً عند توفر اتصال
  بالإنترنت. إذا كنت غير متصل، ستظهر رسالة تطلب حفظ الملف كـ CSV.

  Author: ChatGPT
-->
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8" />
  <title>AWS Analysis</title>
  <style>

/* AWS Analysis heading style */
.panel-title {
  color: var(--accent);
  font-weight: 800;
  letter-spacing: .015em;
}



/* Reserve top space for header */
.sidebar, .content { padding-top: 78px !important; }



/* Fixed header for logo */
#page-header { position: fixed; left: 0; right: 0; top: 0; height: 64px;
  display: flex; align-items: center;
  padding: 0 10px;
  background: rgba(255,255,255,.94);
  border-bottom: 1px solid var(--border);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  z-index: 450;
}
#page-header .brand { display:flex; align-items:center; gap:8px; }
#page-header img { max-height: 48px; height: 48px; width: auto; object-fit: contain; }



/* Footer refinements */
#page-footer { height: 36px; }
#page-footer .credit { font-size: 12px; gap: 6px; }



/* Global footer credit (bottom, integrated) */
#page-footer {
  position: fixed;
  left: 0; right: 0; bottom: 0;
  height: 46px;
  display: flex; align-items: center; justify-content: center;
  background: rgba(255,255,255,.92);
  border-top: 1px solid var(--border);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  z-index: 400;
}
#page-footer .credit {
  display: inline-flex; align-items: center; gap: 8px;
  font-size: 12.5px; color: var(--muted);
}
#page-footer .credit .dot {
  width: 8px; height: 8px; border-radius: 999px;
  background: var(--accent);
  box-shadow: 0 0 0 3px rgba(14,165,233,.18);
}
#page-footer .credit strong { color: var(--text); font-weight: 700; letter-spacing: .01em; }

/* Reserve space so footer doesn't cover content */
.sidebar, .content { padding-bottom: 56px !important; }



/* Designer credit badge */
.sidebar { position: relative; padding-bottom: 70px; }
#credit-badge {
  position: absolute;
  right: 12px;
  bottom: 12px;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  font-size: 12.5px;
  color: var(--muted);
  background: rgba(255,255,255,.75);
  border: 1px solid var(--border);
  border-radius: 999px;
  box-shadow: 0 8px 22px rgba(2,6,23,.08);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
#credit-badge .dot {
  width: 8px; height: 8px;
  border-radius: 999px;
  background: var(--accent);
  box-shadow: 0 0 0 3px rgba(14,165,233,.18);
}
#credit-badge strong { color: var(--text); font-weight: 700; letter-spacing: .01em; }



/* Chart polish */
#analysis-section {
  padding: 14px !important;
  border-radius: 16px !important;
}
#analysis-section canvas {
  border-radius: 12px;
}



/* === Polished light theme (CSS-only, safe) === */
:root {
  --bg: #f7f8fb;
  --panel: #ffffff;
  --sidebar: #eaf4ff;
  --text: #0f172a;
  --muted: #475569;
  --accent: #0ea5e9;
  --accent-contrast: #ffffff;
  --border: #e5e7eb;
  --chip: #eef2ff;
}
html, body { background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
.sidebar { background: var(--sidebar) !important; color: var(--text) !important; }
.content { background: var(--panel) !important; border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 10px 24px rgba(2,6,23,.06); }

/* Inputs */
.filter-section input[type="text"],
.filter-section input[type="date"],
.filter-section input[type="time"] {
  background: var(--panel) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  padding: 8px 10px !important;
  border-radius: 10px !important;
  outline: none;
  transition: box-shadow .15s ease, border-color .15s ease;
}
.filter-section input::placeholder { color: var(--muted); opacity: .9; }
.filter-section input:focus { border-color: var(--accent); box-shadow: 0 0 0 4px rgba(14,165,233,.2); }

/* Event list pills */
.event-list { padding: 6px; }
.event-item {
  background: var(--chip) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  border-radius: 12px !important;
  padding: 8px 10px !important;
  transition: transform .1s ease, box-shadow .2s ease, background .2s ease;
}
.event-item:hover { transform: translateY(-1px); box-shadow: 0 8px 18px rgba(2,6,23,.08); }
.event-item.selected {
  background: var(--accent) !important;
  color: var(--accent-contrast) !important;
  border-color: transparent !important;
  box-shadow: 0 8px 20px rgba(14,165,233,.35);
}

/* Buttons */
button {
  border: 1px solid var(--border) !important;
  background: linear-gradient(to bottom, rgba(255,255,255,.95), rgba(245,246,250,.95)) !important;
  color: var(--text) !important;
  padding: 8px 12px !important;
  border-radius: 10px !important;
  cursor: pointer;
  font-weight: 600;
  transition: transform .1s ease, box-shadow .2s ease, border-color .15s ease;
}
button:hover { transform: translateY(-1px); box-shadow: 0 12px 24px rgba(2,6,23,.10); border-color: var(--accent); }
button:active { transform: translateY(0); box-shadow: none; }
#export-btn, #export-excel-btn, 
#analysis-img-btn, #analysis-pdf-btn { display: none; } /* intentionally removed auto-hide for robust visibility */

/* Table styling */
#table-container table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  overflow: hidden;
  border-radius: 12px;
  box-shadow: 0 10px 24px rgba(2,6,23,.06);
}

#table-container thead th.sortable-th { user-select: none; }
#table-container thead th.sortable-th:hover { filter: brightness(1.05); }

#table-container thead th {
  position: sticky; top: 0;
  background: #0f172a !important;  /* deep navy header */
  color: #ffffff !important;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: .04em;
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
}
#table-container tbody td {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  vertical-align: middle;
  background: var(--panel);
  color: var(--text);
}
#table-container tbody tr:nth-child(even) { background: rgba(2,6,23,.03); }
#table-container tbody tr:hover { background: rgba(14,165,233,.10); }
#table-container tbody td:nth-child(5),
#table-container tbody td:nth-child(6) { text-align: right; font-variant-numeric: tabular-nums; }

/* Metrics chips */
.metrics { display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
.metric {
  background: var(--chip) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  border-radius: 999px !important;
  padding: 6px 10px !important;
  box-shadow: 0 2px 8px rgba(2,6,23,.06);
}
.metric span { opacity:.8; margin-inline-end:4px; }
.metric strong { font-variant-numeric: tabular-nums; }

/* Chart canvas frame */
#analysis-section { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 10px; box-shadow: 0 10px 24px rgba(2,6,23,.06); }
#selected-event-title { font-size: 18px; font-weight: 800; letter-spacing: .015em; margin: 10px 0; }

/* Scrollbars */
* { scrollbar-width: thin; scrollbar-color: rgba(100,116,139,.6) transparent; }
*::-webkit-scrollbar { width: 10px; height: 10px; }
*::-webkit-scrollbar-track { background: transparent; }
*::-webkit-scrollbar-thumb { background: rgba(100,116,139,.5); border-radius: 10px; border: 2px solid transparent; background-clip: padding-box; }
*::-webkit-scrollbar-thumb:hover { background: rgba(100,116,139,.8); }


/* === Metrics bar above the analysis chart === */
.metrics {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  align-items: center;
  margin-bottom: 6px;
}
.metric {
  background: var(--sidebar-color);
  border: 1px solid var(--accent-color);
  border-radius: 6px;
  padding: 6px 8px;
  font-size: 13px;
}
.metric span {
  opacity: 0.8;
  margin-inline-end: 4px;
}

    :root {
      /* ألوان مستوحاة من الصورة المرفقة: مزيج بين الأزرق الداكن والأبيض والأزرق الفاتح */
      --bg-color: #ffffff;
      --sidebar-color: #e6f2fa;
      --accent-color: #00a5e3;
      --text-color: #000000;
      --highlight-color: #8dd7f8;
      --error-bg: #fdecea;
      --error-text: #b00020;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: row-reverse;
      height: 100vh;
      /* خلفية بيضاء للموقع كما هو مطلوب */
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: system-ui, sans-serif;
      overflow: hidden;
    }
    .sidebar {
      width: 280px;
      max-width: 100%;
      background-color: var(--sidebar-color);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
    }
    .content {
      flex: 1;
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
      /* اجعل خلفية منطقة المحتوى بيضاء حتى لا يتأثر بالتدرج في الـbody */
      background-color: var(--bg-color);
      border-radius: 8px;
    }
    h1, h2, h3 {
      margin: 0 0 8px 0;
      font-weight: 600;
    }
    h1 {
      font-size: 20px;
    }
    h2 {
      font-size: 18px;
    }
    h3 {
      font-size: 16px;
    }
    .message {
      padding: 8px;
      border-radius: 4px;
      background-color: var(--error-bg);
      color: var(--error-text);
      display: none;
      font-size: 14px;
    }
    .filter-section {
      margin-bottom: 12px;
    }
    .filter-section label {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
    }
    .filter-section input[type="date"],
    .filter-section input[type="time"] {
      width: 100%;
      padding: 4px;
      border-radius: 4px;
      border: none;
      background-color: var(--accent-color);
      color: var(--text-color);
    }
    .quick-buttons button {
      margin: 2px;
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      background-color: var(--accent-color);
      color: var(--text-color);
      cursor: pointer;
      font-size: 12px;
    }
    .quick-buttons button:hover {
      background-color: var(--highlight-color);
    }
    .category-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 120px;
      overflow-y: auto;
    }
    .category-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 14px;
    }
    .event-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 300px;
      overflow-y: auto;
      direction: ltr; /* عرض عناصر قائمة الإنذارات من اليسار لليمين لتجنب انزلاق النص خارج الحاوية في الوضع RTL */
    }
    .event-item {
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      background-color: var(--accent-color);
      color: var(--text-color);
      font-size: 14px;
      /* السماح بظهور النص بالكامل داخل عنصر الإنذار حتى وإن كان طويلاً */
      white-space: normal;
      overflow-wrap: anywhere;
      direction: ltr; /* عرض أسماء الإنذارات من اليسار لليمين حتى لا تختفي النصوص في الوضع RTL */
      text-align: left;
    }
    .event-item.selected {
      background-color: var(--highlight-color);
      font-weight: bold;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 14px;
    }
    th, td {
      padding: 8px;
      border: 1px solid var(--accent-color);
      text-align: left;
      /* Set direction to left-to-right since the table is now fully in English */
      direction: ltr;
    }
    th {
      background-color: var(--accent-color);
    }
    #export-btn {
      align-self: flex-start;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      background-color: var(--accent-color);
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
    }
    #export-btn:hover {
      background-color: var(--highlight-color);
    }
    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: var(--sidebar-color);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--accent-color);
      border-radius: 3px;
    }

    /* Logo container inside content: display flex and allow wrapping */
    #logo-container {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      margin-bottom: 16px;
      width: 100%;
    }
    #logo-container img {
      max-width: 150px;
      height: auto;
    }
    #logo-container #selected-event-title {
      margin-top: 4px;
      font-size: 16px;
      font-weight: 600;
      color: var(--text-color);
      max-width: 100%;
      white-space: normal;
      word-break: break-word;
    }
  </style>
</head>
<body>
<header id="page-header"><div class="brand"><!-- Use the provided logo image from the same directory.  It will scale down automatically. -->
      <!-- Embed the logo image directly using a base64 data URI to ensure it always displays correctly -->
      <img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAA8AL4DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKSlqnrF4unaXd3bHCwQvKf+AqT/AEppNuyJlJRTky3S189/sy+PNQkt4tD1uSVzqULanpk87ljKpZhIgJ/2lLY9m9q+hK7cbhJYKvKjJ3t17/1+Z5eV5jTzXCxxNNWvuuqfb9V3TTCiiiuE9Y8e+PXxe1j4dXvh3TvD9ta3mpapI6+XcozcAqqhQGHJZsc+lcvrvxC+N/hrR7zVNQ8MaJBY2cZlmlDhtqjqcCbJ/CqXxc+HviH4nfHbTbSGC/0zR7S0RBrUcDGOJgGlJVsgbtxVevUe1Y3xa+BPirw/4XEtl4p8Q+MJJp1ifTPLkkBXBYuQHbgEDqO4r7fC0sDGnh6U3Dnkru6ber01TSWnc/K8wxGaVK2Lr0lU9nB2jyyjFaJX0ablrroe3/B/4jXPj34dw+ItXgt9OkDTLK0bERbY2IL/ADHgYBzk8YNeM+KP2qfEq3l9qnh/RrSXwlb3a2cd5dROWlbaW6hgAWVSQMcDGeTV/wAbab4v1vwn4V+HPh3w7PpNrNaQHVbxbd47SNioZotxz8oOS/JJOF55qjrXwD+JFn8OZvD66xot5o1oDdJp9rakTSyKS/D7MlyeOTz0qcNh8BTqOrX5bTlpFt6RvvpfXte2hWNxmb1qMaGF5704+9OMV707LTW2i6tXd9LHtnjz4oWvhH4Zv4st4hepJDE9pEW2iRpcbAT2HzZPsDXkui/Fn4q+JNMt9Tsz4Ngtrld8cdxdhJFH+0pkyD7HmsUHxofgBpuhT+BptWe1vWtp7XULWbzBAB5kMiKrK3BO3I6bfeueXw1oDxLn4J+J2ucDP+kz7C2PQr0z+la4XA4ejTnGUVKXM1f3XottHONr7mOPzXGYirTnCcoR5Itr34+899VTne21tD03xH8dvFXw3+DV94o8V6dpy69cXX2TR9OgVwJ2PAd8McrgMw2nlQP7wrAi8W/tPXFvHOPC/hSASoHWKaUK6gjOCDNwfao/iv4o+Kum/Crwba2PhK71G7u2WfV20+12tBEkgK2gjQFow6YUsBwAR1NeafGHXNW+NF5/aF98EfGsOtR2ZtLSSO8nSCLlmDGNYRu+ZsnkZwBXNRw8ZNv2cLNyu7p2torJyjpv59T16mKnCEU6tS6jGyaabb1d2oyu9lsktj0GH9p34h6H8H/FeveKvCcOi65p91aWunG5tZoYbppmIbKM2TsVScq2Dkfj6z8K/jjo/iT4eaDqniTxH4dsNbvLYT3NrHfxRCJmJIXazlgQuMgnrmvkjXPgd4+0n4H+FfDSeHNTudT1rXJdUvo4YmlNoixpDAJiMhTh3fGeOc9K991T9if4X6Zod1cro2p391b2zyCOK/lLzOqE4AB6sRwB61niqOXqFm7OUnblV9FZdXom9TowVfNJTuldRirqba1d30jq0rJl/wCDf7QGtfFT41eMtBhi01/COjLJ9mvLZHMs2JRGjb9xUhsSHgdAKyfjv+1BrXhXxofCXw/0u117V7C3lvNWknRpI7dETeyAKy/Mq/MxJ4yq9TivLPgnpfjv4I/BzxXqVh4J1qXxlrt5HZWNr/Z8jPbRxxZM7rjhQ0jbQfvMB2Bra+GP7Mvxk8F2t7qemeJfD2l6hrkIOoLqVsbq4+bLNG7tG3OWJbacE+uBVywuDp151JOPLGyim9JOyu3a7/zZEMZj62HhSipc8ryk0tYpt2SvZXf4I96/Zt+MM3xq+G0WtXsdvBq0NxJaXkVqCIw4IKsoJJAKMp5PXNeNad+0d8YPiJ438V6b8P8Aw1oeraZo948SyXAKMI/MZIyzNMoLNsY8Csj9mvw349+BviH4iaDfeHNSuLP+z5p7S8trSRra4uoFPl+UxAz5itgDqSoFY3wG/ZN8Ya94Wu9W1DxT4g+Hl/PctG9hDA8UkyqARI/zqeWZ8ZHbPej6vg8PUr1JOPLpy3u1rrstdNhfWsfiaWHpRUuf3ue1ovTRavTXc626/aQ+Mfgf4ieF/D3jPwnodv8A21cxRpBasTI8byrGWVllcAgt0I5qXUP2mPiX4j+Kni3w14K03wzcWWi3MkSyapKYSyI/llt7SqGJcNwB0rnfA/wh8WeB/wBphrjVbLWPHGj6NZzTQa9qtrK4Mi2+9BCzMRvEjbBgnOWwAeR5b4L+HOsWcmqXPjH4HeJfF93ez/aI5N9zZ+QW3FxhUO4lmzk9MV2Qw+DleSjFvlW2zbfZyWyXV9ThlisfC0JTmlzPfdKKX2oxe7fRNafM+ovA/wAQPjbqXirT4vEGm+DbXQFcyahcWN6ss0cCgliqrMxz0HQ4zXnngz9p34y/E1dSu/DGh+FJbC1uDHm8nEDAHLIPnnXcduMkDFVPBOgNovh3x/deHPgZrfg3WW8PzWttdTXFxdSTvK6oIo0dBzyXJHICe9eZeC/hpNouhra+I/gD4n8TaksjH7ctzdWo2HG1PLVCOPXvmpp4fDy9o5QjdWSXu+rdue3b7XyLq4rFR9nGNSVndt+96JX9nfo38PzPb/Df7THxPsfjD4b8F+K9A8Ps2rTRq66TMZHjjcsPMDJK65UKWKnsO2Qa+gPjTrH9h/CTxbe5wY9MnAPuyFR+rV8r/s5fCvxLbftAW/iPT/A2pfDzwpbW8gmtNQkeTfmIrsDSAM5ZyG4GFC9a94/a61I2PwL1qBTiS/mtrNfcvMnH5A15uIo0fr9ClSSV+W9u7fq1+LPVwtbEf2ZiateTdublv2S0s7JvXukch4ohsPA3wB+Husy3iadrWmJZ/wBnyEEtLLKAzRcdiCWPoFNe1fD74jaP8Q9J+06dcxm6hCrd2e795bORnay9cdcN0OOK8Q8BacPjp8WrfWGHneA/ASrp+lLj93e36qoeb3C4GPonqay/HHwqv/CfxohufDWrP4c1LUUeXR7rGbeSTdue0mHdCScdcbl4PbnxXs5yVOvO0tXfouZ3SfX17N+Ry0KlbANYnDwvRfLBpbtxVlNdNfhXe0T6uory74b/ABkbW9RPhrxbYHw14wh+VrOX/U3X+3C2eQf7uT7E16hnNePWoVMPPkqK35Nd0+qPscLi6OMp+0oyutn3T7Nbprsw2jOcc0YFLRXOdgm0elFLRQA3aPSsvX/Edp4d/s/7YJNl9dJZoyAFUdlYgsSeF+UjPuK1qxfF3hHTvG2kf2bqiSPa+dHMRFIUJKOGAyOcHGCO4JHegDm7f4z+H7nRm1OKK9a2S2vLxx5IV0it32Fipbje2Ag6tntg4nvvi7oWn61q2kzLeDUNNjtnkgEXMnnuiKsZzhmVpYgw/h8xfWrR+F+hG312HyptutXSXV4fNOSVZWCL/dTKn5Rx87/3qZffCrQNS1K2v7iGaS8t9W/tmOYykET7FTHumEj+Tp8inqBQAz/hZ2nf20bJtP1BLUaj/ZP9p+WhtvtOBhOH3gFiF3FNu7jNWvGXxC0/wVdaZa3UE1zc6h5pgjilhi4jCliWmkRf4lGM5JPSodJ+GOl6XqgvGub++CXc1/DbXdxvhhnlZmeRUAGWy7YLZ254xU/iT4f2fibWrPVJL29tLq1ha3T7M6bSjOrsCrowySi8jB4oAzdS+L2g6Tq2qaXdRXkWo6faQ3ctv5QJcSMqiNCGwzqXj3DPHmIckGrll8StO1DxVf6FbW80klhK0Vzc+dbqkZWNXY7DL5pADqNwTGTSap8LdB1q+S8vIZZrpNWj1lZTKQROkaRgf7m2NAU6HAplp8L9Ps7jWZI77UPL1X7SZ4TKm1WnOXZDs3A+nzED0oAp6b8YtHvLR7m4sdS0yI2MWpQ/aoVZriGV/LiKLG7nczEAIwDEsMDrjRn+Iltpen/btX0rUdDtRdRWry3yxBI/M4WRmWRgEyQpJPBIyO9VrX4PeGdP0zUrCys20+1vjbuy2b+UYpIAPKljK4KuCqHPcrnHJzbb4b6VPoOoaVePdahHqM6XF5NdS75bhkKYDHGNuI0XaABgH1oAux+MLF/CU/iSSK5t9Mht5LsmWE+Y0KAneEGThlG4DGcEcA8UvhDxVD4w0hdRgs7i0tpD+6M7xOJVwCHVondSOcdcgggjir+s6WNZ0yeza5urMSgfv7OYxSoQQQVYdOn0I4OQaxNI+HlhoWk3FhY3d9bJdG4kuJo5gsks02N8xIHDjHBUADJwKALHh3xtpvijVNXsLJZy+muivLJHtjmDbhviP8abo5E3dNyNjPWqa/Eawm8aXHhm3tLi4vbZ0SeRZYFWMtGJPutKJGAVlJKocZ+tM0X4VaB4YupZ9Dhl0ZpbaO0ZbOUhTGj714OeRlhn0Y1LY/Du003xBqOr2+oagk19LJNLEZEKB3RULLlNwwFXA3YGOlAHVYHXFfMX7cWvQ3nhzw14Ptp8arqOordmNVLGOCNXUyMBzgMw+u0+lfQ2u65YeCvC93qmq3ZisNOtjLPcTEFtqjkn1Y/qTXyp8Mfi14dtvEus/E7xdcte+LNeP2fRvD9gn2m4s7FThE2jhGfHOcEjn+I17mV0Z+0+sxi5cmyXV9F8t2+h83neIpqj9VlNQ5929lFbvdXvsl1v5HqPw5+Kfw4+G/g3S/DumXV5HaWUQTzJLCVWlfq8jcdWYkn61V+K3xN8D+PPCc1tBrEltqtqwurC4a1lUxzJyvO3gHp+IPatS11D4mfErD2+mW/gHR26TXiia+ZfZcfIfwH1ro/DPwM8OaJdfb75JfEGqsd7XeqN5nzeoT7o/EE+9Rj6eHUXdXnLdc6l97UbX9G/keRQ/tPGQ9hS5fY2teVOUFb+6nNy9LpLszgLz4mfDr4l+DdPj8XX0dhrccYLSxxP5tvKOrRuqkYJGcdOeelUPDf7R0fg2WbStUv18W6fEP8ARNVsvkmZf7sqyY5A79fr1r6EbQdOfO6wtW+sCf4VE3hfR2+9pdk31to/8K8WdTEOkqMZe6u+v9X62PV/s3F+1VeNWKnazai1zL+8uZp/dddLGpRRRTPpgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAOM+LHwvsPi74V/wCEf1O9vrKxa5iuJfsMio0gQ5CNkEFSeenUA9qPh/8AB/wj8MrUReH9Ft7OXGHumHmXD+u6Rst+uPauzordV6qp+xUny9uhzPC0ZVfbuCc9r9RKWiisDpCiiigD/9k=" alt="Ras Ghareb Wind Energy Logo" />
      <!-- This element will be updated dynamically to show the selected alarm name -->
      <h2 id="selected-event-title"></h2></div></header>

  <!-- Logo container will be placed inside the content for scrollable behaviour -->
  <div class="sidebar">
    <!-- تمت إزالة الشعار القديم. سيتم عرض الشعار الجديد في أعلى يسار الموقع -->
    <h1><span class="panel-title">AWS Analysis</span></h1>
    <input type="file" id="file-input" accept=".csv,.txt,.xls,.xlsx" />
    <div id="message" class="message"></div>
    <div id="filters" style="display:none;">
      <div class="filter-section">
        <h3>Category Filter</h3>
        <div id="category-filters" class="category-list"></div>
      </div>
      <div class="filter-section">
        <h3>Time Filter</h3>
        <label>From (Date):
          <input type="date" id="start-date" />
        </label>
        <label>To (Date):
          <input type="date" id="end-date" />
        </label>
        <label>From (Time):
          <!-- Use 24-hour format by default by specifying the value -->
          <input type="time" id="start-time" value="00:00" />
        </label>
        <label>To (Time):
          <!-- Set the default value to the end of the day -->
          <input type="time" id="end-time" value="23:59" />
        </label>
        <div class="quick-buttons">
          <button id="today-btn">Today</button>
          <button id="yesterday-btn">Yesterday</button>
          <button id="last24-btn">Last 24 hours</button>
          <button id="clear-filter-btn">Clear filter</button>
        </div>
      </div>
      
<div class="filter-section">
  <h3>Filter by Turbine</h3>
  <input type="text" id="device-filter" placeholder="Type turbine number/name (e.g., 5 or WTG-05)" style="width:100%; padding:4px; border-radius:4px; border:none; background-color: var(--accent-color); color: var(--text-color); margin-bottom:4px;" />
  <div class="quick-buttons">
    <button id="clear-device-filter-btn">Clear turbine</button>
  </div>
</div>

<div class="filter-section">
  <h3>Emergency sequences</h3>
  <button id="btn-emergency-seq" style="width:100%; padding:6px; border-radius:6px; border:1px solid #e5e7eb; cursor:pointer;">
    Show pre-alarms before emergency
  </button>
</div>

<div class="filter-section">
        <h3>Alarm List</h3>
        <!-- مربع البحث عن الإنذارات -->
        <input type="text" id="event-search" placeholder="Search for alarm..." style="width:100%; padding:4px; border-radius:4px; border:none; background-color: var(--accent-color); color: var(--text-color); margin-bottom:4px;" />
        <div id="event-list" class="event-list"></div>
      </div>
    </div>
    <!-- فقرة لعرض اسم المصمم -->
    
    <!-- أيقونة توربين رياح لإضافة مظهر طاقة الرياح -->
    <div style="margin-top:12px; text-align:center;">
      <svg width="60" height="80" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
        <!-- برج التوربين -->
        <rect x="31" y="32" width="2" height="28" fill="var(--text-color)" />
        <!-- المحور -->
        <circle cx="32" cy="32" r="3" fill="var(--text-color)" />
        <!-- الريش الثلاثة -->
        <line x1="32" y1="32" x2="32" y2="16" stroke="var(--accent-color)" stroke-width="2" />
        <line x1="32" y1="32" x2="44" y2="42" stroke="var(--accent-color)" stroke-width="2" />
        <line x1="32" y1="32" x2="20" y2="42" stroke="var(--accent-color)" stroke-width="2" />
      </svg>
    </div>
  </div>
  <div class="content">
    <!-- Logo and selected alarm name container (scrolls with the page) -->
    
    <div id="table-container"></div>
    <!-- أزرار التصدير للجدول -->
    <div style="display:flex; flex-wrap: wrap; gap:8px; margin-top:8px;">
      <button id="export-btn" style="display:none;">Export table (CSV)</button>
      <button id="export-excel-btn" style="display:none;">Export table (Excel)</button>
      <button id="export-pdf-btn" style="display:none;">Export table (PDF)</button>
    </div>

    <!-- قسم التحليل لأعلى التوربينات حسب إجمالي Total Duration -->
    <div id="analysis-section" style="display:none; margin-top:24px;">
      <!-- Heading removed to keep chart only -->
      <!-- الرسم البياني -->
      <!-- صغر حجم الرسم البياني للملاءمة -->
      <div id="chart-metrics" class="metrics">
  <div class="metric"><span>Alarm Name:</span> <strong id="metric-alarm">—</strong></div>
  <div class="metric"><span>Occurrences:</span> <strong id="metric-count">0</strong></div>
  <div class="metric"><span>Total Duration:</span> <strong id="metric-duration">00:00</strong></div>
</div>

      <canvas id="analysis-chart" style="width:100%; max-width:100%; height:200px; max-height:200px;"></canvas>
      <!-- جدول التحليل -->
      <div id="analysis-table-container" style="margin-top:12px;"></div>
      <!-- أزرار تصدير التحليل -->
      <div style="display:flex; flex-wrap: wrap; gap:8px; margin-top:8px;">
        <button id="analysis-img-btn" style="display:none;">Export analysis (Image)</button>
        <button id="analysis-pdf-btn" style="display:none;">Export analysis (PDF)</button>
      </div>
    </div>
  </div>
  <script>
    // بيانات التحميل
    let dataset = [];
    let header = [];
    let colMap = {};
    let filteredData = [];
    let events = [];
    let selectedEvents = new Set(['__ALL__']);
function isAllSelected() {
  return selectedEvents.has('__ALL__') || selectedEvents.size === 0;
}
function currentAlarmLabel() {
  if (isAllSelected()) return 'All';
  const names = Array.from(selectedEvents);
  return names.length === 1 ? names[0] : `Multiple (${names.length})`;
}

    let searchTerm = '';
    let searchedEvents = [];
    let deviceFilterTerm = '';  // نص فلترة التوربينة (Device/WTG)


    // متغيرات عالمية للاحتفاظ بنطاق Date/الوقت الحاليين
    // يُستخدمان لحساب الإحصاءات بغض النظر عن فلاتر الفئة في جداول الإنذارات المفردة.
    let globalStartFilter = null;
    let globalEndFilter = null;

    // عناصر DOM
    const fileInput = document.getElementById('file-input');
    const messageDiv = document.getElementById('message');
    const filtersDiv = document.getElementById('filters');
    const categoryFiltersDiv = document.getElementById('category-filters');
    const eventListDiv = document.getElementById('event-list');
    const eventSearchInput = document.getElementById('event-search');
    const tableContainer = document.getElementById('table-container');
    const selectedEventTitle = document.getElementById('selected-event-title');
    const exportBtn = document.getElementById('export-btn');
    const exportExcelBtn = document.getElementById('export-excel-btn');
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    const analysisSection = document.getElementById('analysis-section');
    const analysisChartCanvas = document.getElementById('analysis-chart');
const metricAlarm = document.getElementById('metric-alarm');
const metricCount = document.getElementById('metric-count');
const metricDuration = document.getElementById('metric-duration');

    const analysisTableContainer = document.getElementById('analysis-table-container');
    const analysisImgBtn = document.getElementById('analysis-img-btn');
    const analysisPdfBtn = document.getElementById('analysis-pdf-btn');
    let analysisChart = null;
    // تخزين أعداد الإنذارات وTotal Duration لكل عنصر في التحليل لرسمها على الأعمدة
    let analysisCounts = [];
    let analysisDurationsFormatted = [];
// === Sorting state for table ===
let currentSort = { key: null, dir: 'desc' }; // key in ['count','duration'], dir in ['asc','desc']

// Helper: toggle sort
function toggleSort(key) {
  if (currentSort.key === key) {
    currentSort.dir = (currentSort.dir === 'asc') ? 'desc' : 'asc';
  } else {
    currentSort.key = key;
    currentSort.dir = 'desc'; // default to largest -> smallest
  }
  updateTable();
}

// Helper: compare with direction
function compareBy(a, b, key) {
  const sign = (currentSort.dir === 'asc') ? 1 : -1;
  let va = a[key], vb = b[key];
  // Normalize types per column
  if (key === 'count' || key === 'duration') {
    va = Number(va) || 0; vb = Number(vb) || 0;
  } else if (key === 'date') {
    function norm(d) {
      if (!d) return 0;
      if (Array.isArray(d)) {
        const t0 = (d[0] instanceof Date) ? d[0].getTime() : 0;
        const t1 = (d[1] instanceof Date) ? d[1].getTime() : 0;
        return Math.min(t0 || 0, t1 || 0);
      }
      return (d instanceof Date) ? d.getTime() : 0;
    }
    va = norm(va); vb = norm(vb);
  } else {
    va = (va ?? '').toString().toLowerCase();
    vb = (vb ?? '').toString().toLowerCase();
  }
  if (va < vb) return -1 * sign;
  if (va > vb) return 1 * sign;
  return 0;
}


    // تاريخ وزمن التصفية
    const startDateInput = document.getElementById('start-date');
    const endDateInput = document.getElementById('end-date');
    const startTimeInput = document.getElementById('start-time');
    const endTimeInput = document.getElementById('end-time');

    const todayBtn = document.getElementById('today-btn');
    const yesterdayBtn = document.getElementById('yesterday-btn');
    const last24Btn = document.getElementById('last24-btn');
    const clearFilterBtn = document.getElementById('clear-filter-btn');

    // مدخل تصفية التوربينة
    const deviceFilterInput = document.getElementById('device-filter');
    const clearDeviceFilterBtn = document.getElementById('clear-device-filter-btn');


// أحداث إدخال لمسح وتطبيق فلتر التوربينة
if (clearDeviceFilterBtn) {
  clearDeviceFilterBtn.addEventListener('click', () => {
    if (deviceFilterInput) deviceFilterInput.value = '';
    deviceFilterTerm = '';
    updateFilteredData();
  });
}
if (deviceFilterInput) {
  deviceFilterInput.addEventListener('input', () => {
    deviceFilterTerm = (deviceFilterInput.value || '').trim().toLowerCase();
    updateFilteredData();
  });
}

    // إظهار رسالة خطأ
    function showMessage(msg) {
      messageDiv.textContent = msg;
      messageDiv.style.display = 'block';
    }
    function hideMessage() {
      messageDiv.style.display = 'none';
    }

    // كشف الأعمدة بالاعتماد على الأسماء المحتملة
    function detectColumns() {
      const lowerHeader = header.map(h => h.trim().toLowerCase());
      function findCol(possibles) {
        for (let name of possibles) {
          const idx = lowerHeader.indexOf(name.toLowerCase());
          if (idx !== -1) return header[idx];
        }
        return null;
      }
      // مرادفات بالعربية والإنجليزية
      colMap.device = findCol(['device','wtg','turbine','التربينة','التربينات','التركيبة','(device/wtg)','اسم التوربينة']);
      colMap.event = findCol(['event','event name','alarm','alarm name','اسم الإنذار','event/subevent/category','subevent','subevent / categorization']);
      colMap.category = findCol(['category','الفئة','categorization','توصيف','category/event']);
      colMap.duration = findCol(['duration','مدة','duration (hh:mm:ss)','time','Total Duration']);
      colMap.start = findCol(['start date','start','start time','بداية الحدث','تاريخ البداية']);
      colMap.end = findCol(['end date','end','end time','نهاية الحدث','تاريخ النهاية']);
      // كشف العمود الفرعي (subevent) إن وجد، لعرض اسم الإنذار عند عدم وجود اسم في العمود الأساسي
      colMap.subevent = findCol(['subevent','subevent/categorization','subevent / categorization','categorization description','categorisation description','subevent categorization']);
      // احتياطي: لو لم يتم العثور على event، استخدم subevent إذا كان متاحًا
      if (!colMap.event) {
        colMap.event = findCol(['subevent','subevent / categorization']);
      }
    }

    // تحليل السطر الواحد مع مراعاة علامات الاقتباس
    function splitCSVLine(line, delim) {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
          if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === delim && !inQuotes) {
          result.push(current);
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current);
      return result;
    }

    // تحليل نص CSV كامل وإرجاع كائن {header,data}
    function parseCSV(text) {
      const lines = text.split(/\r\n|\n|\r/);
      if (!lines.length) return { header: [], data: [] };
      // اكتشاف الفاصل: جرب الفواصل الشائعة واختَر الذي يعطي أكبر عدد من الحقول في الصف الأول
      const candidateDelims = [',',';','\t','|'];
      let bestDelim = ',';
      let maxFields = 0;
      for (const d of candidateDelims) {
        const fields = splitCSVLine(lines[0], d);
        if (fields.length > maxFields) {
          maxFields = fields.length;
          bestDelim = d;
        }
      }
      const delim = bestDelim;
      // تحليل الصفوف مع مراعاة الأسطر داخل الاقتباسات
      const rows = [];
      let currentLine = '';
      let inQuotes = false;
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        currentLine += (currentLine ? '\n' : '') + line;
        // عدّ علامات الاقتباس لمعرفة إذا ما زلنا داخل حقل مقتبس
        let quoteCount = 0;
        for (let j = 0; j < line.length; j++) {
          if (line[j] === '"') quoteCount++;
        }
        if (quoteCount % 2 === 1) {
          // عدد فردي من الاقتباسات في هذا السطر – نواصل على السطر التالي
          continue;
        }
        const record = splitCSVLine(currentLine, delim);
        rows.push(record);
        currentLine = '';
      }
      const headerRow = rows.shift() || [];
      const data = [];
      for (const row of rows) {
        if (row.length === 0 || row.every(cell => cell.trim() === '')) continue;
        const obj = {};
        for (let j = 0; j < headerRow.length; j++) {
          obj[headerRow[j].trim()] = row[j] !== undefined ? row[j].trim() : '';
        }
        data.push(obj);
      }
      return { header: headerRow, data };
    }

    // تحليل مدة على شكل HH:MM:SS أو MM:SS أو ثواني
    function parseDuration(str) {
      if (!str) return 0;
      // أزل الفواصل المنقوطة والفواصل البيضاء
      str = String(str).trim().replace(/;+$/, '');
      if (!str) return 0;
      const parts = str.split(':');
      let seconds = 0;
      if (parts.length === 3) {
        seconds += parseFloat(parts[0]) * 3600;
        seconds += parseFloat(parts[1]) * 60;
        seconds += parseFloat(parts[2].replace(',', '.'));
      } else if (parts.length === 2) {
        seconds += parseFloat(parts[0]) * 60;
        seconds += parseFloat(parts[1].replace(',', '.'));
      } else {
        seconds += parseFloat(str.replace(',', '.'));
      }
      return isNaN(seconds) ? 0 : seconds;
    }

    function formatDuration(seconds) {
      if (seconds <= 0 || isNaN(seconds)) return '00:00';
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = seconds % 60;
      const hh = h > 0 ? String(h).padStart(2, '0') + ':' : '';
      const mm = String(m).padStart(2, '0');
      const ss = s < 10 ? '0' + s.toFixed(0) : s.toFixed(0);
      return hh + mm + ':' + ss;
    }

    // تنسيق Date على شكل YYYY-MM-DD لعرضه في الجدول
    function formatDateShort(date) {
      if (!date || !(date instanceof Date) || isNaN(date.getTime())) return '';
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth() + 1).padStart(2, '0');
      const dd = String(date.getDate()).padStart(2, '0');
      return yyyy + '-' + mm + '-' + dd;
    }

    // قراءة Date والوقت من النصوص
    function parseDateTime(dateStr, timeStr) {
      if (!dateStr) return null;
      let dtStr = dateStr;
      if (timeStr) dtStr += 'T' + timeStr;
      // استخدم Date مباشرة مع التعامل مع الفاصل /
      return new Date(dtStr);
    }
    function parseRowDate(row) {
      const s = row[colMap.start] || '';
      const e = row[colMap.end] || '';
      // جرب تحويل السلسلة مباشرة
      let startDate = null;
      let endDate = null;
      if (s) {
        // استبدل الفراغ بفاصل T إذا كان هناك وقت
        const iso = s.replace(/\//g, '-').replace(' ', 'T');
        startDate = new Date(iso);
      }
      if (e) {
        const iso2 = e.replace(/\//g, '-').replace(' ', 'T');
        endDate = new Date(iso2);
      }
      return { startDate, endDate };
    }

// احسب تقاطع (Overlap) فترة صف واحد مع مجال الفلترة الزمني وأعده بالثواني
function overlapSeconds(startDate, endDate, startFilter, endFilter) {
  if (!(startDate instanceof Date) || !(endDate instanceof Date)) return 0;
  if (isNaN(startDate) || isNaN(endDate)) return 0;
  let s = startDate, e = endDate;
  if (startFilter && e < startFilter) return 0;
  if (endFilter && s > endFilter) return 0;
  if (startFilter && s < startFilter) s = startFilter;
  if (endFilter && e > endFilter) e = endFilter;
  const sec = (e.getTime() - s.getTime()) / 1000;
  return sec > 0 ? sec : 0;
}

// أرجِع Dateين بعد القصّ داخل مجال الفلترة (إن كان هناك تداخل)، وإلا (null,null)
function clippedDates(startDate, endDate, startFilter, endFilter) {
  if (!(startDate instanceof Date) || !(endDate instanceof Date)) return { cs: null, ce: null };
  if (isNaN(startDate) || isNaN(endDate)) return { cs: null, ce: null };
  let s = startDate, e = endDate;
  if (startFilter && e < startFilter) return { cs: null, ce: null };
  if (endFilter && s > endFilter) return { cs: null, ce: null };
  if (startFilter && s < startFilter) s = startFilter;
  if (endFilter && e > endFilter) e = endFilter;
  if (e <= s) return { cs: null, ce: null };
  return { cs: s, ce: e };
}


    // إنشاء قائمة الفئات
    function buildCategoryFilters() {
      categoryFiltersDiv.innerHTML = '';
      // احسب تكرار الفئات المصنفة (Alarm, State, Warning, Other)
      const counts = {};
      filteredData.forEach(row => {
        let rawCat = row[colMap.category] || '';
        let trimmedCat = rawCat ? String(rawCat).trim() : '';
        const hasSub = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
        let key;
        if (hasSub) {
          key = '__OTHER__';
        } else if (!trimmedCat || trimmedCat.toLowerCase() === 'unknown' || trimmedCat === 'غير معروف' || trimmedCat === 'بدون فئة') {
          key = '__OTHER__';
        } else {
          const lc = trimmedCat.toLowerCase();
          if (lc.includes('alarm') || trimmedCat === 'إنذار') {
            key = 'Alarm';
          } else if (lc.includes('state') || trimmedCat === 'حالة') {
            key = 'State';
          } else if (lc.includes('warning') || trimmedCat === 'تحذير') {
            key = 'Warning';
          } else {
            key = '__OTHER__';
          }
        }
        counts[key] = (counts[key] || 0) + 1;
      });
      // أنشئ مربعات الاختيار للفئات المعروفة إذا كانت موجودة في البيانات
      ['Alarm','State','Warning'].forEach(cat => {
        if (counts[cat]) {
          const id = 'cat-' + cat.toLowerCase();
          const wrapper = document.createElement('div');
          wrapper.className = 'category-item';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = id;
          checkbox.value = cat;
          checkbox.checked = true;
          checkbox.addEventListener('change', updateFilteredData);
          const label = document.createElement('label');
          label.htmlFor = id;
          label.textContent = cat;
          wrapper.appendChild(checkbox);
          wrapper.appendChild(label);
          categoryFiltersDiv.appendChild(wrapper);
        }
      });
      // أنشئ خيار "Other" إذا كان هناك عناصر غير مصنفة
      if (counts['__OTHER__']) {
        const otherWrapper = document.createElement('div');
        otherWrapper.className = 'category-item';
        const otherCheckbox = document.createElement('input');
        otherCheckbox.type = 'checkbox';
        otherCheckbox.id = 'cat-other';
        otherCheckbox.value = '__OTHER__';
        otherCheckbox.checked = true;
        otherCheckbox.addEventListener('change', updateFilteredData);
        const otherLabel = document.createElement('label');
        otherLabel.htmlFor = 'cat-other';
        otherLabel.textContent = 'Other';
        otherWrapper.appendChild(otherCheckbox);
        otherWrapper.appendChild(otherLabel);
        categoryFiltersDiv.appendChild(otherWrapper);
      }
    }

    // إنشاء قائمة الإنذارات
    function buildEventList(list) {
  const arr = list || events;
  eventListDiv.innerHTML = '';

  if (arr.length > 0) {
    const allBtn = document.createElement('div');
    allBtn.className = 'event-item' + (isAllSelected() ? ' selected' : '');
    allBtn.textContent = 'ALL';
    allBtn.title = 'ALL';
    allBtn.addEventListener('click', () => {
      selectedEvents = new Set(['__ALL__']);
      if (eventSearchInput) eventSearchInput.value = '';
      searchTerm = '';
      filterEventList();
      updateEventSelection();
      updateTable();
      updateAnalysis();
    });
    eventListDiv.appendChild(allBtn);
  }

  arr.forEach(ev => {
    const btn = document.createElement('div');
    btn.className = 'event-item' + (selectedEvents.has(ev) ? ' selected' : '');
    btn.textContent = ev;
    btn.title = ev;
    btn.addEventListener('click', () => {
      if (selectedEvents.has('__ALL__')) selectedEvents.delete('__ALL__');
      if (selectedEvents.has(ev)) {
        selectedEvents.delete(ev);
      } else {
        selectedEvents.add(ev);
      }
      if (selectedEvents.size === 0) selectedEvents.add('__ALL__');
      updateEventSelection();
      updateTable();
      updateAnalysis();
    });
    eventListDiv.appendChild(btn);
  });
}

    // تحديث تحديد الإنذار في القائمة
    function updateEventSelection() {
  const items = eventListDiv.querySelectorAll('.event-item');
  items.forEach(item => {
    const name = item.textContent;
    const isSel = (name === 'ALL' && isAllSelected()) || selectedEvents.has(name);
    item.classList.toggle('selected', isSel);
  });
}

    // تصفية قائمة الإنذارات بناءً على مصطلح البحث
    function filterEventList() {
  if (searchTerm) {
    searchedEvents = events.filter(ev => ev.toLowerCase().includes(searchTerm));
  } else {
    searchedEvents = events.slice();
  }
  const kept = new Set();
  selectedEvents.forEach(n => {
    if (n === '__ALL__' || events.includes(n)) kept.add(n);
  });
  selectedEvents = kept.size ? kept : new Set(['__ALL__']);
  buildEventList(searchedEvents);
  updateTable();
}

    // حدث البحث
    eventSearchInput.addEventListener('input', () => {
      searchTerm = eventSearchInput.value.trim().toLowerCase();
      filterEventList();
    });

    // تحديث البيانات المفلترة وفق الفلاتر
    function updateFilteredData() {
      if (!dataset.length) return;
      hideMessage();
      // تصفية حسب الفئة
      const checkedCats = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'))
        .filter(cb => cb.checked)
        .map(cb => cb.value);
      // نطاق زمني
      const sd = startDateInput.value;
      const ed = endDateInput.value;
      const st = startTimeInput.value;
      const et = endTimeInput.value;
      let startFilter = null;
      let endFilter = null;
      if (sd) {
        startFilter = parseDateTime(sd, st || '00:00');
      }
      if (ed) {
        endFilter = parseDateTime(ed, et || '23:59');
      }
      // خزّن نطاق Date/الوقت الحاليين للاستخدام في حساب الإنذارات الفردية
      globalStartFilter = startFilter;
      globalEndFilter = endFilter;
      filteredData = dataset.filter(row => {
        // Category filtering: classify each row's category into Alarm, State, Warning, or Other
        let rawCat = row[colMap.category] || '';
        let trimmedCat = rawCat ? String(rawCat).trim() : '';
        // Check if a subevent/categorization exists; if yes, treat as 'Other'
        const hasSub = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
        let catKey;
        if (hasSub) {
          catKey = '__OTHER__';
        } else if (!trimmedCat || trimmedCat.toLowerCase() === 'unknown' || trimmedCat === 'غير معروف' || trimmedCat === 'بدون فئة') {
          catKey = '__OTHER__';
        } else {
          const lc = trimmedCat.toLowerCase();
          // Determine known categories; default to Other for anything else
          if (lc.includes('alarm') || trimmedCat === 'إنذار') {
            catKey = 'Alarm';
          } else if (lc.includes('state') || trimmedCat === 'حالة') {
            catKey = 'State';
          } else if (lc.includes('warning') || trimmedCat === 'تحذير') {
            catKey = 'Warning';
          } else {
            catKey = '__OTHER__';
          }
        }
        // Apply category filter: include if catKey is checked
        if (checkedCats.length && !checkedCats.includes(catKey)) return false;
        // Time range filter
        if (startFilter || endFilter) {
          const { startDate, endDate } = parseRowDate(row);
          if (startFilter && (!endDate || endDate < startFilter)) return false;
          if (endFilter && (!startDate || startDate > endFilter)) return false;
        }
        
// Device/Turbine filter
if (deviceFilterTerm) {
  const rawDev = row[colMap.device] || '';
  const devStr = String(rawDev).trim().toLowerCase();
  // مطابقة مرنة: إما احتواء مباشر، أو مطابقة على الأرقام فقط (WTG-05 ~ 5)
  const devDigits = devStr.replace(/\D/g, '');
  const filterDigits = deviceFilterTerm.replace(/\D/g, '');
  const containsText = devStr.includes(deviceFilterTerm);
  const containsDigits = filterDigits ? devDigits.includes(filterDigits) : true;
  if (!(containsText || containsDigits)) return false;
}
return true;
      });
      // جلب الإنذارات الفريدة مع تجاهل القيم غير المعروفة
      const evSet = new Set();
      filteredData.forEach(row => {
        // استخدم اسم الإنذار الأساسي أو الفرعي إذا كان الأساسي فارغًا
        let rawName = '';
        if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
          rawName = row[colMap.event];
        } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
          rawName = row[colMap.subevent];
        }
        const name = (rawName || '').trim();
        // استبعد الأسماء الفارغة أو "غير معروف" أو "unknown" (بعد إزالة الفراغات)
        if (!name || name === 'غير معروف' || name.toLowerCase() === 'unknown') {
          return;
        }
        evSet.add(name);
      });
      events = Array.from(evSet).sort((a,b) => a.localeCompare(b, 'ar'));
const intersection = new Set();
selectedEvents.forEach(n => { if (n === '__ALL__' || evSet.has(n)) intersection.add(n); });
selectedEvents = intersection.size ? intersection : new Set(['__ALL__']);
 // sort alphabetically
      // إذا لم يكن الإنذار المختار ضمن القائمة الحالية اختر أول عنصر
      // إلا إذا كان الاختيار هو كل الأحداث (__ALL__)،
      // ففي هذه الحالة نحتفظ به حتى يتمكن المستخدم من رؤية جميع الإنذارات.
      if (!isAllSelected()) {
        if (!Array.from(selectedEvents)[0] || !evSet.has(Array.from(selectedEvents)[0])) {
          Array.from(selectedEvents)[0] = events.length ? events[0] : null;
        }
      }
      // بعد تحديث قائمة الإنذارات والأحداث المفلترة، طبّق البحث الحالي لتصفية القائمة إن وجد
      filterEventList();
      // حدّث التحليل لأعلى التوربينات
      updateAnalysis();
    }

    // حساب وتجهيز البيانات الخاصة بإنذار واحد وعرضها في الجدول
    function updateTable() {
  tableContainer.innerHTML = '';
  /* reveal export buttons once a table is present */
  try { exportBtn.style.display=''; exportExcelBtn.style.display=''; exportPdfBtn.style.display=''; } catch(_) {}

  exportBtn.style.display = 'none';
  exportExcelBtn.style.display = 'none';
  /* keep hidden until data is ready */

  if (!events.length) {
    selectedEventTitle.textContent = '';
    return;
  }
  selectedEventTitle.textContent = 'Alarm: ' + currentAlarmLabel() + (deviceFilterTerm ? ('  |  Turbine: ' + (deviceFilterInput ? deviceFilterInput.value : deviceFilterTerm)) : '');

  const rows = [];

  function rowTypeOf(row) {
    const hasSub = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
    if (hasSub) return 'Other';
    const cat = (row[colMap.category] || '').toString().toLowerCase();
    if (cat.includes('alarm') || row[colMap.category] === 'إنذار') return 'Alarm';
    if (cat.includes('state') || row[colMap.category] === 'حالة') return 'State';
    if (cat.includes('warning') || row[colMap.category] === 'تحذير') return 'Warning';
    return 'Other';
  }
  function getEventName(row) {
    if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') return row[colMap.event].trim();
    if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') return row[colMap.subevent].trim();
    return '';
  }
  function getDur(row) {
    // لو يوجد Start/End قصّ Total Duration داخل مجال الفلترة
    if (colMap.start && colMap.end) {
      const { startDate, endDate } = parseRowDate(row);
      if (startDate && endDate) {
        if (globalStartFilter || globalEndFilter) {
          return overlapSeconds(startDate, endDate, globalStartFilter, globalEndFilter);
        }
        return (endDate.getTime() - startDate.getTime()) / 1000;
      }
    }
    // وإلا لو يوجد Duration فقط ولا يمكن القصّ، استخدمه كما هو
    if (colMap.duration && row[colMap.duration]) return parseDuration(row[colMap.duration]);
    return 0;
  }

  const multiMode = !isAllSelected() && selectedEvents.size > 1;

  if (isAllSelected() || multiMode) {
    let useData = filteredData;
    (function decideSource() {
      const cbs = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'));
      const allCats = cbs.length > 0 && cbs.every(cb => cb.checked);
      if (allCats && !globalStartFilter && !globalEndFilter && !deviceFilterTerm) useData = dataset;
    })();

    const group = {};
    useData.forEach(row => {
      const evName = getEventName(row);
      if (!evName) return;
      if (!isAllSelected() && !selectedEvents.has(evName)) return;

      const rawDev = row[colMap.device];
      if (!rawDev) return;
      const dev = String(rawDev).trim();
      if (!dev || dev.toLowerCase() === 'unknown' || dev === 'غير معروف') return;

      const key = evName + '___' + dev;
      if (!group[key]) group[key] = { event: evName, device: dev, count: 0, duration: 0, earliest: null, latest: null, typeCounts: {} };
      const g = group[key];
      g.count++;
      g.duration += getDur(row);

      const t = rowTypeOf(row);
      g.typeCounts[t] = (g.typeCounts[t] || 0) + 1;

      const { startDate, endDate } = parseRowDate(row);
if (startDate && endDate) {
  let cs = startDate, ce = endDate;
  if (globalStartFilter || globalEndFilter) {
    const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
    cs = clip.cs; ce = clip.ce;
  }
  if (cs && ce) {
    if (!g.earliest || cs < g.earliest) g.earliest = cs;
    if (!g.latest || ce > g.latest) g.latest = ce;
  }
}

    });

    Object.values(group).forEach(s => {
      let chosenType = '';
      let maxT = 0;
      for (const t in s.typeCounts) if (s.typeCounts[t] > maxT) { maxT = s.typeCounts[t]; chosenType = t; }
      let dateVal = s.earliest
        ? (s.latest && s.earliest.toDateString() !== s.latest.toDateString() ? [s.earliest, s.latest] : s.earliest)
        : null;
      rows.push({ event: s.event, date: dateVal, type: chosenType, device: s.device, count: s.count, duration: s.duration });
    });

  } else {
    const only = Array.from(selectedEvents)[0];
    const counts = {};
    const earliest = {};
    const latest = {};
    let eventType = '';

    let useDataSel = filteredData;
      (function decideSourceSel(){
        const cbs = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'));
        const allCats = cbs.length > 0 && cbs.every(cb => cb.checked);
        if (allCats && !globalStartFilter && !globalEndFilter && !deviceFilterTerm) useDataSel = dataset;
      })();
      useDataSel.forEach(row => {
      const evName = getEventName(row);
      if (evName !== only) return;

      if (globalStartFilter || globalEndFilter) {
        const { startDate, endDate } = parseRowDate(row);
        if (globalStartFilter && (!endDate || endDate < globalStartFilter)) return;
        if (globalEndFilter && (!startDate || startDate > globalEndFilter)) return;
      }

      // enforce turbine filter when a term is present
      if (deviceFilterTerm) {
        const rawDev = row[colMap.device] || '';
        const devStr = String(rawDev).trim().toLowerCase();
        const devDigits = devStr.replace(/\D/g, '');
        const filterDigits = deviceFilterTerm.replace(/\D/g, '');
        const containsText = devStr.includes(deviceFilterTerm);
        const containsDigits = filterDigits ? devDigits.includes(filterDigits) : true;
        if (!(containsText || containsDigits)) return;
      }

      const rawDev = row[colMap.device];
      if (!rawDev) return;
      const dev = String(rawDev).trim();
      if (!dev || dev.toLowerCase() === 'unknown' || dev === 'غير معروف') return;

      if (!counts[dev]) counts[dev] = { count: 0, duration: 0 };
      counts[dev].count++;
      counts[dev].duration += getDur(row);

      const t = rowTypeOf(row);
      if (!eventType) eventType = t;

      const { startDate, endDate } = parseRowDate(row);
if (startDate && endDate) {
  let cs = startDate, ce = endDate;
  if (globalStartFilter || globalEndFilter) {
    const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
    cs = clip.cs; ce = clip.ce;
  }
  if (cs && ce) {
    if (!earliest[dev] || cs < earliest[dev]) earliest[dev] = cs;
    if (!latest[dev] || ce > latest[dev]) latest[dev] = ce;
  }
}

    });

    Object.keys(counts).forEach(dev => {
      const e = earliest[dev] || null;
      const l = latest[dev] || null;
      const dateVal = e ? (l && e.toDateString() !== l.toDateString() ? [e, l] : e) : null;
      rows.push({ event: only, date: dateVal, type: eventType, device: dev, count: counts[dev].count, duration: counts[dev].duration });
    });
  }

  if (currentSort.key) {
    rows.sort((a,b) => compareBy(a,b,currentSort.key));
} else {
    rows.sort((a,b) => (b.count - a.count) || (b.duration - a.duration));
}

  if (!rows.length) {
    const info = document.createElement('p');
    info.textContent = 'No records match the filters.';
    tableContainer.appendChild(info);
    return;
  }

  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  
['Alarm Name','Type','Date','Turbine','Occurrences','Total Duration','Details'].forEach((text, idx) => {
    const th = document.createElement('th'); 
    th.textContent = text; 
    // Sortable headers: Date (idx 2), Turbine (idx 3), Occurrences (idx 4), Total Duration (idx 5)
    const keysByIdx = {2:'date', 3:'device', 4:'count', 5:'duration'};
    if (keysByIdx[idx]) {
      th.style.cursor = 'pointer';
      th.classList.add('sortable-th');
      const arrow = document.createElement('span');
      arrow.style.marginLeft = '6px';
      const key = keysByIdx[idx];
      if (currentSort.key === key) {
        arrow.textContent = currentSort.dir === 'asc' ? '▲' : '▼';
        arrow.style.opacity = '1';
      } else {
        arrow.textContent = '▼';
        arrow.style.opacity = '0.35';
      }
      th.appendChild(arrow);
      th.addEventListener('click', () => { toggleSort(key); });
    }
    trh.appendChild(th);
  });thead.appendChild(trh); table.appendChild(thead);

  const tbody = document.createElement('tbody');
  rows.forEach(r => {
    const tr = document.createElement('tr');
    const tdEvent = document.createElement('td'); tdEvent.textContent = r.event;
    const tdType  = document.createElement('td'); tdType.textContent  = r.type || '';
    const tdDate  = document.createElement('td');
    if (Array.isArray(r.date)) tdDate.textContent = formatDateShort(r.date[0]) + ' - ' + formatDateShort(r.date[1]);
    else tdDate.textContent = r.date ? formatDateShort(r.date) : '';
    const tdDev   = document.createElement('td'); tdDev.textContent   = r.device;
    const tdCnt   = document.createElement('td'); tdCnt.textContent   = r.count;
    const tdDur   = document.createElement('td'); tdDur.textContent   = formatDuration(r.duration);
    
const tdMore  = document.createElement('td');
const btnMore = document.createElement('button');
btnMore.textContent = 'Details';
btnMore.className = 'btn btn-details';
btnMore.addEventListener('click', () => {
  try { window.openAlarmDetails && window.openAlarmDetails(r.event, r.device); } catch (_) {}
});
tdMore.appendChild(btnMore);
tr.append(tdEvent, tdType, tdDate, tdDev, tdCnt, tdDur, tdMore);
tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  tableContainer.appendChild(table);
      try{ window.__ensureAllExportButtons && window.__ensureAllExportButtons(); window.__bindDomExportsAll && window.__bindDomExportsAll(); }catch(_){}
      try{ window.__bindDomTableExports && window.__bindDomTableExports(); }catch(_){}
      try{ window.__ensurePdfButton && window.__ensurePdfButton(); window.__bindPdfExport && window.__bindPdfExport(); }catch(_){}
      try{ window.__ensurePdfButton && window.__ensurePdfButton(); }catch(_){}

  exportBtn.style.display = 'inline-block';
  exportExcelBtn.style.display = 'inline-block';
  exportPdfBtn.style.display = 'inline-block';
}

    // تصدير الجدول الحالي إلى ملف CSV
    function exportCurrentTable() {
      if (!Array.from(selectedEvents)[0]) return;
      const lines = [];
      // CSV header includes event type and date columns
      lines.push(['Event','Type','Date','Device','Count','Duration'].join(','));
      const counts = {};
      const typeCountsPerDevice = {};
      const earliestDates = {};
      const latestDates = {};
      const eventCountsPerDevice = {};
      // اختر مصدر البيانات حسب الاختيار: إذا كان "الكل" استخدم البيانات المفلترة، وإذا كان إنذارًا محددًا استخدم مجموعة البيانات كاملة
      const dataForExport = (isAllSelected() || deviceFilterTerm) ? filteredData : dataset;
      dataForExport.forEach(row => {
        // استخدم اسم الإنذار الأساسي أو الفرعي
        let evName = '';
        if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
          evName = row[colMap.event];
        } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
          evName = row[colMap.subevent];
        }
        // عند اختيار إنذار محدد، تجاهل الصفوف التي لا تتطابق معه
        if (!isAllSelected() && evName !== Array.from(selectedEvents)[0]) return;
        // عند اختيار إنذار محدد، طبّق فلتر الوقت المخزن
        if (!isAllSelected()) {
          if (globalStartFilter || globalEndFilter) {
            const { startDate, endDate } = parseRowDate(row);
            if (globalStartFilter && (!endDate || endDate < globalStartFilter)) return;
            if (globalEndFilter && (!startDate || startDate > globalEndFilter)) return;
          }
        }
        const rawDev = row[colMap.device];
        if (!rawDev) return;
        const trimmedDev = String(rawDev).trim();
        if (!trimmedDev || trimmedDev === 'غير معروف' || trimmedDev.toLowerCase() === 'unknown') return;
        const dev = trimmedDev;
        if (!counts[dev]) counts[dev] = { count: 0, duration: 0 };
        counts[dev].count++;
        if (colMap.start && colMap.end) {
          const { startDate, endDate } = parseRowDate(row);
          if (startDate && endDate) {
            const dur = (globalStartFilter || globalEndFilter) ? overlapSeconds(startDate, endDate, globalStartFilter, globalEndFilter) : (endDate.getTime() - startDate.getTime()) / 1000;
            counts[dev].duration += dur;
          }
        } else if (colMap.duration && row[colMap.duration]) {
          // لا يمكن قصّها لعدم وجود تواريخ واضحة
          counts[dev].duration += parseDuration(row[colMap.duration]);
        }
        // تحديد نوع الصف
        let rowType = '';
        const hasSubEvent = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
        if (hasSubEvent) {
          rowType = 'Other';
        } else {
          let cat = row[colMap.category] || '';
          let lcCat = cat ? cat.toString().toLowerCase() : '';
          if (lcCat.includes('alarm') || cat === 'إنذار') {
            rowType = 'Alarm';
          } else if (lcCat.includes('state') || cat === 'حالة') {
            rowType = 'State';
          } else if (lcCat.includes('warning') || cat === 'تحذير') {
            rowType = 'Warning';
          } else {
            rowType = 'Other';
          }
        }
        if (rowType) {
          if (!typeCountsPerDevice[dev]) typeCountsPerDevice[dev] = {};
          typeCountsPerDevice[dev][rowType] = (typeCountsPerDevice[dev][rowType] || 0) + 1;
        }
        // تتبع أقدم وأحدث تواريخ بعد القصّ داخل مجال الفلترة
        const { startDate, endDate } = parseRowDate(row);
        if (startDate && endDate) {
          let cs = startDate, ce = endDate;
          if (globalStartFilter || globalEndFilter) {
            const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
            cs = clip.cs; ce = clip.ce;
          }
          if (cs && ce) {
            if (!earliestDates[dev] || cs < earliestDates[dev]) {
              earliestDates[dev] = cs;
            }
            if (!latestDates[dev] || ce > latestDates[dev]) {
              latestDates[dev] = ce;
            }
          }
        }

        // عدّ كل إنذار لكل توربينة عند التصدير لـ "الكل"
        if (isAllSelected()) {
          let evName2 = '';
          if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
            evName2 = row[colMap.event];
          } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
            evName2 = row[colMap.subevent];
          }
          if (!eventCountsPerDevice[dev]) eventCountsPerDevice[dev] = {};
          eventCountsPerDevice[dev][evName2] = (eventCountsPerDevice[dev][evName2] || 0) + 1;
        }
      });
      // Determine eventType for specific selection
      let eventType = '';
      if (!isAllSelected()) {
        const dataForType = dataset;
        for (const row of dataForType) {
          // Apply time filter if present
          if (globalStartFilter || globalEndFilter) {
            const { startDate, endDate } = parseRowDate(row);
            if (globalStartFilter && (!endDate || endDate < globalStartFilter)) continue;
            if (globalEndFilter && (!startDate || startDate > globalEndFilter)) continue;
          }
          let evName = '';
          if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
            evName = row[colMap.event];
          } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
            evName = row[colMap.subevent];
          }
          if (evName === Array.from(selectedEvents)[0]) {
            const hasSubEvt = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
            if (hasSubEvt) {
              eventType = 'Other';
            } else {
              let cat = row[colMap.category] || '';
              let lcCat = cat ? cat.toString().toLowerCase() : '';
              if (lcCat.includes('alarm') || cat === 'إنذار') {
                eventType = 'Alarm';
              } else if (lcCat.includes('state') || cat === 'حالة') {
                eventType = 'State';
              } else if (lcCat.includes('warning') || cat === 'تحذير') {
                eventType = 'Warning';
              } else {
                eventType = 'Other';
              }
            }
            break;
          }
        }
      }
      // Build lines: إذا كان الاختيار "الكل"، تجميع حسب اسم الإنذار، وإلا تجميع حسب التوربينة
      if (isAllSelected()) {
        // تجميع حسب الإنذار والتوربينة
        const groupStats = {};
        // حدد مجموعة البيانات للتصدير: إذا كانت كل الفئات محددة ولا يوجد فلتر زمني، استخدم dataset
        let useData;
        (function determineExportData() {
          const catCheckboxes = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'));
          const allCatsChecked = catCheckboxes.length > 0 && catCheckboxes.every(cb => cb.checked);
          if (allCatsChecked && !globalStartFilter && !globalEndFilter) {
            useData = dataset;
          } else {
            useData = filteredData;
          }
        })();
        useData.forEach(row => {
          // event name
          let evName = '';
          if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
            evName = row[colMap.event];
          } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
            evName = row[colMap.subevent];
          }
          if (!evName) return;
          const name = evName.trim();
          if (!name || name.toLowerCase() === 'unknown' || name === 'غير معروف') return;
          // device name
          const rawDev = row[colMap.device];
          if (!rawDev) return;
          const trimmedDev = String(rawDev).trim();
          if (!trimmedDev || trimmedDev === 'غير معروف' || trimmedDev.toLowerCase() === 'unknown') return;
          const key = name + '___' + trimmedDev;
          if (!groupStats[key]) {
            groupStats[key] = { event: name, device: trimmedDev, count: 0, duration: 0, earliest: null, latest: null, typeCounts: {} };
          }
          const stat = groupStats[key];
          stat.count++;
          // duration
          if (colMap.duration && row[colMap.duration]) {
            stat.duration += parseDuration(row[colMap.duration]);
          } else if (colMap.start && colMap.end) {
            const { startDate, endDate } = parseRowDate(row);
            if (startDate && endDate) {
              const dur = (globalStartFilter || globalEndFilter) ? overlapSeconds(startDate, endDate, globalStartFilter, globalEndFilter) : (endDate.getTime() - startDate.getTime()) / 1000;
              stat.duration += dur;
            }
          }
          // type classification
          let rowType = '';
          const hasSubEvent = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
          if (hasSubEvent) {
            rowType = 'Other';
          } else {
            let cat = row[colMap.category] || '';
            let lc = cat ? cat.toString().toLowerCase() : '';
            if (lc.includes('alarm') || cat === 'إنذار') {
              rowType = 'Alarm';
            } else if (lc.includes('state') || cat === 'حالة') {
              rowType = 'State';
            } else if (lc.includes('warning') || cat === 'تحذير') {
              rowType = 'Warning';
            } else {
              rowType = 'Other';
            }
          }
          stat.typeCounts[rowType] = (stat.typeCounts[rowType] || 0) + 1;
          // dates
          const { startDate, endDate } = parseRowDate(row);
          if (startDate && endDate) {
            let cs = startDate, ce = endDate;
            if (globalStartFilter || globalEndFilter) {
              const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
              cs = clip.cs; ce = clip.ce;
            }
            if (cs && ce) {
              if (!stat.earliest || cs < stat.earliest) stat.earliest = cs;
              if (!stat.latest || ce > stat.latest) stat.latest = ce;
            }
          }
        });
        Object.keys(groupStats).forEach(k => {
          const s = groupStats[k];
          // choose most frequent type
          let chosenType = '';
          let maxT = 0;
          for (const t in s.typeCounts) {
            if (s.typeCounts[t] > maxT) {
              maxT = s.typeCounts[t];
              chosenType = t;
            }
          }
          let dateVal = '';
          const e = s.earliest;
          const l = s.latest;
          if (e && l && e instanceof Date && l instanceof Date && e.toDateString() !== l.toDateString()) {
            dateVal = formatDateShort(e) + ' - ' + formatDateShort(l);
          } else if (e) {
            dateVal = formatDateShort(e);
          }
          const dur = formatDuration(s.duration);
          lines.push([s.event, chosenType, dateVal, s.device, s.count, dur].join(','));
        });
      } else {
        // تجميع حسب التوربينة لإنذار محدد
        Object.keys(counts).forEach(dev => {
          const obj = counts[dev];
          const dur = formatDuration(obj.duration);
          let type = eventType || '';
          let dateVal = '';
          const e = earliestDates[dev];
          const l = latestDates[dev];
          if (e && l && e instanceof Date && l instanceof Date && e.toDateString() !== l.toDateString()) {
            dateVal = formatDateShort(e) + ' - ' + formatDateShort(l);
          } else if (e) {
            dateVal = formatDateShort(e);
          }
          lines.push([Array.from(selectedEvents)[0], type, dateVal, dev, obj.count, dur].join(','));
        });
      }
      const csvContent = lines.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      const sheetName = (isAllSelected() ? 'All' : (selectedEvents.size === 1 ? Array.from(selectedEvents)[0] : ('Multiple_' + selectedEvents.size))).replace(/[\/:*?"<>|]+/g, '_');
      link.download = 'alarm_' + sheetName + '.csv';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    /*
     * التحليل والتصدير الإضافي
     */

    // تحميل مكتبة jsPDF و html2canvas عند الحاجة
    function loadPDFLib() {
      return new Promise((resolve, reject) => {
        if (window.jspdf && window.html2canvas) {
          resolve();
          return;
        }
        let loaded = 0;
        function done() {
          loaded++;
          if (loaded === 2) resolve();
        }
        function fail() {
          reject();
        }
        const script1 = document.createElement('script');
        script1.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
        script1.onload = done;
        script1.onerror = fail;
        document.head.appendChild(script1);
        const script2 = document.createElement('script');
        script2.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        script2.onload = done;
        script2.onerror = fail;
        document.head.appendChild(script2);
      });
    }

    // تحميل Chart.js عند الحاجة
    function loadChartJS() {
      return new Promise((resolve, reject) => {
        if (window.Chart) {
          resolve();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
        script.onload = () => resolve();
        script.onerror = () => reject();
        document.head.appendChild(script);
      });
    }

    // تصدير الجدول الحالي إلى Excel
    function exportCurrentTableExcel() {
      if (!Array.from(selectedEvents)[0]) return;
      loadXLSX().then(() => {
        // Include event type and date columns in the Excel export
        const headerRow = ['Event','Type','Date','Device','Count','Duration'];
        const dataRows = [];
        const counts = {};
        // Determine the type/category of the selected event
        let eventType = '';
        if (!isAllSelected()) {
          // Scan the entire dataset (with time filter) to determine the first matching row's type
          for (const row of dataset) {
            // Apply time filter
            if (globalStartFilter || globalEndFilter) {
              const { startDate, endDate } = parseRowDate(row);
              if (globalStartFilter && (!endDate || endDate < globalStartFilter)) continue;
              if (globalEndFilter && (!startDate || startDate > globalEndFilter)) continue;
            }
            let evName = '';
            if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
              evName = row[colMap.event];
            } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
              evName = row[colMap.subevent];
            }
            if (evName === Array.from(selectedEvents)[0]) {
              if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
                eventType = 'Other';
              } else {
                let catVal = row[colMap.category] || '';
                let lcVal = catVal ? catVal.toString().toLowerCase() : '';
                if (lcVal.includes('alarm') || catVal === 'إنذار') {
                  eventType = 'Alarm';
                } else if (lcVal.includes('state') || catVal === 'حالة') {
                  eventType = 'State';
                } else if (lcVal.includes('warning') || catVal === 'تحذير') {
                  eventType = 'Warning';
                } else {
                  eventType = 'Other';
                }
              }
              break;
            }
          }
        }
        const earliestDates = {};
        const latestDates = {};
        const typeCountsPerDevice = {};
        const eventCountsPerDevice = {};
        // اختر مصدر البيانات: إذا كان "الكل" استخدم البيانات المفلترة، وإلا استخدم مجموعة البيانات كاملة
        const dataForExportExcel = (isAllSelected()) ? filteredData : dataset;
        dataForExportExcel.forEach(row => {
          let evName = '';
          if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
            evName = row[colMap.event];
          } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
            evName = row[colMap.subevent];
          }
          if (!isAllSelected() && evName !== Array.from(selectedEvents)[0]) return;
          // Apply time filter for specific event
          if (!isAllSelected()) {
            if (globalStartFilter || globalEndFilter) {
              const { startDate, endDate } = parseRowDate(row);
              if (globalStartFilter && (!endDate || endDate < globalStartFilter)) return;
              if (globalEndFilter && (!startDate || startDate > globalEndFilter)) return;
            }
          }
          const rawDev = row[colMap.device];
          if (!rawDev) return;
          const trimmedDev = String(rawDev).trim();
          if (!trimmedDev || trimmedDev === 'غير معروف' || trimmedDev.toLowerCase() === 'unknown') return;
          const dev = trimmedDev;
          if (!counts[dev]) counts[dev] = { count: 0, duration: 0 };
          counts[dev].count++;
          if (colMap.duration && row[colMap.duration]) {
            counts[dev].duration += parseDuration(row[colMap.duration]);
          } else if (colMap.start && colMap.end) {
            const { startDate, endDate } = parseRowDate(row);
            if (startDate && endDate) counts[dev].duration += (endDate.getTime() - startDate.getTime()) / 1000;
          }
          // classify this row for type and count event occurrences when exporting all
          let rowType = '';
          const hasSubEvent = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
          if (hasSubEvent) {
            rowType = 'Other';
          } else {
            let catVal = row[colMap.category] || '';
            let lcVal = catVal ? catVal.toString().toLowerCase() : '';
            if (lcVal.includes('alarm') || catVal === 'إنذار') {
              rowType = 'Alarm';
            } else if (lcVal.includes('state') || catVal === 'حالة') {
              rowType = 'State';
            } else if (lcVal.includes('warning') || catVal === 'تحذير') {
              rowType = 'Warning';
            } else {
              rowType = 'Other';
            }
          }
          if (rowType) {
            if (!typeCountsPerDevice[dev]) typeCountsPerDevice[dev] = {};
            typeCountsPerDevice[dev][rowType] = (typeCountsPerDevice[dev][rowType] || 0) + 1;
          }
          // Count events per device when Array.from(selectedEvents)[0] is "All"
          if (isAllSelected()) {
            let evName2 = '';
            if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
              evName2 = row[colMap.event];
            } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
              evName2 = row[colMap.subevent];
            }
            if (!eventCountsPerDevice[dev]) eventCountsPerDevice[dev] = {};
            eventCountsPerDevice[dev][evName2] = (eventCountsPerDevice[dev][evName2] || 0) + 1;
          }
          // track earliest and latest dates
          const { startDate, endDate } = parseRowDate(row);
          if (startDate && endDate) {
  let cs = startDate, ce = endDate;
  if (globalStartFilter || globalEndFilter) {
    const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
    cs = clip.cs; ce = clip.ce;
  }
  if (cs && ce) {
    if (!earliestDates[dev] || cs < earliestDates[dev]) { earliestDates[dev] = cs; }
    if (!latestDates[dev] || ce > latestDates[dev]) { latestDates[dev] = ce; }
  }
}

        });
        if (isAllSelected()) {
          // تجميع حسب الإنذار والتوربينة
          const groupStats = {};
          // حدد مجموعة البيانات للتصدير: استخدم كامل البيانات إذا كانت كل الفئات محددة ولا يوجد فلتر زمني
          let useData;
          (function determineExportData() {
            const catCheckboxes = Array.from(categoryFiltersDiv.querySelectorAll('input[type="checkbox"]'));
            const allCatsChecked = catCheckboxes.length > 0 && catCheckboxes.every(cb => cb.checked);
            if (allCatsChecked && !globalStartFilter && !globalEndFilter) {
              useData = dataset;
            } else {
              useData = filteredData;
            }
          })();
          useData.forEach(row => {
            let evName = '';
            if (colMap.event && row[colMap.event] && row[colMap.event].trim() !== '') {
              evName = row[colMap.event];
            } else if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '') {
              evName = row[colMap.subevent];
            }
            if (!evName) return;
            const name = evName.trim();
            if (!name || name.toLowerCase() === 'unknown' || name === 'غير معروف') return;
            const rawDev = row[colMap.device];
            if (!rawDev) return;
            const trimmedDev = String(rawDev).trim();
            if (!trimmedDev || trimmedDev === 'غير معروف' || trimmedDev.toLowerCase() === 'unknown') return;
            const key = name + '___' + trimmedDev;
            if (!groupStats[key]) {
              groupStats[key] = { event: name, device: trimmedDev, count: 0, duration: 0, earliest: null, latest: null, typeCounts: {} };
            }
            const stat = groupStats[key];
            stat.count++;
            if (colMap.duration && row[colMap.duration]) {
              stat.duration += parseDuration(row[colMap.duration]);
            } else if (colMap.start && colMap.end) {
              const { startDate, endDate } = parseRowDate(row);
              if (startDate && endDate) stat.duration += (endDate.getTime() - startDate.getTime()) / 1000;
            }
            // classify type
            let rowType = '';
            const hasSubEvent = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
            if (hasSubEvent) {
              rowType = 'Other';
            } else {
              let catVal = row[colMap.category] || '';
              let lcVal = catVal ? catVal.toString().toLowerCase() : '';
              if (lcVal.includes('alarm') || catVal === 'إنذار') {
                rowType = 'Alarm';
              } else if (lcVal.includes('state') || catVal === 'حالة') {
                rowType = 'State';
              } else if (lcVal.includes('warning') || catVal === 'تحذير') {
                rowType = 'Warning';
              } else {
                rowType = 'Other';
              }
            }
            stat.typeCounts[rowType] = (stat.typeCounts[rowType] || 0) + 1;
// dates (clipped to filter window)
const { startDate, endDate } = parseRowDate(row);
if (startDate && endDate) {
  let cs = startDate, ce = endDate;
  if (globalStartFilter || globalEndFilter) {
    const clip = clippedDates(startDate, endDate, globalStartFilter, globalEndFilter);
    cs = clip.cs; ce = clip.ce;
  }
  if (cs && ce) {
    if (!stat.earliest || cs < stat.earliest) stat.earliest = cs;
    if (!stat.latest || ce > stat.latest) stat.latest = ce;
  }
}

          });
          Object.keys(groupStats).forEach(k => {
            const s = groupStats[k];
            let chosenType = '';
            let maxT = 0;
            for (const t in s.typeCounts) {
              if (s.typeCounts[t] > maxT) {
                maxT = s.typeCounts[t];
                chosenType = t;
              }
            }
            let dateVal = '';
            const e = s.earliest;
            const l = s.latest;
            if (e && l && e instanceof Date && l instanceof Date && e.toDateString() != l.toDateString()) {
              dateVal = formatDateShort(e) + ' - ' + formatDateShort(l);
            } else if (e) {
              dateVal = formatDateShort(e);
            }
            dataRows.push([s.event, chosenType, dateVal, s.device, s.count, formatDuration(s.duration)]);
          });
        } else {
          // تجميع حسب التوربينة لإنذار محدد
          Object.keys(counts).forEach(dev => {
            const obj = counts[dev];
            let typeForDev = eventType || '';
            let dateVal = '';
            const e = earliestDates[dev];
            const l = latestDates[dev];
            if (e && l && e instanceof Date && l instanceof Date && e.toDateString() !== l.toDateString()) {
              dateVal = formatDateShort(e) + ' - ' + formatDateShort(l);
            } else if (e) {
              dateVal = formatDateShort(e);
            }
            dataRows.push([Array.from(selectedEvents)[0], typeForDev, dateVal, dev, obj.count, formatDuration(obj.duration)]);
          });
        }
        if (!dataRows.length) return;
        const wsData = [headerRow, ...dataRows];
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        const wb = XLSX.utils.book_new();
        const sheetName = (isAllSelected() ? 'All' : (selectedEvents.size === 1 ? Array.from(selectedEvents)[0] : ('Multiple_' + selectedEvents.size))).replace(/[\/:*?"<>|]+/g, '_');
        XLSX.utils.book_append_sheet(wb, ws, sheetName);
        const fileName = 'alarm_' + sheetName + '.xlsx';
        XLSX.writeFile(wb, fileName);
      }).catch(() => {
        showMessage('Failed to load the Excel export library. Please connect to the internet');
      });
    }

    // تصدير الجدول الحالي إلى PDF
    function exportCurrentTablePDF() {
      if (!Array.from(selectedEvents)[0]) return;
      loadPDFLib().then(() => {
        // قم بتخزين القيم الأصلية للثيم قبل التعديل
        const root = document.documentElement;
        const oldBg = getComputedStyle(root).getPropertyValue('--bg-color');
        const oldSidebar = getComputedStyle(root).getPropertyValue('--sidebar-color');
        const oldAccent = getComputedStyle(root).getPropertyValue('--accent-color');
        const oldText = getComputedStyle(root).getPropertyValue('--text-color');
        const oldHighlight = getComputedStyle(root).getPropertyValue('--highlight-color');
        // غيّر الألوان مؤقتًا لتهيئة تصدير الـPDF بنص أسود وخلفية بيضاء
        root.style.setProperty('--bg-color', '#ffffff');
        root.style.setProperty('--sidebar-color', '#ffffff');
        root.style.setProperty('--accent-color', '#cccccc');
        root.style.setProperty('--highlight-color', '#dddddd');
        root.style.setProperty('--text-color', '#000000');
        // أنشئ عنصرًا مؤقتًا يضم عنوان الإنذار، الجدول، والرسم البياني
        const wrapper = document.createElement('div');
        wrapper.style.backgroundColor = '#ffffff';
        wrapper.style.color = '#000000';
        wrapper.style.padding = '16px';
        wrapper.style.fontSize = '14px';
        wrapper.style.lineHeight = '1.4';
        // أضف عنوان الإنذار
        const title = document.createElement('h2');
        title.style.marginBottom = '12px';
        title.textContent = selectedEventTitle.textContent;
        wrapper.appendChild(title);
        // نسخ الجدول الحالي
        const tableEl = tableContainer.querySelector('table');
        if (tableEl) {
          const tableClone = tableEl.cloneNode(true);
          // استبدل ألوان الخلفية للجدول بالعناصر الفاتحة
          tableClone.querySelectorAll('th').forEach(th => {
            th.style.backgroundColor = '#cccccc';
            th.style.color = '#000000';
          });
          tableClone.querySelectorAll('td').forEach(td => {
            td.style.backgroundColor = '#ffffff';
            td.style.color = '#000000';
          });
          tableClone.style.width = '100%';
          wrapper.appendChild(tableClone);
        }
        // إضافة الرسم البياني (إن وجد) كصورة أسفل الجدول
        if (analysisChart) {
          const chartImg = new Image();
          // استخدام toDataURL للحصول على صورة للرسم البياني الحالي
          chartImg.src = analysisChartCanvas.toDataURL('image/png');
          chartImg.style.display = 'block';
          chartImg.style.marginTop = '16px';
          chartImg.style.maxWidth = '100%';
          wrapper.appendChild(chartImg);
        }
        document.body.appendChild(wrapper);
        // استخدام html2canvas لالتقاط العنصر كاملاً بدقة أعلى
        window.html2canvas(wrapper, { scale: 2 }).then(canvas => {
          // إعادة القيم القديمة لخصائص الثيم
          root.style.setProperty('--bg-color', oldBg);
          root.style.setProperty('--sidebar-color', oldSidebar);
          root.style.setProperty('--accent-color', oldAccent);
          root.style.setProperty('--highlight-color', oldHighlight);
          root.style.setProperty('--text-color', oldText);
          // إزالة العنصر المؤقت من الصفحة
          wrapper.remove();
          const imgData = canvas.toDataURL('image/png');
          const { jsPDF } = window.jspdf;
          // استخدم الوضع الأفقي للحصول على عرض أكبر للجدول والرسم
          const pdf = new jsPDF('l', 'pt', 'a4');
          const pageWidth = pdf.internal.pageSize.getWidth();
          const imgWidth = pageWidth;
          const imgHeight = canvas.height * pageWidth / canvas.width;
          pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
          const sheetName = (isAllSelected() ? 'All' : (selectedEvents.size === 1 ? Array.from(selectedEvents)[0] : ('Multiple_' + selectedEvents.size))).replace(/[\/:*?"<>|]+/g, '_');
          const fileName = 'alarm_' + sheetName + '.pdf';
          pdf.save(fileName);
        });
      }).catch(() => {
        showMessage('Failed to load the PDF export library. Please connect to the internet');
      });
    }

    // تحديث قسم التحليل لأعلى التوربينات حسب إجمالي Total Duration
    
// original updateAnalysis moved to backend


    // تصدير قسم التحليل كصورة
    function exportAnalysisImage() {
      // Temporarily hide the analysis export buttons so they do not appear in the exported image
      const prevImgDisplay = analysisImgBtn.style.display;
      const prevPdfDisplay = analysisPdfBtn.style.display;
      analysisImgBtn.style.display = 'none';
      analysisPdfBtn.style.display = 'none';
      loadPDFLib().then(() => {
        window.html2canvas(analysisSection).then(canvas => {
          // Restore the buttons after capturing
          analysisImgBtn.style.display = prevImgDisplay;
          analysisPdfBtn.style.display = prevPdfDisplay;
          const link = document.createElement('a');
          link.download = 'analysis.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
        });
      }).catch(() => {
        // Restore the buttons in case of failure
        analysisImgBtn.style.display = prevImgDisplay;
        analysisPdfBtn.style.display = prevPdfDisplay;
        showMessage('Failed to load the libraries required to export the image. Please connect to the internet');
      });
    }

    // تصدير قسم التحليل كـ PDF
    function exportAnalysisPDF() {
      // Temporarily hide the analysis export buttons so they do not appear in the exported PDF
      const prevImgDisplay = analysisImgBtn.style.display;
      const prevPdfDisplay = analysisPdfBtn.style.display;
      analysisImgBtn.style.display = 'none';
      analysisPdfBtn.style.display = 'none';
      loadPDFLib().then(() => {
        // استخدم scale أعلى للحصول على جودة أفضل
        window.html2canvas(analysisSection, { scale: 2 }).then(canvas => {
          // Restore the buttons after capturing
          analysisImgBtn.style.display = prevImgDisplay;
          analysisPdfBtn.style.display = prevPdfDisplay;
          const imgData = canvas.toDataURL('image/png');
          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF('p', 'pt', 'a4');
          const pageWidth = pdf.internal.pageSize.getWidth();
          const imgWidth = pageWidth;
          const imgHeight = canvas.height * pageWidth / canvas.width;
          pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
          pdf.save('analysis.pdf');
        });
      }).catch(() => {
        // Restore the buttons in case of failure
        analysisImgBtn.style.display = prevImgDisplay;
        analysisPdfBtn.style.display = prevPdfDisplay;
        showMessage('Failed to load the libraries required to export the PDF. Please connect to the internet');
      });
    }

    // معالجة رفع الملف
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      hideMessage();
      dataset = [];
      header = [];
      colMap = {};
      filteredData = [];
      events = [];
      selectedEvents = new Set(['__ALL__']);
      tableContainer.innerHTML = '';
  /* reveal export buttons once a table is present */
  try { exportBtn.style.display=''; exportExcelBtn.style.display=''; exportPdfBtn.style.display=''; } catch(_) {}

      selectedEventTitle.textContent = 'Alarm: ' + currentAlarmLabel();
      exportBtn.style.display = 'none';
      const ext = file.name.split('.').pop().toLowerCase();
      // دالة مساعدة لتحليل البيانات بعد القراءة
      function handleParsedResult(parsed) {
        header = parsed.header;
        dataset = parsed.data;
        if (!dataset.length) {
          showMessage('لا توجد صفوف في الملف.');
          return;
        }
        detectColumns();
        if (!colMap.device || !colMap.event || !colMap.category) {
          showMessage('لم يتم العثور على الأعمدة الأساسية (الجهاز، الإنذار، الفئة) في الملف.');
          return;
        }
        filtersDiv.style.display = 'block';
        filteredData = dataset.slice();
        buildCategoryFilters();
        updateFilteredData();
      }
      if (ext === 'csv' || ext === 'txt') {
        const reader = new FileReader();
        reader.onload = function(evt) {
          const text = evt.target.result;
          const parsed = parseCSV(text);
          handleParsedResult(parsed);
        };
        reader.onerror = function() {
          showMessage('حدث خطأ أثناء قراءة الملف.');
        };
        reader.readAsText(file);
      } else if (ext === 'xls' || ext === 'xlsx') {
        // حاول تحميل مكتبة XLSX من الإنترنت
        showMessage('جارٍ تحميل مكتبة Excel من الإنترنت...');
        loadXLSX().then(() => {
          const reader = new FileReader();
          reader.onload = function(evt) {
            try {
              const data = new Uint8Array(evt.target.result);
              const workbook = XLSX.read(data, { type: 'array' });
              const sheetName = workbook.SheetNames[0];
              // حوّل أول شيت إلى CSV واستخدم المحلل نفسه
              const csv = XLSX.utils.sheet_to_csv(workbook.Sheets[sheetName], { FS: ',' });
              const parsed = parseCSV(csv);
              hideMessage();
              handleParsedResult(parsed);
            } catch (err) {
              showMessage('Failed to parse the Excel file. Please save the file as CSV or ensure the file is valid.');
            }
          };
          reader.onerror = function() {
            showMessage('حدث خطأ أثناء قراءة الملف.');
          };
          reader.readAsArrayBuffer(file);
        }).catch(() => {
          showMessage('Failed to load the Excel library from the internet. Please save the file as CSV or ensure you are connected to the internet.');
        });
      } else {
        showMessage('نوع ملف غير مدعوم.');
      }
    });

    // تحميل مكتبة XLSX من CDN عند الحاجة
    function loadXLSX() {
      return new Promise((resolve, reject) => {
        if (window.XLSX) {
          return resolve();
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
        script.onload = () => resolve();
        script.onerror = () => reject();
        document.head.appendChild(script);
      });
    }

    // أحداث الأزرار السريعة
    todayBtn.addEventListener('click', () => {
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const todayStr = yyyy + '-' + mm + '-' + dd;
      startDateInput.value = todayStr;
      endDateInput.value = todayStr;
      startTimeInput.value = '00:00';
      endTimeInput.value = '23:59';
      updateFilteredData();
    });
    yesterdayBtn.addEventListener('click', () => {
      const now = new Date();
      now.setDate(now.getDate() - 1);
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const yStr = yyyy + '-' + mm + '-' + dd;
      startDateInput.value = yStr;
      endDateInput.value = yStr;
      startTimeInput.value = '00:00';
      endTimeInput.value = '23:59';
      updateFilteredData();
    });
    last24Btn.addEventListener('click', () => {
      const now = new Date();
      const end = now;
      const start = new Date(now.getTime() - 24 * 3600 * 1000);
      const formatDate = (d) => {
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        return yyyy + '-' + mm + '-' + dd;
      };
      const formatTime = (d) => {
        const hh = String(d.getHours()).padStart(2, '0');
        const mn = String(d.getMinutes()).padStart(2, '0');
        return hh + ':' + mn;
      };
      startDateInput.value = formatDate(start);
      endDateInput.value = formatDate(end);
      startTimeInput.value = formatTime(start);
      endTimeInput.value = formatTime(end);
      updateFilteredData();
    });
    clearFilterBtn.addEventListener('click', () => {
      startDateInput.value = '';
      endDateInput.value = '';
      startTimeInput.value = '';
      endTimeInput.value = '';
      updateFilteredData();
    });

    // عند تغيير المدخلات الزمنية يدويًا
    startDateInput.addEventListener('change', updateFilteredData);
    endDateInput.addEventListener('change', updateFilteredData);
    startTimeInput.addEventListener('change', updateFilteredData);
    endTimeInput.addEventListener('change', updateFilteredData);

    // زر التصدير
    exportBtn.addEventListener('click', exportCurrentTable);

    // زر التصدير إلى Excel
    exportExcelBtn.addEventListener('click', exportCurrentTableExcel);
    // زر التصدير إلى PDF
    exportPdfBtn.addEventListener('click', exportCurrentTablePDF);

    // أزرار تصدير التحليل
    analysisImgBtn.addEventListener('click', exportAnalysisImage);
    analysisPdfBtn.addEventListener('click', exportAnalysisPDF);
  
// === Full table PDF export (print-friendly, multi-page, no external libs) ===
(function setupPrintPDF(){
  try {
    window.__ensurePdfButton && window.__ensurePdfButton();
    const original = document.getElementById('export-pdf-btn');
    if (!original) return;
    // Replace node to remove any existing event listeners (so it won't trigger twice)
    const btn = original.cloneNode(true);
    original.parentNode.replaceChild(btn, original);
    btn.style.display = ''; // ensure visible

    // No-op any legacy PDF export function if it exists
    try { window.exportCurrentTablePDF = function(){ /* overridden: single-print only */ }; } catch(_){}

    // Helper to build printable HTML (as before)
    function buildPrintableHTML(tableHtml) {
      const title = (document.getElementById('selected-event-title')?.textContent || 'Exported Table').trim();
      const styles = `
        <style>
          @page { size: A4 landscape; margin: 12mm; }
          html, body { font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; color: #0f172a; }
          h1 { font-size: 16px; margin: 0 0 8px 0; }
          .meta { font-size: 11px; color: #475569; margin: 0 0 10px 0; }
          table { width: 100%; border-collapse: collapse; table-layout: fixed; }
          thead { display: table-header-group; }
          tfoot { display: table-footer-group; }
          th, td { border: 1px solid #e5e7eb; padding: 6px 8px; vertical-align: top; word-break: break-word; }
          th { background: #0f172a; color: #fff; font-weight: 700; font-size: 12px; }
          td { font-size: 11px; }
          tr { page-break-inside: avoid; }
          .footer { font-size: 10px; color: #64748b; margin-top: 8px; }
        </style>`;
      const now = new Date();
      const meta = `Printed on: ${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
      return `<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />${styles}<title>${title}</title></head>
<body>
  <h1>${title}</h1>
  <div class="meta">${meta}</div>
  ${tableHtml}
  <div class="footer">Exported from AWS Analysis dashboard</div>
  <script>
    window.addEventListener('afterprint', () => window.close());
    window.addEventListener('load', () => setTimeout(() => window.print(), 100));
  <\/script>
</body>
</html>`;
    }

    function exportTableToPDF() {
      const table = document.querySelector('#table-container table');
      if (!table) { alert('No table to export yet.'); return; }
      const clone = table.cloneNode(true);
      clone.querySelectorAll('button, input, select, .no-print').forEach(el => el.remove());
      const wrapper = document.createElement('div');
      const t = document.createElement('table');
      t.innerHTML = clone.innerHTML;
      wrapper.appendChild(t);
      const docHtml = buildPrintableHTML(wrapper.innerHTML);
      const win = window.open('', '_blank');
      win.document.open();
      win.document.write(docHtml);
      win.document.close();
    }

    // Single handler (after replacing node there are no other listeners)
    btn.addEventListener('click', exportTableToPDF);
  } catch (e) {
    console.error('Failed to set up PDF export:', e);
  }
})();

// === Ensure Export PDF button exists & stays visible ===
(function ensurePdfButton(){
  function makeBtn(){
    const b = document.createElement('button');
    b.id = 'export-pdf-btn';
    b.textContent = 'Export table (PDF)';
    b.style.marginRight = '8px';
    return b;
  }
  function findContainer(){
    // Prefer the same row as CSV/Excel buttons
    const csv = document.getElementById('export-btn');
    const xls = document.getElementById('export-excel-btn');
    if (csv && csv.parentElement) return csv.parentElement;
    if (xls && xls.parentElement) return xls.parentElement;
    // fallback: append after table container
    return document.getElementById('table-container') || document.body;
  }
  function ensure(){
    let btn = document.getElementById('export-pdf-btn');
    if (!btn){
      const parent = findContainer();
      btn = makeBtn();
      parent && parent.appendChild(btn);
    }
    // Always force visible
    btn.removeAttribute('hidden');
    btn.style.display = '';
    btn.classList.remove('hidden');
  }
  document.addEventListener('DOMContentLoaded', ensure);
  // Also try after each render tick
  window.addEventListener('load', ensure);
  // Expose for manual calls (e.g., after updateTable)
  window.__ensurePdfButton = ensure;
})();


// === Strong ensure for Export PDF button (create+show+bind single handler) ===
(function ensurePdfButtonStrong(){
  function findButtonsContainer(){
    const csv = document.getElementById('export-btn');
    if (csv && csv.parentElement) return csv.parentElement;
    const wrap = document.querySelector('#table-container')?.parentElement || document.body;
    return wrap;
  }
  function ensureButton(){
    let btn = document.getElementById('export-pdf-btn');
    if (!btn){
      btn = document.createElement('button');
      btn.id = 'export-pdf-btn';
      btn.textContent = 'Export table (PDF)';
      findButtonsContainer().appendChild(btn);
    }
    // Force visible regardless of prior CSS
    btn.style.display = 'inline-block';
    btn.removeAttribute('hidden');
    btn.classList.remove('hidden');
    // A bit of spacing like the other buttons
    btn.style.marginLeft = '8px';
    btn.style.marginRight = '0';
    return btn;
  }
  window.__ensurePdfButton = ensureButton;
  document.addEventListener('DOMContentLoaded', ensureButton);
  window.addEventListener('load', ensureButton);
})();

// === Single-print PDF (table + chart) ===
(function setupPrintPDFOnce(){
  function buildPrintableHTML(tableHtml, chartDataUrl, metrics){
    const title = (document.getElementById('selected-event-title')?.textContent || 'Exported Table').trim();
    const styles = `
      <style>
        @page { size: A4 landscape; margin: 12mm; }
        html, body { font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial; color: #0f172a; }
        h1 { font-size: 16px; margin: 0 0 8px 0; }
        h2 { font-size: 14px; margin: 14px 0 8px 0; }
        .meta { font-size: 11px; color: #475569; margin: 0 0 10px 0; }
        table { width: 100%; border-collapse: collapse; table-layout: fixed; }
        thead { display: table-header-group; }
        tfoot { display: table-footer-group; }
        th, td { border: 1px solid #e5e7eb; padding: 6px 8px; vertical-align: top; word-break: break-word; }
        th { background: #0f172a; color: #fff; font-weight: 700; font-size: 12px; }
        td { font-size: 11px; }
        tr { page-break-inside: avoid; }
        .metrics { display:flex; flex-wrap:wrap; gap:10px; font-size: 11px; color:#334155; }
        .metric { padding: 2px 8px; border:1px solid #e5e7eb; border-radius: 999px; }
        .footer { font-size: 10px; color: #64748b; margin-top: 8px; }
        .chart-wrap { page-break-inside: avoid; margin-top: 8px; }
        .chart-wrap img { width: 100%; height: auto; }
      </style>`;
    const now = new Date();
    const meta = `Printed on: ${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')} ${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;

    const chartBlock = chartDataUrl ? `
      <h2>Analysis Chart</h2>
      <div class="metrics">
        ${metrics.alarm ? `<div class="metric">Alarm: <strong>${metrics.alarm}</strong></div>` : ''}
        ${metrics.count ? `<div class="metric">Occurrences: <strong>${metrics.count}</strong></div>` : ''}
        ${metrics.duration ? `<div class="metric">Total Duration: <strong>${metrics.duration}</strong></div>` : ''}
      </div>
      <div class="chart-wrap">
        <img alt="Analysis Chart" src="${chartDataUrl}"/>
      </div>` : '';

    return `<!DOCTYPE html>
<html>
<head><meta charset="utf-8" />${styles}<title>${title}</title></head>
<body>
  <h1>${title}</h1>
  <div class="meta">${meta}</div>
  ${tableHtml}
  ${chartBlock}
  <div class="footer">Exported from AWS Analysis dashboard</div>
  <script>
    window.addEventListener('afterprint', () => window.close());
    window.addEventListener('load', () => setTimeout(() => window.print(), 100));
  <\/script>
</body>
</html>`;
  }

  
// === Helper: build per-alarm details HTML (By Day + By Hour) ===
function __buildDetailsHTMLFor(eventName, deviceName){
  function pad(n){ return String(n).padStart(2,'0'); }
  function ymd(d){ return d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate()); }
  function dayName(d){
    try { return d.toLocaleDateString('en-US',{weekday:'long'}); }
    catch(_) { return ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][d.getDay()]; }
  }
  function hourRange(d){
    const h = pad(d.getHours()); const h2 = pad((d.getHours()+1)%24);
    return h+':00 – '+h2+':00';
  }
  function hm(d){ return pad(d.getHours())+':'+pad(d.getMinutes()); }
  function hm(d){ return pad(d.getHours())+':'+pad(d.getMinutes()); }
  function nextBoundary(d, by){
    const n = new Date(d);
    if (by==='day') n.setHours(24,0,0,0);
    else n.setHours(n.getHours()+1,0,0,0);
    return n;
  }
  function split(cs, ce, by){
    const segs=[]; let s=new Date(cs);
    while (s < ce){
      const bEnd = nextBoundary(s, by);
      const e = (ce < bEnd) ? ce : bEnd;
      segs.push({s, e, sec:(e - s)/1000});
      s = e;
    }
    return segs;
  }
  function getEventNameFromRow(row){
    if (colMap.event && row[colMap.event] && row[colMap.event].trim()!=='') return row[colMap.event].trim();
    if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim()!=='') return row[colMap.subevent].trim();
    return '';
  }
  function build(by){
    const buckets = {};
    const dataSrc = (typeof filteredData !== 'undefined' && filteredData && filteredData.length) ? filteredData : dataset;
    dataSrc.forEach(row=>{
      const ev = getEventNameFromRow(row); if (ev !== eventName) return;
      const rawDev = row[colMap.device]; if (!rawDev) return;
      const dev = String(rawDev).trim(); if (dev !== deviceName) return;
      const dObj = (typeof parseRowDate === 'function') ? parseRowDate(row) : {};
      const startDate = dObj && dObj.startDate; const endDate = dObj && dObj.endDate;
      if (!startDate || !endDate) return;
      const clip = (typeof clippedDates === 'function' && (globalStartFilter || globalEndFilter))
        ? clippedDates(startDate, endDate, globalStartFilter, globalEndFilter)
        : { cs: startDate, ce: endDate };
      const cs = clip.cs, ce = clip.ce; if (!cs || !ce) return;
      const startKey = (by==='day') ? ymd(cs) : (ymd(cs)+' '+pad(cs.getHours()));
      if (!buckets[startKey]) buckets[startKey] = { start: (by==='day'? new Date(cs.getFullYear(), cs.getMonth(), cs.getDate()) : new Date(cs.getFullYear(), cs.getMonth(), cs.getDate(), cs.getHours())), sec: 0, occ: 0, ranges: [] };
      buckets[startKey].occ += 1;
      split(cs, ce, by).forEach(p=>{
        const key = (by==='day') ? ymd(p.s) : (ymd(p.s)+' '+pad(p.s.getHours()));
        if (!buckets[key]) buckets[key] = { start: p.s, sec: 0, occ: 0, ranges: [] };
        buckets[key].sec += p.sec;
        if (by==='hour') { buckets[key].ranges.push(hm(p.s)+'–'+hm(p.e)); }
      });
    });
    const rows = Object.values(buckets).sort((a,b)=> a.start - b.start);
    const rowsForTable = (by==='hour') ? rows.filter(r=> r.occ) : rows;
    const headers = (by==='hour') ? ['Day','Date','Hour Range','Occurrences','Total Duration']
                                  : ['Day','Date','Occurrences','Total Duration'];
    const thead = '<thead><tr>' + headers.map(h=>`<th>${h}</th>`).join('') + '</tr></thead>';
    const trs = rowsForTable.map(r=>{
      const d = r.start;
      const cells = (by==='hour')
        ? [dayName(d), ymd(d), (r.ranges && r.ranges.length ? r.ranges.join('<br>') : ''), String(r.occ), (typeof formatDuration==='function' ? formatDuration(r.sec) : (Math.round(r.sec)+'s'))]
        : [dayName(d), ymd(d), String(r.occ), (typeof formatDuration==='function' ? formatDuration(r.sec) : (Math.round(r.sec)+'s'))];
      return '<tr>' + cells.map(c=>`<td>${c}</td>`).join('') + '</tr>';
    }).join('');
    return `<table>${thead}<tbody>${trs}</tbody></table>`;
  }
  const title = `Details: ${eventName} | Turbine: ${deviceName}`;
  return `<section style="page-break-inside:avoid;margin-top:12px">
    <h2>${title}</h2>
    <h3>By Day</h3>
    ${build('day')}
    <h3>By Hour</h3>
    ${build('hour')}
  </section>`;
}

async function exportTableAndChartToPDF(){
    const table = document.querySelector('#table-container table');
    if (!table) { alert('No table to export yet.'); return; }
    // Clone current table
    const clone = table.cloneNode(true);
    const wrapper = document.createElement('div');
    const tbl = document.createElement('table');
    tbl.innerHTML = clone.innerHTML;
    wrapper.appendChild(tbl);

// --- Remove "Details" column from the cloned table before exporting ---
try {
  const headRow = tbl.querySelector('thead tr');
  let detailsIdx = -1;
  if (headRow) {
    const ths = Array.from(headRow.children);
    detailsIdx = ths.findIndex(th => (th.textContent || '').trim().toLowerCase() === 'details');
    if (detailsIdx >= 0) {
      headRow.removeChild(headRow.children[detailsIdx]);
      tbl.querySelectorAll('tbody tr').forEach(tr => {
        if (tr.children.length > detailsIdx) tr.removeChild(tr.children[detailsIdx]);
      });
    }
  }
} catch (e) { console.warn('Failed to strip Details column for PDF', e); }

// Ask user whether to include per-row details
    const includeDetails = await (window.confirmIncludeDetails ? window.confirmIncludeDetails() : Promise.resolve(false));
    let detailsHTML = '';
    if (includeDetails) {
      try {
        const rows = Array.from(document.querySelectorAll('#table-container table tbody tr'));
        rows.forEach((tr, idx) => {
          const tds = tr.querySelectorAll('td');
          const ev = tds[0] ? tds[0].textContent.trim() : '';
          const dev = tds[3] ? tds[3].textContent.trim() : '';
          if (ev && dev) detailsHTML += __buildDetailsHTMLFor(ev, dev);
        });
      } catch (e) { console.warn('Details build failed', e); }
    }
// Try to capture chart canvas
    const canvas = document.getElementById('analysis-chart');
    let chartDataUrl = '';
    try {
      if (canvas && canvas.width && canvas.height) {
        chartDataUrl = canvas.toDataURL('image/png');
      }
    } catch (_) {}

    // Metrics
    const metrics = {
      alarm: (document.getElementById('metric-alarm')?.textContent || '').trim(),
      count: (document.getElementById('metric-count')?.textContent || '').trim(),
      duration: (document.getElementById('metric-duration')?.textContent || '').trim(),
    };

    const docHtml = buildPrintableHTML(wrapper.innerHTML + (includeDetails ? detailsHTML : ''), chartDataUrl, metrics);
    const win = window.open('', '_blank');
    win.document.open();
    win.document.write(docHtml);
    win.document.close();
  }

  function bindOnce(){
    // make sure button exists then bind single listener
    const ensureBtn = window.__ensurePdfButton || (()=>{});
    const btn = ensureBtn();
    if (!btn) return;
    // Remove any previous listeners by replacing the node
    const cloneBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(cloneBtn, btn);
    cloneBtn.addEventListener('click', exportTableAndChartToPDF);
  }

  // bind on DOM ready + after table renders
  document.addEventListener('DOMContentLoaded', bindOnce);
  window.addEventListener('load', bindOnce);
  // Expose to call after updateTable()
  window.__bindPdfExport = bindOnce;
})();

// === Robust CSV/Excel export: use the currently visible table ===
(function ensureDOMTableExports(){
  // Convert the on-screen table to a 2D array (AOA)
  function getCurrentTableAOA(){
    const table = document.querySelector('#table-container table');
    if (!table) return [];
    const aoa = [];
    const ths = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    if (ths.length) aoa.push(ths);
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(tr => {
      const tds = Array.from(tr.children).map(td => (td.textContent || '').trim());
      aoa.push(tds);
    });
    return aoa;
  }

  // CSV export straight from the DOM table
  function exportCSVFromDOM(){
    const aoa = getCurrentTableAOA();
    if (!aoa || aoa.length === 0) {
      alert('No table data to export.');
      return;
    }
    function csvEscape(s){
      s = String(s).replace(/\r?\n/g, ' ').replace(/\r/g, ' ');
      if (/[\",;\t]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }
    const csv = aoa.map(row => row.map(csvEscape).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'alarm_table.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  }

  // Excel export straight from DOM table (requires XLSX; load if needed)
  function exportExcelFromDOM(){
    const aoa = getCurrentTableAOA();
    if (!aoa || aoa.length === 0) {
      alert('No table data to export.');
      return;
    }
    function _go(){
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      // Auto width
      const colWidths = aoa[0].map((_, ci) => {
        let w = 10;
        for (let ri=0; ri<aoa.length; ri++){
          const v = (aoa[ri][ci] ?? '').toString();
          w = Math.max(w, Math.min(60, v.length + 2));
        }
        return { wch: w };
      });
      ws['!cols'] = colWidths;
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Alarm Table');
      XLSX.writeFile(wb, 'alarm_table.xlsx');
    }
    if (typeof XLSX === 'undefined'){
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js';
      s.onload = _go;
      s.onerror = () => alert('Failed to load Excel library. Please connect to the internet.');
      document.head.appendChild(s);
    } else {
      _go();
    }
  }

  // Rebind buttons to these robust exporters (single listeners)
  function bindExportButtons(){
    const csvBtn = document.getElementById('export-btn');
    const xlsBtn = document.getElementById('export-excel-btn');
    if (csvBtn){
      const clone = csvBtn.cloneNode(true);
      csvBtn.parentNode.replaceChild(clone, csvBtn);
      clone.addEventListener('click', exportCSVFromDOM);
    }
    if (xlsBtn){
      const clone = xlsBtn.cloneNode(true);
      xlsBtn.parentNode.replaceChild(clone, xlsBtn);
      clone.addEventListener('click', exportExcelFromDOM);
    }
  }

  document.addEventListener('DOMContentLoaded', bindExportButtons);
  window.addEventListener('load', bindExportButtons);
  // Make callable after each table rebuild
  window.__bindDomTableExports = bindExportButtons;
})();


// === Ensure ALL export buttons exist & are visible in one row ===
(function ensureAllExportButtons(){
  function findButtonsContainer(){
    // Prefer the same toolbar the file already uses (below the table)
    const group = document.querySelector('#table-container + div, #table-container ~ div');
    if (group && group.querySelector('button')) return group;
    // Fallback: create a group under the table
    let wrap = document.getElementById('table-container');
    if (!wrap) wrap = document.body;
    let g = wrap.nextElementSibling;
    if (!g || g.tagName !== 'DIV') { g = document.createElement('div'); wrap.parentNode.insertBefore(g, wrap.nextSibling); }
    g.style.display = 'flex'; g.style.flexWrap = 'wrap'; g.style.gap = '8px'; g.style.marginTop = '8px';
    return g;
  }
  function ensureBtn(id, label){
    let b = document.getElementById(id);
    if (!b){
      b = document.createElement('button');
      b.id = id; b.textContent = label;
      b.style.padding = '6px 12px';
      b.style.borderRadius = '10px';
      b.style.border = '1px solid #e5e7eb';
      b.style.fontWeight = '600';
      b.style.cursor = 'pointer';
      findButtonsContainer().appendChild(b);
    }
    b.style.display = 'inline-block';
    b.removeAttribute('hidden');
    b.classList.remove('hidden');
    return b;
  }
  function ensureAll(){
    const a = ensureBtn('export-btn', 'Export table (CSV)');
    const b = ensureBtn('export-excel-btn', 'Export table (Excel)');
    const c = ensureBtn('export-pdf-btn', 'Export table (PDF)');
    return {csv:a, xls:b, pdf:c};
  }
  window.__ensureAllExportButtons = ensureAll;
  document.addEventListener('DOMContentLoaded', ensureAll);
  window.addEventListener('load', ensureAll);
})();

// === Robust exporters that use the VISIBLE table (DOM) ===
(function bindDomExporters(){
  function getCurrentTableAOA(){
    const table = document.querySelector('#table-container table');
    if (!table) return [];
    const aoa = [];
    const ths = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim());
    if (ths.length) aoa.push(ths);
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach(tr => aoa.push(Array.from(tr.children).map(td => (td.textContent||'').trim())));
    return aoa;
  }
  function exportCSV(){
    const aoa = getCurrentTableAOA();
    if (!aoa.length) { alert('No table data to export.'); return; }
    const esc = s => {
      s = String(s).replace(/\r?\n/g,' ').replace(/\r/g,' ');
      return /[\",;\t]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
    };
    const csv = aoa.map(r => r.map(esc).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'alarm_table.csv';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(a.href);
  }
  function exportExcel(){
    const aoa = getCurrentTableAOA();
    if (!aoa.length) { alert('No table data to export.'); return; }
    function go(){
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      ws['!cols'] = aoa[0].map((_,i)=>({wch: Math.min(60, Math.max(10, Math.max(...aoa.map(r=>(r[i]||'').toString().length+2))))}));
      const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, 'Alarm Table'); XLSX.writeFile(wb, 'alarm_table.xlsx');
    }
    if (typeof XLSX==='undefined'){ const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js'; s.onload=go; s.onerror=()=>alert('Failed to load Excel library.'); document.head.appendChild(s); }
    else go();
  }
  function exportPDF(){
    // If a dedicated PDF exporter exists, call it; else quick fallback prints table only
    if (typeof exportTableAndChartToPDF === 'function') return exportTableAndChartToPDF();
    const table = document.querySelector('#table-container table'); if (!table){ alert('No table to export.'); return; }
    const clone = table.cloneNode(true); const wrap = document.createElement('div'); const tbl = document.createElement('table'); tbl.innerHTML=clone.innerHTML; wrap.appendChild(tbl);
    const html = `<!doctype html><html><head><meta charset="utf-8"><style>@page{size:A4 landscape;margin:12mm} table{width:100%;border-collapse:collapse} th,td{border:1px solid #e5e7eb;padding:6px 8px} thead{display:table-header-group}</style></head><body>${wrap.innerHTML}<script>addEventListener('load',()=>setTimeout(()=>print(),50));<\/script></body></html>`;
    const w = window.open('','_blank'); w.document.open(); w.document.write(html); w.document.close();
  }
  function bind(){
    const {csv, xls, pdf} = (window.__ensureAllExportButtons && window.__ensureAllExportButtons()) || {};
    if (csv){ const c=csv.cloneNode(true); csv.parentNode.replaceChild(c, csv); c.addEventListener('click', exportCSV); }
    if (xls){ const x=xls.cloneNode(true); xls.parentNode.replaceChild(x, xls); x.addEventListener('click', exportExcel); }
    if (pdf){ const p=pdf.cloneNode(true); pdf.parentNode.replaceChild(p, pdf); p.addEventListener('click', exportPDF); }
  }
  window.__bindDomExportsAll = bind;
  document.addEventListener('DOMContentLoaded', bind);
  window.addEventListener('load', bind);
})();
</script>


<!-- Alarm Details Modal (show BOTH: day & hour) -->
<style>
  #alarm-details-overlay{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:10000}
  #alarm-details{background:#fff;max-width:980px;width:92%;border-radius:12px;padding:14px;max-height:85vh;overflow:auto;box-shadow:0 20px 50px rgba(2,6,23,.25)}
  #alarm-details .header{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px}
  #alarm-details .title{font-weight:800;font-size:16px}
  #alarm-details .controls{display:flex;gap:10px;align-items:center}
  #alarm-details .btn{border:1px solid #e5e7eb;border-radius:8px;padding:4px 8px;cursor:pointer}
  #alarm-details table{width:100%;border-collapse:collapse;margin-top:6px;border:1px solid #94a3b8}
  #alarm-details thead th{background:#0f172a;color:#fff;padding:8px;border:1px solid #94a3b8}
  #alarm-details tbody td{padding:8px;border:1px solid #94a3b8}
  #alarm-details .meta{color:#475569;font-size:12px;margin:6px 0 10px 0}
  #alarm-details h4{margin:10px 0 4px 0; font-size:14px}
</style>
<div id="alarm-details-overlay">
  <div id="alarm-details" role="dialog" aria-modal="true">
    <div class="header">
      <div class="title">Details</div>
      <div class="controls">
        <button id="alarm-details-img" class="btn">Export Image</button>
        <button id="alarm-details-pdf" class="btn">Export PDF</button>
        <button id="alarm-details-close" class="btn">Close</button>
      </div>
    </div>
    <div class="meta"></div>
    <div class="table-wrap">
      <h4>By Day</h4>
      <table class="dt dt-day">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="table-wrap">
      <h4>By Hour</h4>
      <canvas id="alarm-details-hour-chart" style="height:380px;max-height:380px;margin-bottom:10px;"></canvas>
      <table class="dt dt-hour">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>
<script>
// === Alarm details logic (both day & hour) ===
(function(){
  const overlay = document.getElementById('alarm-details-overlay');
  const root = document.getElementById('alarm-details');
  if (!overlay || !root) return;
  const els = {
    title: root.querySelector('.title'),
    meta: root.querySelector('.meta'),
    theadDay: root.querySelector('.dt-day thead'),
    tbodyDay: root.querySelector('.dt-day tbody'),
    theadHour: root.querySelector('.dt-hour thead'),
    tbodyHour: root.querySelector('.dt-hour tbody'),
    close: root.querySelector('#alarm-details-close'),
    pdf: root.querySelector('#alarm-details-pdf'),
    img: root.querySelector('#alarm-details-img'),
  };

  let hourChart = null;
  const hourChartCanvas = root.querySelector('#alarm-details-hour-chart');

  function ensureAlarmChartJs(){
    if (typeof loadChartJS === 'function') {
      return loadChartJS();
    }
    return new Promise((resolve, reject)=>{
      if (window.Chart) { resolve(); return; }
      const script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
      script.onload = ()=>resolve();
      script.onerror = ()=>reject();
      document.head.appendChild(script);
    });
  }

  function renderHourChart(rows){
    if (!hourChartCanvas) return;
    if (!rows || !rows.length) {
      if (hourChart) { hourChart.destroy(); hourChart = null; }
      return;
    }
    if (!window.Chart) return;
    const labels = [];
    const dates = [];
    const occData = [];
    const durData = [];
    rows.forEach(r=>{
      if (!r || !r.start) return;
      labels.push(hourRange(r.start));
      dates.push(ymd(r.start));
      occData.push(r.occ || 0);
      durData.push((r.sec || 0)/60);
    });
    const ctx = hourChartCanvas.getContext('2d');
    if (!ctx) return;
    if (hourChart) hourChart.destroy();

    const dateLabelPlugin = {
      id: 'hourDateLabels',
      afterDraw(chart, args, pluginOptions){
        const xScale = chart.scales.x;
        const ctx = chart.ctx;
        if (!xScale) return;
        ctx.save();
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.font = '10px sans-serif';
        const ticks = xScale.ticks || [];
        const bottom = xScale.bottom;
        ticks.forEach((tick, index)=>{
          const labelIndex = typeof tick.value === 'number' ? tick.value : index;
          const date = dates[labelIndex];
          const prevDate = labelIndex > 0 ? dates[labelIndex-1] : null;
          if (!date || date === prevDate) return;
          const x = xScale.getPixelForValue(labelIndex);
          // draw small separator line بين الأيام
          ctx.beginPath();
          ctx.moveTo(x, bottom);
          ctx.lineTo(x, bottom + 10);
          ctx.lineWidth = 1;
          ctx.strokeStyle = '#999';
          ctx.stroke();
          // draw date تحت الساعات
          ctx.fillText(date, x, bottom + 14);
        });
        ctx.restore();
      }
    };

    hourChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          {
            label: 'Occurrences',
            data: occData,
          },
          {
            label: 'Duration (min)',
            data: durData,
          }
        ]
      },
      plugins: [dateLabelPlugin],
      options: {
        responsive: true,
        maintainAspectRatio: false,
        layout: {
          padding: {
            bottom: 64
          }
        },
        plugins: {
          legend: { position: 'top' },
          title: { display: false }
        },
        scales: {
          x: {
            ticks: {
              maxRotation: 90,
              minRotation: 90,
              autoSkip: false,
              callback: function(value, index){
                const hour = labels[index] || '';
                return hour;
              }
            }
          },
          y: {
            beginAtZero: true,
            max: (function(){
              var all = occData.concat(durData).filter(function(v){ return v != null && !isNaN(v); });
              if (!all.length) return 5;
              var max = Math.max.apply(null, all);
              var top = Math.ceil(max / 5) * 5;
              return Math.max(5, top);
            })(),
            ticks: {
              stepSize: 5,
              autoSkip: false,
              precision: 0
            },
            title: {
              display: true,
              text: 'Minutes'
            }
          }
        }
      }
    });
  }

  function pad(n){ return String(n).padStart(2,'0'); }
  function ymd(d){ return d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate()); }
  function dayName(d){
    try { return d.toLocaleDateString('en-US',{weekday:'long'}); }
    catch(_) { return ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][d.getDay()]; }
  }
  function hourRange(d){
    const h = pad(d.getHours()); const h2 = pad((d.getHours()+1)%24);
    return h+':00 – '+h2+':00';
  }
  function hm(d){ return pad(d.getHours())+':'+pad(d.getMinutes()); }
  function hm(d){ return pad(d.getHours())+':'+pad(d.getMinutes()); }
  function nextBoundary(d, by){
    const n = new Date(d);
    if (by==='day') n.setHours(24,0,0,0);
    else n.setHours(n.getHours()+1,0,0,0);
    return n;
  }
  function split(cs, ce, by){
    const segs=[]; let s=new Date(cs);
    while (s < ce){
      const bEnd = nextBoundary(s, by);
      const e = (ce < bEnd) ? ce : bEnd;
      segs.push({s, e, sec:(e - s)/1000});
      s = e;
    }
    return segs;
  }
  function getEventNameFromRow(row){
    if (colMap.event && row[colMap.event] && row[colMap.event].trim()!=='') return row[colMap.event].trim();
    if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim()!=='') return row[colMap.subevent].trim();
    return '';
  }

  function buildTable(by, thead, tbody, eventName, deviceName){
    thead.innerHTML=''; tbody.innerHTML='';
    const trh = document.createElement('tr');
    const headers = (by==='hour')
      ? ['Day','Date','Hour Range','Occurrences','Total Duration']
      : ['Day','Date','Occurrences','Total Duration'];
    headers.forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
    thead.appendChild(trh);

    const buckets = {};
    const dataSrc = (typeof filteredData !== 'undefined' && filteredData && filteredData.length) ? filteredData : dataset;

    dataSrc.forEach(row=>{
      const ev = getEventNameFromRow(row);
      if (ev !== eventName) return;
      const rawDev = row[colMap.device];
      if (!rawDev) return;
      const dev = String(rawDev).trim();
      if (dev !== deviceName) return;

      const dObj = (typeof parseRowDate === 'function') ? parseRowDate(row) : {};
      const startDate = dObj && dObj.startDate; const endDate = dObj && dObj.endDate;
      if (!startDate || !endDate) return;

      const clip = (typeof clippedDates === 'function' && (globalStartFilter || globalEndFilter))
        ? clippedDates(startDate, endDate, globalStartFilter, globalEndFilter)
        : { cs: startDate, ce: endDate };
      const cs = clip.cs, ce = clip.ce;
      if (!cs || !ce) return;

      // Count occurrence in the bucket it STARTED in
      const startKey = (by==='day') ? ymd(cs) : (ymd(cs)+' '+pad(cs.getHours()));
      if (!buckets[startKey]) buckets[startKey] = { start: (by==='day'? new Date(cs.getFullYear(), cs.getMonth(), cs.getDate()) : new Date(cs.getFullYear(), cs.getMonth(), cs.getDate(), cs.getHours())), sec: 0, occ: 0, ranges: [] };
      buckets[startKey].occ += 1;

      // Distribute duration across buckets
      split(cs, ce, by).forEach(p=>{
        const key = (by==='day') ? ymd(p.s) : (ymd(p.s)+' '+pad(p.s.getHours()));
        if (!buckets[key]) buckets[key] = { start: p.s, sec: 0, occ: 0, ranges: [] };
        buckets[key].sec   += p.sec;
        if (by==='hour') { buckets[key].ranges.push(hm(p.s)+'–'+hm(p.e)); }
      });
    });

    const rows = Object.values(buckets).sort((a,b)=> a.start - b.start);
    const rowsForTable = (by==='hour') ? rows.filter(r=> r.occ) : rows;
    rowsForTable.forEach(r=>{
      const d = r.start;
      const tr = document.createElement('tr');
      if (by==='hour') {
        const td1=document.createElement('td'); td1.textContent=dayName(d);
        const td2=document.createElement('td'); td2.textContent=ymd(d);
        const td3=document.createElement('td'); td3.innerHTML=(r.ranges && r.ranges.length) ? r.ranges.map(x=>`<span>${x}</span>`).join('<br>') : '';
        const td4=document.createElement('td'); td4.textContent=String(r.occ);
        const td5=document.createElement('td'); td5.textContent=(typeof formatDuration==='function' ? formatDuration(r.sec) : (Math.round(r.sec)+'s'));
        tr.append(td1,td2,td3,td4,td5);
      } else {
        const td1=document.createElement('td'); td1.textContent=dayName(d);
        const td2=document.createElement('td'); td2.textContent=ymd(d);
        const td3=document.createElement('td'); td3.textContent=String(r.occ);
        const td4=document.createElement('td'); td4.textContent=(typeof formatDuration==='function' ? formatDuration(r.sec) : (Math.round(r.sec)+'s'));
        tr.append(td1,td2,td3,td4);
      }
      tbody.appendChild(tr);
    });
    return rowsForTable;
  }

  function openDetails(eventName, deviceName){
    els.title.textContent = 'Details: ' + eventName + '  |  Turbine: ' + deviceName;
    const dayRows  = buildTable('day',  els.theadDay,  els.tbodyDay,  eventName, deviceName);
    const hourRows = buildTable('hour', els.theadHour, els.tbodyHour, eventName, deviceName);
    ensureAlarmChartJs().then(()=>{ renderHourChart(hourRows || []); }).catch(()=>{});
    overlay.style.display = 'flex';
  }
  function close(){ overlay.style.display='none'; }
  els.close.addEventListener('click', close);
  overlay.addEventListener('click', (e)=>{ if (e.target === overlay) close(); });

  function exportDetailsImage(){
    try{
      const dayTable = root.querySelector('.dt-day');
      if (!dayTable) {
        alert('No By Day data to export.');
        return;
      }
      if (!hourChartCanvas || typeof hourChartCanvas.toDataURL !== 'function') {
        alert('Chart is not ready yet.');
        return;
      }
      // Grab chart as image
      const chartDataUrl = hourChartCanvas.toDataURL('image/png');
      const img = new Image();
      img.onload = function(){
        try{
          const headers = Array.from(dayTable.querySelectorAll('thead th')).map(th => th.textContent.trim());
          const rows = Array.from(dayTable.querySelectorAll('tbody tr')).map(tr =>
            Array.from(tr.children).map(td => td.textContent.trim())
          );
          const colCount = headers.length || (rows[0] ? rows[0].length : 0);
          if (!colCount) {
            alert('No By Day data to export.');
            return;
          }

          const chartWidth  = img.width || hourChartCanvas.width || 1000;
          const chartHeight = img.height || hourChartCanvas.height || 300;
          const marginX = 40;
          const marginTop = 20;
          const headerHeight = 26;
          const rowHeight = 22;
          const tableWidth = chartWidth - marginX * 2;
          const tableHeight = headerHeight + rows.length * rowHeight + 20;
          const totalHeight = marginTop + chartHeight + 30 + tableHeight + 20;

          const canvas = document.createElement('canvas');
          canvas.width = chartWidth;
          canvas.height = totalHeight;
          const ctx = canvas.getContext('2d');

          // Background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Draw chart
          ctx.drawImage(img, 0, marginTop, chartWidth, chartHeight);

          // Draw table title
          let yTop = marginTop + chartHeight + 30;
          ctx.fillStyle = '#0f172a';
          ctx.font = '16px system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif';
          ctx.textBaseline = 'alphabetic';
          ctx.fillText('By Day', marginX, yTop - 8);

          // Draw table grid
          const tableLeft = marginX;
          const colWidth = tableWidth / colCount;
          const headerY = yTop;
          ctx.textBaseline = 'middle';

          // Header background
          ctx.fillStyle = '#0f172a';
          ctx.fillRect(tableLeft, headerY, tableWidth, headerHeight);
          ctx.strokeStyle = '#e5e7eb';
          ctx.lineWidth = 1;

          // Header text
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif';
          headers.forEach((text, ci) => {
            const x = tableLeft + ci * colWidth;
            ctx.strokeRect(x, headerY, colWidth, headerHeight);
            ctx.fillText(text, x + 6, headerY + headerHeight / 2);
          });

          // Body rows
          let y = headerY + headerHeight;
          ctx.fillStyle = '#0f172a';
          rows.forEach(row => {
            row = row || [];
            for (let ci = 0; ci < colCount; ci++) {
              const x = tableLeft + ci * colWidth;
              ctx.strokeRect(x, y, colWidth, rowHeight);
              const txt = (row[ci] || '');
              ctx.fillText(txt, x + 6, y + rowHeight / 2);
            }
            y += rowHeight;
          });

          const outUrl = canvas.toDataURL('image/png');
          const a = document.createElement('a');
          const baseName = (els.title && els.title.textContent ? els.title.textContent : 'details')
            .replace(/[^\w\-]+/g, '_')
            .slice(0, 80) || 'details';
          a.href = outUrl;
          a.download = baseName + '_byday_chart.png';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        } catch(innerErr){
          console.error('Image export failed', innerErr);
          alert('Failed to export image.');
        }
      };
      img.onerror = function(){
        alert('Failed to capture chart image.');
      };
      img.src = chartDataUrl;
    }catch(err){
      console.error('Image export failed', err);
    }
  }

  function exportDetailsPDF(){
    try{
      const title = els.title.textContent || 'Details';
      const dayTable  = root.querySelector('.dt-day');
      const hourTable = root.querySelector('.dt-hour');
      const metaHtml  = els.meta ? els.meta.innerHTML : '';
      let chartImgHTML = '';
      if (hourChartCanvas && typeof hourChartCanvas.toDataURL === 'function') {
        try{
          const dataUrl = hourChartCanvas.toDataURL('image/png');
          if (dataUrl) {
            chartImgHTML =
              '<h3>By Hour Chart</h3>' +
              '<div class="chart-wrap"><img src="' + dataUrl + '" alt="By Hour chart"></div>';
          }
        }catch(e){}
      }
      const html = `<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>${title}</title>
  <style>
    *{box-sizing:border-box}
    body{font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", "Segoe UI Emoji","Apple Color Emoji","Segoe UI Emoji"; color:#0f172a; padding:18px}
    h2{margin:0 0 12px 0; font-size:18px}
    h3{margin:16px 0 8px 0; font-size:14px}
    table{width:100%; border-collapse:collapse; page-break-inside:auto; border:1px solid #94a3b8}
    thead{display:table-header-group}
    tfoot{display:table-row-group}
    tr{page-break-inside:avoid; page-break-after:auto}
    th{background:#0f172a; color:#fff; padding:8px; border:1px solid #94a3b8; text-align:left}
    td{padding:8px; border:1px solid #94a3b8}
    .meta{font-size:12px; color:#475569; margin:4px 0 10px 0}
    .chart-wrap{margin:10px 0 18px 0; text-align:center; page-break-inside:avoid}
    .chart-wrap img{max-width:100%; height:auto; border:1px solid #e5e7eb; padding:4px; border-radius:4px}
    @media print { @page { size: A4; margin: 12mm } }
  </style>
</head>
<body>
  <h2>${title}</h2>
  <div class="meta">${metaHtml}</div>
  ${chartImgHTML}
  <h3>By Day</h3>
  ${dayTable ? dayTable.outerHTML : ''}
  <h3>By Hour</h3>
  ${hourTable ? hourTable.outerHTML : ''}
</body>
</html>`;
      const w = window.open('', 'details_pdf');
      if (!w) return;
      w.document.open();
      w.document.write(html);
      w.document.close();
      w.focus();
      w.print();
      // do not auto-close: some browsers need the window for saving as PDF
    }catch(err){ console.error('PDF export failed', err); }
  }
  if (els.pdf) els.pdf.addEventListener('click', exportDetailsPDF);
  if (els.img) els.img.addEventListener('click', exportDetailsImage);


  window.openAlarmDetails = openDetails;
})();
</script>

<!-- Confirm Include Details Modal -->
<style>
  #confirm-include-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:10010}
  #confirm-include{background:#fff;max-width:480px;width:92%;border-radius:12px;padding:16px;box-shadow:0 20px 50px rgba(2,6,23,.25)}
  #confirm-include .head{font-weight:800;margin:0 0 8px 0;font-size:16px}
  #confirm-include .msg{color:#334155;font-size:14px;margin-bottom:12px}
  #confirm-include .actions{display:flex;gap:10px;justify-content:flex-end}
  #confirm-include .btn{border:1px solid #e5e7eb;border-radius:8px;padding:6px 12px;cursor:pointer;font-weight:600}
</style>
<div id="confirm-include-overlay" role="dialog" aria-modal="true" aria-labelledby="confirm-include-title">
  <div id="confirm-include">
    <div id="confirm-include-title" class="head">Export PDF</div>
    <div class="msg">Include per‑alarm details (by day & hour) after the main table?</div>
    <div class="actions">
      <button id="confirm-include-no"  class="btn">No</button>
      <button id="confirm-include-yes" class="btn">Yes</button>
    </div>
  </div>
</div>
<script>
(function(){
  // Promise-based confirmation
  window.confirmIncludeDetails = function(){
    return new Promise(resolve => {
      const overlay = document.getElementById('confirm-include-overlay');
      const yes = document.getElementById('confirm-include-yes');
      const no  = document.getElementById('confirm-include-no');
      if (!overlay || !yes || !no) { resolve(false); return; }
      function cleanup(){
        overlay.style.display = 'none';
        yes.removeEventListener('click', onYes);
        no.removeEventListener('click', onNo);
        overlay.removeEventListener('click', onOverlay);
        document.removeEventListener('keydown', onKey);
      }
      function onYes(){ cleanup(); resolve(true); }
      function onNo(){ cleanup(); resolve(false); }
      function onOverlay(e){ if (e.target === overlay) onNo(); }
      function onKey(e){ if (e.key === 'Escape') onNo(); }
      yes.addEventListener('click', onYes);
      no.addEventListener('click', onNo);
      overlay.addEventListener('click', onOverlay);
      document.addEventListener('keydown', onKey);
      overlay.style.display = 'flex';
      // focus Yes for quick Enter confirm
      setTimeout(()=>yes.focus(), 0);
    });
  };
})();
</script>

<!-- Emergency pre-alarms Modal -->
<style>
  #emergency-overlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,0.45);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:10020;
  }
  #emergency-panel{
    background:#fff;
    max-width:1100px;
    width:96%;
    max-height:85vh;
    overflow:auto;
    border-radius:12px;
    padding:14px;
    box-shadow:0 20px 50px rgba(15,23,42,0.25);
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    font-size:13px;
    color:#0f172a;
  }
  #emergency-panel .header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
    margin-bottom:8px;
  }
  #emergency-panel .title{font-weight:800;font-size:16px;}
  #emergency-panel .controls{display:flex;gap:8px;align-items:center;}
  #emergency-panel .btn{
    border:1px solid #e5e7eb;
    border-radius:8px;
    padding:4px 10px;
    cursor:pointer;
    background:#f8fafc;
  }
  #emergency-panel .meta{
    font-size:12px;
    color:#64748b;
    margin-bottom:8px;
  }
  #emergency-panel table{
    width:100%;
    border-collapse:collapse;
    margin-top:6px;
    border:1px solid #cbd5f5;
  }
  #emergency-panel thead th{
    background:#0f172a;
    color:#fff;
    padding:6px 8px;
    border:1px solid #cbd5f5;
    font-size:12px;
  }
  #emergency-panel tbody td{
    padding:6px 8px;
    border:1px solid #e5e7eb;
    font-size:12px;
  }
  #emergency-panel tbody tr:nth-child(even){
    background:#f9fafb;
  }
</style>

<div id="emergency-overlay">
  <div id="emergency-panel" role="dialog" aria-modal="true">
    <div class="header">
      <div class="title">Emergency pre-alarms</div>
      <div class="controls">
        <span id="emergency-info" class="meta"></span>
        <button id="emergency-close" class="btn">Close</button>
      </div>
    </div>
    <div class="meta">
      Shows turbines that entered <strong>EMERGENCY</strong> and the <strong>Alarm/Warning</strong> active just before it.
    </div>
    <table id="emergency-table">
      <thead>
        <tr>
          <th>Turbine</th>
          <th>Emergency start</th>
          <th>Emergency end</th>
          <th>Pre-alarm name</th>
          <th>Category</th>
          <th>Pre-alarm start</th>
          <th>Pre-alarm end</th>
          <th>Δt (from pre-alarm start)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</div>

<script>
(function(){
  const WINDOW_MIN_BEFORE = 30; // minutes before EMERGENCY

  const btn      = document.getElementById('btn-emergency-seq');
  const overlay  = document.getElementById('emergency-overlay');
  const panel    = document.getElementById('emergency-panel');
  const closeBtn = document.getElementById('emergency-close');
  const infoEl   = document.getElementById('emergency-info');
  const tbody    = panel ? panel.querySelector('#emergency-table tbody') : null;

  if (!btn || !overlay || !panel || !tbody) return;

  function fmtDateTime(d){
    if (!(d instanceof Date) || isNaN(d)) return '';
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    const h = String(d.getHours()).padStart(2,'0');
    const mi = String(d.getMinutes()).padStart(2,'0');
    const s = String(d.getSeconds()).padStart(2,'0');
    return `${y}-${m}-${day} ${h}:${mi}:${s}`;
  }

  function fmtDuration(sec){
    if (typeof formatDuration === 'function') return formatDuration(sec);
    sec = Math.max(0, Math.round(sec||0));
    const h = Math.floor(sec/3600); sec -= h*3600;
    const m = Math.floor(sec/60);   sec -= m*60;
    const s = sec;
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  function getEventNameFromRow(row){
    if (colMap.event && row[colMap.event] && row[colMap.event].trim()!=='') return row[colMap.event].trim();
    if (colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim()!=='') return row[colMap.subevent].trim();
    return '';
  }

  function classifyRowType(row){
    const hasSub = colMap.subevent && row[colMap.subevent] && row[colMap.subevent].trim() !== '';
    if (hasSub) return 'Other';
    const rawCat = row[colMap.category] || '';
    const cat = String(rawCat).toLowerCase();
    if (cat.includes('alarm')   || rawCat === 'إنذار')  return 'Alarm';
    if (cat.includes('warning') || rawCat === 'تحذير')  return 'Warning';
    if (cat.includes('state')   || rawCat === 'حالة')   return 'State';
    return 'Other';
  }

  function applyTimeAndDeviceFilter(row){
    if (globalStartFilter || globalEndFilter) {
      const d = parseRowDate(row);
      const startDate = d && d.startDate;
      const endDate   = d && d.endDate;
      if (!startDate || !endDate) return false;
      if (globalStartFilter && endDate < globalStartFilter) return false;
      if (globalEndFilter   && startDate > globalEndFilter) return false;
    }

    if (deviceFilterTerm) {
      const rawDev = row[colMap.device] || '';
      const devStr = String(rawDev).trim().toLowerCase();
      const devDigits = devStr.replace(/\D/g,'');
      const filterDigits = deviceFilterTerm.replace(/\D/g,'');
      const containsText   = devStr.includes(deviceFilterTerm);
      const containsDigits = filterDigits ? devDigits.includes(filterDigits) : true;
      if (!(containsText || containsDigits)) return false;
    }

    const rawDev = row[colMap.device];
    if (!rawDev) return false;
    const dev = String(rawDev).trim();
    if (!dev || dev.toLowerCase()==='unknown' || dev==='غير معروف') return false;

    return true;
  }

  
// original buildEmergencySequences moved to backend


  function openEmergencyModal(){
    const sequences = buildEmergencySequences();
    tbody.innerHTML = '';

    if (infoEl) {
      infoEl.textContent = `Window: Alarm/Warning whose end ≥ emergency start − ${WINDOW_MIN_BEFORE} min`;
    }

    if (!sequences.length){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 8;
      td.textContent = 'No emergency events found with pre-alarms in the current filters.';
      tr.appendChild(td);
      tbody.appendChild(tr);
    } else {
      sequences.forEach(s=>{
        const tr = document.createElement('tr');

        const tdDev   = document.createElement('td'); tdDev.textContent   = s.device;
        const tdEs    = document.createElement('td'); tdEs.textContent    = fmtDateTime(s.emergencyStart);
        const tdEe    = document.createElement('td'); tdEe.textContent    = fmtDateTime(s.emergencyEnd);
        const tdName  = document.createElement('td'); tdName.textContent  = s.preName;
        const tdCat   = document.createElement('td'); tdCat.textContent   = s.preCat;
        const tdPs    = document.createElement('td'); tdPs.textContent    = fmtDateTime(s.preStart);
        const tdPe    = document.createElement('td'); tdPe.textContent    = fmtDateTime(s.preEnd);
        const tdDelta = document.createElement('td'); tdDelta.textContent = fmtDuration(s.deltaSec);

        tr.append(tdDev, tdEs, tdEe, tdName, tdCat, tdPs, tdPe, tdDelta);
        tbody.appendChild(tr);
      });
    }

    overlay.style.display = 'flex';
  }

  function closeModal(){
    overlay.style.display = 'none';
  }

  btn.addEventListener('click', openEmergencyModal);
  closeBtn.addEventListener('click', closeModal);
  overlay.addEventListener('click', (e)=>{ if (e.target === overlay) closeModal(); });
})();

// ==== Backend API base for RGWE alarms ====
const RGWE_ALARMS_API_BASE = "https://rgwe-alarms.mohamedlasheen2019.workers.dev";

// === Backend-powered analysis & emergency sequences (server-side logic hidden) ===
async function updateAnalysis() {
  if (!Array.isArray(dataset) || !Array.isArray(filteredData) || !dataset.length) {
    if (typeof analysisSection !== 'undefined' && analysisSection) {
      analysisSection.style.display = 'none';
    }
    return;
  }
  try {
    const res = await fetch(RGWE_ALARMS_API_BASE + "/api/analysis", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        dataset,
        filteredData,
        colMap,
        selectedEvents: Array.from(selectedEvents || []),
        globalStartFilter: globalStartFilter ? globalStartFilter.toISOString() : null,
        globalEndFilter: globalEndFilter ? globalEndFilter.toISOString() : null,
        deviceFilterTerm
      })
    });
    if (!res.ok) throw new Error('Server error');
    const payload = await res.json();
    renderAnalysisFromServer(payload);
  } catch (err) {
    console.error(err);
    if (typeof analysisSection !== 'undefined' && analysisSection) {
      analysisSection.style.display = 'none';
    }
  }
}

function renderAnalysisFromServer(payload) {
  if (!payload || !payload.rows || !payload.rows.length) {
    if (typeof analysisSection !== 'undefined' && analysisSection) {
      analysisSection.style.display = 'none';
    }
    return;
  }

  if (typeof analysisSection !== 'undefined' && analysisSection) {
    analysisSection.style.display = 'block';
  }

  if (typeof metricAlarm !== 'undefined' && payload.metrics) {
    metricAlarm.textContent = payload.metrics.alarmLabel || metricAlarm.textContent;
  }
  if (typeof metricCount !== 'undefined' && payload.metrics) {
    metricCount.textContent = payload.metrics.totalCount;
  }
  if (typeof metricDuration !== 'undefined' && payload.metrics) {
    metricDuration.textContent = payload.metrics.totalDuration;
  }

  const container = document.getElementById('analysis-table-container');
  if (container) {
    container.innerHTML = '';
    const table = document.createElement('table');
    table.className = 'analysis-table';
    const thead = document.createElement('thead');
    thead.innerHTML = '<tr><th>Device</th><th>Occurrences</th><th>Total duration (min)</th></tr>';
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    payload.rows.forEach(row => {
      const tr = document.createElement('tr');
      tr.innerHTML =
        '<td>' + row.device + '</td>' +
        '<td>' + row.count + '</td>' +
        '<td>' + row.durationMinutes.toFixed(1) + '</td>';
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    container.appendChild(table);
  }

  if (typeof analysisChartCanvas !== 'undefined' && window.Chart && payload.chart) {
    if (window.analysisChartObj) {
      window.analysisChartObj.destroy();
    }
    const labels = payload.chart.labels || [];
    const counts = payload.chart.counts || [];
    const durations = payload.chart.durationsMin || [];
    const ctx = analysisChartCanvas.getContext('2d');
    window.analysisChartObj = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [
          { label: 'Occurrences', data: counts },
          { label: 'Duration (min)', data: durations }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false
      }
    });
  }
}

async function buildEmergencySequences() {
  if (!Array.isArray(dataset) || !dataset.length) {
    alert('Load the CSV file first.');
    return [];
  }
  try {
    const res = await fetch(RGWE_ALARMS_API_BASE + "/api/emergency-sequences", {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        dataset,
        colMap,
        globalStartFilter: globalStartFilter ? globalStartFilter.toISOString() : null,
        globalEndFilter: globalEndFilter ? globalEndFilter.toISOString() : null,
        deviceFilterTerm
      })
    });
    if (!res.ok) throw new Error('Server error');
    const payload = await res.json();
    return payload.sequences || [];
  } catch (err) {
    console.error(err);
    alert('Failed to load emergency sequences from server.');
    return [];
  }
}

</script>

<footer id="page-footer" role="contentinfo" aria-label="Credits">
  <div class="credit">Designed by <strong>Mohamed Lasheen</strong></div>
</footer>
</body>
</html>